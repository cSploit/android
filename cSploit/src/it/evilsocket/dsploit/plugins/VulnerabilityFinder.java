/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.SettingsActivity;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Databases.NationalVulnerability;
import it.evilsocket.dsploit.net.Databases.OpenSourcedVulnerability;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Port;
import it.evilsocket.dsploit.net.Target.Vulnerability;

public class VulnerabilityFinder extends Plugin {
    private final static String TAG = "VULNERABILITYFINDER";
    private final static int SEARCH_OSV = 1;
    private final static int SEARCH_CVE = 2;

    private ToggleButton mSearchToggleButton = null;
    private ProgressBar mSearchProgress = null;
    private ExpandableListView mListView = null;
    private ListViewAdapter mAdapter = null;
    private Thread mThread = null;
    private boolean mVersionMatching = true;

    private static Comparator<Vulnerability> sort_by_score = new Comparator<Vulnerability>() {
        @Override
        public int compare(Vulnerability o1, Vulnerability o2) {
            if (o1.severity > o2.severity)
                return -1;

            else if (o1.severity < o2.severity)
                return 1;

            else
                return 0;
        }
    };

    public class ListViewAdapter extends BaseExpandableListAdapter {
        private HashMap<String, ArrayList<Vulnerability>> mGroups = null;
        private Context mContext = null;

        public ListViewAdapter(Context context) {
            mGroups = new HashMap<String, ArrayList<Vulnerability>>();
            mContext = context;
        }

        public void clear() {
            Object[] keys = mGroups.keySet().toArray();

            for (Object key : keys) {
                mGroups.get(key).clear();
            }

            notifyDataSetChanged();
        }

        public boolean hasGroup(String name) {
            return mGroups.containsKey(name);
        }

        public void addGroup(String name) {
            mGroups.put(name, new ArrayList<Vulnerability>());
            notifyDataSetChanged();
        }

        public void addChild(String group, Vulnerability child) {
            if (!hasGroup(group))
                addGroup(group);

            ArrayList<Vulnerability> vulns = mGroups.get(group);
            if (!vulns.contains(child)) {
                vulns.add(child);
                Collections.sort(mGroups.get(group), sort_by_score);

                notifyDataSetChanged();
            }
        }

        private ArrayList<Vulnerability> getGroupAt(int position) {
            return mGroups.get(mGroups.keySet().toArray()[position]);
        }

        @Override
        public Object getChild(int groupPosition, int childPosition) {
            return getGroupAt(groupPosition).get(childPosition);
        }

        @Override
        public long getChildId(int groupPosition, int childPosition) {
            return (groupPosition * 10) + childPosition;
        }

        @Override
        public int getChildrenCount(int groupPosition) {
            return getGroupAt(groupPosition).size();
        }

        @Override
        public Object getGroup(int groupPosition) {
            return mGroups.keySet().toArray()[groupPosition];
        }

        @Override
        public int getGroupCount() {
            return mGroups.size();
        }

        @Override
        public long getGroupId(int groupPosition) {
            return groupPosition;
        }

        @Override
        public View getGroupView(int groupPosition, boolean isExpanded,
                                 View convertView, ViewGroup parent) {
            TextView row = (TextView) convertView;
            if (row == null)
                row = new TextView(mContext);

            row.setText(getGroup(groupPosition).toString());
            row.setTextSize(15);
            row.setTypeface(Typeface.DEFAULT_BOLD);
            row.setPadding(50, 0, 0, 0);

            return row;
        }

        @Override
        public View getChildView(int groupPosition, int childPosition,
                                 boolean isLastChild, View convertView, ViewGroup parent) {
            TextView row = (TextView) convertView;
            if (row == null)
                row = new TextView(mContext);

            Vulnerability cve = (Vulnerability) getChild(groupPosition,
                    childPosition);

            if (cve == null)
                row.setText(Html.fromHtml(getString(R.string.nothing_found)));
            else
                row.setText(Html.fromHtml("<font color=\"" + cve.getHtmlColor()
                        + "\"><b>" + cve.getIdentifier()
                        + "</b></font> : <small>" + cve.summary + "</small>"));

            row.setPadding(30, 0, 0, 0);

            return row;
        }

        @Override
        public boolean hasStableIds() {
            return true;
        }

        @Override
        public boolean isChildSelectable(int groupPosition, int childPosition) {
            return true;
        }
    }

    public VulnerabilityFinder() {
        super(R.string.vulnerability_finder,
                R.string.vulnerability_finder_desc,

                new Target.Type[]{Target.Type.ENDPOINT, Target.Type.REMOTE},
                R.layout.plugin_vulerability_finder, R.drawable.action_exploit);
    }

    private int getSeachMask() {
        String pref = System.getSettings().getString("SEARCH_OSVDB", "BOTH");
        if (pref.equals("OSVDB"))
            return SEARCH_OSV;
        else if (pref.equals("CVE"))
            return SEARCH_CVE;
        else
            return SEARCH_OSV | SEARCH_CVE;
    }

    public interface VulnerabilityReceiver {
        abstract void onVulnsFound(Vulnerability[] vulns);

        abstract void onEnd();
    }

    public Thread search(final Target target, final VulnerabilityReceiver listener, boolean exactVersionMatch) {
        int i;
        ArrayList<String> searched = new ArrayList<String>();

        final int search_mask = getSeachMask();

        final Thread[] threadPool = new Thread[target.getOpenPorts().size()];

        i = 0;
        for (final Port port : target.getOpenPorts()) {
            if (port.service != null && !port.service.isEmpty()) {
                final String query = (exactVersionMatch ? port.getServiceQueryWithVersion() : port.getServiceQuery());
                if (searched.contains(query))
                    continue;
                searched.add(query);

                threadPool[i] = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            ArrayList<Vulnerability> local_results = new ArrayList<Vulnerability>();
                            if ((search_mask & SEARCH_OSV) != 0)
                                local_results.addAll(OpenSourcedVulnerability.search(query));
                            if ((search_mask & SEARCH_CVE) != 0)
                                local_results.addAll(NationalVulnerability.search(query));
                            if (local_results.isEmpty())
                                return;

                            for (Vulnerability vuln : local_results) {
                                target.addVulnerability(port, vuln);
                            }

                            if (listener != null) {
                                listener.onVulnsFound(local_results.toArray(new Vulnerability[local_results.size()]));
                            }
                        } catch (InterruptedException e) {
                            Logger.info("interrupted");
                            // quit!
                        }
                    }
                });
                i++;
            }
        }
        final int j = (i - 1); // integer bridge
        return new Thread(new Runnable() {

            @Override
            public void run() {
                int i = j;
                while (i >= 0)
                    threadPool[i--].start();
                i = j;
                try {
                    while (i >= 0)
                        threadPool[i--].join();
                } catch (InterruptedException ie) {
                    while (i >= 0)
                        threadPool[i--].interrupt();
                }
                if (listener != null)
                    listener.onEnd();
            }
        });
    }

    private void setStartedState() {
        mSearchProgress.setVisibility(View.VISIBLE);

        mAdapter.clear();
        final Target target = System.getCurrentTarget();

        for (Port p : target.getOpenPorts())
            for (Vulnerability vuln : p.getVulnerabilities())
                mAdapter.addChild(p.service, vuln);

        mThread = search(target, new VulnerabilityReceiver() {
            @Override
            public void onVulnsFound(Vulnerability[] vulns) {
                final Vulnerability[] fVulns = vulns;

                VulnerabilityFinder.this.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        for (Vulnerability vuln : fVulns)
                            mAdapter.addChild(vuln.getPort().service, vuln);
                        mAdapter.notifyDataSetChanged();
                    }
                });
            }

            @Override
            public void onEnd() {
                VulnerabilityFinder.this.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mSearchToggleButton.setChecked(false);
                        mSearchProgress.setVisibility(View.GONE);
                    }
                });
            }
        }, mVersionMatching);
        mThread.start();
    }

    private void setStoppedState() {
        try {
            if (mThread != null) {
                mThread.interrupt();
                mThread.join();
            }
        } catch (Exception e) {

        }

        VulnerabilityFinder.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mSearchToggleButton.setChecked(false);
                mSearchProgress.setVisibility(View.GONE);
            }
        });
    }

    public void onCreate(Bundle savedInstanceState) {
        SharedPreferences themePrefs = getSharedPreferences("THEME", 0);
        Boolean isDark = themePrefs.getBoolean("isDark", false);
        if (isDark)
            setTheme(R.style.Sherlock___Theme);
        else
            setTheme(R.style.AppTheme);
        super.onCreate(savedInstanceState);

        if (System.getCurrentTarget().hasOpenPorts() == false)
            new FinishDialog(getString(R.string.warning),
                    getString(R.string.no_open_ports), this).show();

        else if (System.getCurrentTarget().hasOpenPortsWithService() == false)
            new FinishDialog(getString(R.string.warning),
                    getString(R.string.no_infos_on_target), this).show();

        mSearchToggleButton = (ToggleButton) findViewById(R.id.searchToggleButton);
        mSearchProgress = (ProgressBar) findViewById(R.id.searchActivity);
        mListView = (ExpandableListView) findViewById(R.id.searchListView);
        mAdapter = new ListViewAdapter(this);

        for (Port port : System.getCurrentTarget().getOpenPorts()) {
            if (port.service != null && port.service.isEmpty() == false) {
                mAdapter.addGroup(port.service);
                for (Vulnerability vuln : port.getVulnerabilities())
                    mAdapter.addChild(port.service, vuln);
            }
        }

        mListView.setAdapter(mAdapter);
        mListView.setOnChildClickListener(new OnChildClickListener() {
            @Override
            public boolean onChildClick(ExpandableListView parent, View v,
                                        int groupPosition, int childPosition, long id) {
                Vulnerability vuln = (Vulnerability) mAdapter.getChild(
                        groupPosition, childPosition);

                if (vuln != null) {
                    String uri = ((vuln.osvdb_id > 0) ? "http://osvdb.org/show/osvdb/"
                            : "http://web.nvd.nist.gov/view/vuln/detail?vulnId=")
                            + vuln.getIdentifier();
                    Intent browser = new Intent(Intent.ACTION_VIEW, Uri
                            .parse(uri));

                    startActivity(browser);
                }

                return true;
            }
        });

        for (int i = 0; i < mAdapter.getGroupCount(); i++) {
            mListView.expandGroup(i);
        }

        mSearchToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (((ToggleButton) v).isChecked())
                    setStartedState();
                else
                    setStoppedState();
            }
        });
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getSupportMenuInflater();
        inflater.inflate(R.menu.vulnerability_finder, menu);
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.search_exact_version:
                if (item.isChecked()) {
                    item.setChecked(false);
                    mVersionMatching = false;
                } else {
                    item.setChecked(true);
                    mVersionMatching = true;
                }
                return true;
            case R.id.vulnerability_search_performance:
                startActivity(new Intent(VulnerabilityFinder.this, SettingsActivity.class));
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onBackPressed() {
        setStoppedState();
        super.onBackPressed();
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
    }
}