/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version LI-T3.0.0.31129 Firebird 3.0 Alpha 2 **********************/
/*
 *	PROGRAM:	JRD Backup and Restore Program
 *	MODULE:		restore.epp
 *	DESCRIPTION:	Restore routine
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Toni Martir: Verbose records restored as RESTORE_VERBOSE_INTERVAL,
 * also verbose restoring indexes as DEFERRED when verbose
 * 2003.08.17 Claudio Valderrama: Fix SF Bug #750659.
 * Adriano dos Santos Fernandes
 *
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "../burp/burp.h"
#include "../jrd/align.h"
#include "../jrd/flags.h"
#include "../jrd/license.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../common/stuff.h"
#include "../burp/burp_proto.h"
#include "../burp/canon_proto.h"
#include "../burp/misc_proto.h"
#include "../burp/mvol_proto.h"
#include "../burp/resto_proto.h"
#include "../common/gdsassert.h"
#include "../jrd/constants.h"
#include "../remote/protocol.h"
#ifdef DEBUG
#include "../common/prett_proto.h"
#endif
#include "../common/classes/ClumpletWriter.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/SafeArg.h"
#include "../common/utils_proto.h"
#include "memory_routines.h"
#include "../burp/OdsDetection.h"
#include "../auth/trusted/AuthSspi.h"

using MsgFormat::SafeArg;


//  For service APIs the follow DB handle is a value stored
//  in thread data.  This is also done for other statics generated by
//  GPRE.  This is to avoid multiple threading problems with module
//  level statics.

/*DATABASE DB = STATIC FILENAME "yachts.lnk";*/
/**** GDS Preprocessor Definitions ****/
#ifndef JRD_IBASE_H
#include <ibase.h>
#endif

static const ISC_QUAD
   isc_blob_null = {0, 0};	/* initializer for blobs */
static isc_db_handle
   DB = 0;		/* database handle */

static isc_tr_handle
   gds_trans = 0;		/* default transaction handle */
static ISC_STATUS
   isc_status [20],	/* status vector */
   isc_status2 [20];	/* status vector */
static ISC_LONG
   isc_array_length, 	/* array return size */
   SQLCODE;		/* SQL status code */
static const char
   isc_tpb_27 [4] = {1,9,2,6};

static const char
   isc_tpb_26 [5] = {1,9,2,6,20};

static const char
   isc_tpb_25 [4] = {1,9,2,6};

static const char
   isc_tpb_24 [5] = {1,9,2,6,20};

static const char
   isc_tpb_23 [5] = {1,9,15,6,18};

static const char
   isc_tpb_22 [4] = {1,9,2,6};

static const char
   isc_tpb_21 [5] = {1,9,2,6,20};

static const char
   isc_tpb_20 [4] = {1,9,2,6};

static const char
   isc_tpb_19 [5] = {1,9,2,6,20};

static const char
   isc_tpb_18 [4] = {1,9,2,6};

static const char
   isc_tpb_17 [5] = {1,9,2,6,20};

static const char
   isc_tpb_16 [4] = {1,9,2,6};

static const char
   isc_tpb_15 [5] = {1,9,2,6,20};

static const char
   isc_tpb_14 [4] = {1,9,2,6};

static const char
   isc_tpb_13 [5] = {1,9,2,6,20};

static const char
   isc_tpb_12 [4] = {1,9,2,6};

static const char
   isc_tpb_11 [5] = {1,9,2,6,20};

static const char
   isc_tpb_10 [4] = {1,9,2,6};

static const char
   isc_tpb_9 [5] = {1,9,2,6,20};

static const char
   isc_tpb_8 [4] = {1,9,2,6};

static const char
   isc_tpb_7 [5] = {1,9,2,6,20};

static const char
   isc_tpb_6 [4] = {1,9,2,6};

static const char
   isc_tpb_5 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_4 [4] = {1,9,2,6};

static const char
   isc_tpb_3 [4] = {1,9,2,6};

static const char
   isc_tpb_2 [6] = {1,9,15,6,18,20};

static const char
   isc_tpb_1 [4] = {1,9,2,6};

static const char
   isc_tpb_0 [6] = {1,9,15,6,18,20};

static const short
   isc_28l = 269;
static const char
   isc_28 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 16,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring2, 0,0, 7,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','U','S','E','R','_','P','R','I','V','I','L','E','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 4,0, 
		     blr_field, 0, 16, 'R','D','B','$','G','R','A','N','T','_','O','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','O','B','J','E','C','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 13, 'R','D','B','$','U','S','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 10,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 11,0, 
		     blr_field, 0, 8, 'R','D','B','$','U','S','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 12,0, 
		     blr_field, 0, 13, 'R','D','B','$','P','R','I','V','I','L','E','G','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 13,0, 
		     blr_field, 0, 11, 'R','D','B','$','G','R','A','N','T','O','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 14,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_28 */

static const short
   isc_46l = 116;
static const char
   isc_46 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_boolean, 
		     blr_eql, 
			blr_field, 0, 15, 'R','D','B','$','R','E','L','A','T','I','O','N','_','I','D', 
			blr_literal, blr_long, 0, 1,0,0,0,
		  blr_end, 
	       blr_send, 0, 
		  blr_begin, 
		     blr_assignment, 
			blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			blr_parameter, 0, 0,0, 
		     blr_assignment, 
			blr_literal, blr_long, 0, 1,0,0,0,
			blr_parameter, 0, 1,0, 
		     blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_46 */

static const short
   isc_50l = 238;
static const char
   isc_50 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 3,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		  blr_boolean, 
		     blr_and, 
			blr_not, 
			   blr_missing, 
			      blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
			blr_or, 
			   blr_neq, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			      blr_literal, blr_long, 0, 1,0,0,0,
			   blr_missing, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_assignment, 
			   blr_field, 0, 16, 'R','D','B','$','D','B','K','E','Y','_','L','E','N','G','T','H', 
			   blr_parameter, 0, 2,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 16, 'R','D','B','$','D','B','K','E','Y','_','L','E','N','G','T','H', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_50 */

static const short
   isc_59l = 243;
static const char
   isc_59 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 1, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','C','L','A','S','S', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 2,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 3,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 3,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_59 */

static const short
   isc_71l = 215;
static const char
   isc_71 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 1, 3,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_71 */

static const short
   isc_82l = 260;
static const char
   isc_82 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 1, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
			      blr_parameter, 0, 1,0, 
			   blr_equiv, 
			      blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
			      blr_value_if, 
				 blr_eql, 
				    blr_parameter, 0, 0,0, 
				    blr_literal, blr_text, 0,0, 
				 blr_null, 
				 blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter2, 1, 0,0, 3,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_82 */

static const short
   isc_95l = 215;
static const char
   isc_95 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 1, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 12, 'R','D','B','$','P','A','C','K','A','G','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			      blr_parameter2, 1, 0,0, 3,0, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_95 */

static const short
   isc_107l = 382;
static const char
   isc_107 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 8,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 1, 9,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
			      blr_parameter2, 1, 0,0, 5,0, 
			   blr_assignment, 
			      blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
			      blr_parameter2, 1, 1,0, 6,0, 
			   blr_assignment, 
			      blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
			      blr_parameter2, 1, 2,0, 7,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
			      blr_parameter2, 1, 3,0, 8,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 4,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter2, 2, 3,0, 7,0, 
					     blr_field, 1, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
					  blr_assignment, 
					     blr_parameter2, 2, 2,0, 6,0, 
					     blr_field, 1, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
					  blr_assignment, 
					     blr_parameter2, 2, 1,0, 5,0, 
					     blr_field, 1, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
					  blr_assignment, 
					     blr_parameter2, 2, 0,0, 4,0, 
					     blr_field, 1, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 4,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_107 */

static const short
   isc_131l = 90;
static const char
   isc_131 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','G','E','N','E','R','A','T','O','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 1,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_131 */

static const short
   isc_136l = 119;
static const char
   isc_136 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 5,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','G','E','N','E','R','A','T','O','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 4,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_136 */

static const short
   isc_143l = 245;
static const char
   isc_143 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 11,0, 
	    blr_int64, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','G','E','N','E','R','A','T','O','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 23, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','I','N','C','R','E','M','E','N','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 6,0, 
		     blr_field, 0, 17, 'R','D','B','$','I','N','I','T','I','A','L','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 7,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter, 0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_143 */

static const short
   isc_156l = 214;
static const char
   isc_156 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
		     blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
			   blr_eql, 
			      blr_field, 1, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			      blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 1, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
			   blr_parameter2, 1, 1,0, 3,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 2,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 2,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_156 */

static const short
   isc_164l = 170;
static const char
   isc_164 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_quad, 0, 
	 blr_message, 1, 2,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 20, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 7, 'R','D','B','$','A','C','L', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 1, 7, 'R','D','B','$','A','C','L', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_164 */

static const short
   isc_174l = 170;
static const char
   isc_174 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_double, 
	    blr_short, 0, 
	 blr_message, 0, 3,0, 
	    blr_double, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		  blr_boolean, 
		     blr_eql, 
			blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			blr_literal, blr_long, 0, 1,0,0,0,
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 14, 'R','D','B','$','S','T','A','T','I','S','T','I','C','S', 
			   blr_parameter2, 0, 0,0, 2,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter2, 1, 0,0, 1,0, 
					  blr_field, 1, 14, 'R','D','B','$','S','T','A','T','I','S','T','I','C','S', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_174 */

static const short
   isc_184l = 138;
static const char
   isc_184 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
		  blr_boolean, 
		     blr_and, 
			blr_not, 
			   blr_missing, 
			      blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			blr_neq, 
			   blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
			   blr_literal, blr_long, 0, 0,0,0,0,
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 0,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_erase, 0, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 0,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_184 */

static const short
   isc_191l = 213;
static const char
   isc_191 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
			   blr_parameter2, 0, 0,0, 3,0, 
			blr_assignment, 
			   blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			   blr_parameter, 0, 1,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 2,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter2, 1, 0,0, 1,0, 
					  blr_field, 1, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 2,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_191 */

static const short
   isc_202l = 139;
static const char
   isc_202 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_202 */

static const short
   isc_208l = 139;
static const char
   isc_208 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_208 */

static const short
   isc_214l = 130;
static const char
   isc_214 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_long, 0, 
	 blr_message, 0, 2,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 10, 'R','D','B','$','L','I','N','G','E','R', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 10, 'R','D','B','$','L','I','N','G','E','R', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_214 */

static const short
   isc_222l = 160;
static const char
   isc_222 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_222 */

static const short
   isc_230l = 140;
static const char
   isc_230 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_quad, 0, 
	 blr_message, 0, 2,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_230 */

static const short
   isc_238l = 145;
static const char
   isc_238 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring2, 3,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','N','T','E','X','T','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_238 */

static const short
   isc_244l = 208;
static const char
   isc_244 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_cstring2, 3,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','V','I','E','W','_','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','N','T','E','X','T','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 5,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','N','T','E','X','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','I','E','W','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_244 */

static const short
   isc_254l = 253;
static const char
   isc_254 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring2, 0,0, 7,0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','U','S','E','R','_','P','R','I','V','I','L','E','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','U','S','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 16, 'R','D','B','$','G','R','A','N','T','_','O','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 11,0, 
		     blr_field, 0, 13, 'R','D','B','$','P','R','I','V','I','L','E','G','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 11, 'R','D','B','$','G','R','A','N','T','O','R', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 8, 'R','D','B','$','U','S','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','O','B','J','E','C','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_254 */

static const short
   isc_268l = 154;
static const char
   isc_268 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 7,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','T','Y','P','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 8, 'R','D','B','$','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 13, 'R','D','B','$','T','Y','P','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 4,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_268 */

static const short
   isc_277l = 117;
static const char
   isc_277 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring2, 0,0, 0,4, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','M','E','S','S','A','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','E','S','S','A','G','E','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_277 */

static const short
   isc_282l = 132;
static const char
   isc_282 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
		     blr_first, 
			blr_literal, blr_long, 0, 1,0,0,0,
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
			      blr_literal, blr_long, 0, 1,0,0,0,
			   blr_eql, 
			      blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
			      blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_282 */

static const short
   isc_287l = 319;
static const char
   isc_287 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 16,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_int64, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','I','N','A','C','T','I','V','E', 
		  blr_assignment, 
		     blr_parameter, 0, 7,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 12,0, 
		     blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 15,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_287 */

static const short
   isc_305l = 437;
static const char
   isc_305 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 24,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_int64, 0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 9,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','I','N','A','C','T','I','V','E', 
		  blr_assignment, 
		     blr_parameter, 0, 10,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','N','G','I','N','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 13,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','E','B','U','G','_','I','N','F','O', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 14,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','A','L','I','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 19,0, 18,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 20,0, 
		     blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 21,0, 
		     blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 22,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 23,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_305 */

static const short
   isc_331l = 262;
static const char
   isc_331 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_int64, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','T','R','I','G','G','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','T','R','I','G','G','E','R','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 9,0, 
		     blr_field, 0, 18, 'R','D','B','$','T','R','I','G','G','E','R','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','T','R','I','G','G','E','R','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 11,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_331 */

static const short
   isc_345l = 113;
static const char
   isc_345 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 7, 'R','D','B','$','A','C','L', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 3,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_345 */

static const short
   isc_351l = 288;
static const char
   isc_351 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_cstring2, 3,0, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 7, 'R','D','B','$','M','A','P', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 8,0, 
		     blr_field, 0, 10, 'R','D','B','$','M','A','P','_','T','O', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 12, 'R','D','B','$','M','A','P','_','F','R','O','M', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','A','P','_','F','R','O','M','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 10, 'R','D','B','$','M','A','P','_','D','B', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 12,0, 
		     blr_field, 0, 14, 'R','D','B','$','M','A','P','_','P','L','U','G','I','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','A','P','_','U','S','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 15,0, 
		     blr_field, 0, 12, 'R','D','B','$','M','A','P','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','A','P','_','T','O','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_351 */

static const short
   isc_371l = 86;
static const char
   isc_371 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','R','O','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 2,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 3,0, 
		     blr_field, 0, 13, 'R','D','B','$','R','O','L','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_371 */

static const short
   isc_377l = 144;
static const char
   isc_377 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','R','O','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 3,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 7,0, 
		     blr_field, 0, 13, 'R','D','B','$','R','O','L','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_377 */

static const short
   isc_387l = 247;
static const char
   isc_387 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 4,0, 
	    blr_cstring2, 0,0, 4,0, 
	    blr_cstring2, 0,0, 12,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 24, 'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 6,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 7,0, 
		     blr_field, 0, 22, 'R','D','B','$','I','N','I','T','I','A','L','L','Y','_','D','E','F','E','R','R','E','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 8,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','E','F','E','R','R','A','B','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 10,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_387 */

static const short
   isc_401l = 327;
static const char
   isc_401 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 19,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 24, 'R','D','B','$','E','X','T','E','R','N','A','L','_','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 11, 'R','D','B','$','R','U','N','T','I','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','V','I','E','W','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 13,0, 
		     blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 14,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_401 */

static const short
   isc_422l = 358;
static const char
   isc_422 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 21,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','R','E','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 10,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','F','I','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 24, 'R','D','B','$','E','X','T','E','R','N','A','L','_','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 12,0, 
		     blr_field, 0, 11, 'R','D','B','$','R','U','N','T','I','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','V','I','E','W','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 15,0, 
		     blr_field, 0, 12, 'R','D','B','$','V','I','E','W','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 16,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 9, 'R','D','B','$','F','L','A','G','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 20,0, 19,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_422 */

static const short
   isc_445l = 202;
static const char
   isc_445 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring2, 0,0, 8,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 12,0, 
	    blr_cstring2, 0,0, 12,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','R','E','F','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 5,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','L','E','T','E','_','R','U','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','R','U','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 7,0, 
		     blr_field, 0, 16, 'R','D','B','$','M','A','T','C','H','_','O','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','C','O','N','S','T','_','N','A','M','E','_','U','Q', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_445 */

static const short
   isc_457l = 247;
static const char
   isc_457 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 9,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 24, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','P','A','R','A','M','E','T','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_457 */

static const short
   isc_468l = 502;
static const char
   isc_468 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 25,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 24, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','P','A','R','A','M','E','T','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 9,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 10,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 12,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 23, 'R','D','B','$','P','A','R','A','M','E','T','E','R','_','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 20,0, 19,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 22,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 23,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 24,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_468 */

static const short
   isc_495l = 311;
static const char
   isc_495 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 15,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 21, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','O','U','T','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','I','N','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 11,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 12,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 14,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','S','O','U','R','C','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_495 */

static const short
   isc_512l = 528;
static const char
   isc_512 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 30,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','P','R','O','C','E','D','U','R','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 10,0, 
		     blr_field, 0, 21, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','O','U','T','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','I','N','P','U','T','S', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','R','I','V','A','T','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 15,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 16,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 17,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','N','G','I','N','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 18,0, 
		     blr_field, 0, 17, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 19,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','E','B','U','G','_','I','N','F','O', 
		  blr_assignment, 
		     blr_parameter2, 0, 21,0, 20,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','A','L','I','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 23,0, 22,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 25,0, 24,0, 
		     blr_field, 0, 18, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 26,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 27,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 28,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 29,0, 
		     blr_field, 0, 20, 'R','D','B','$','P','R','O','C','E','D','U','R','E','_','S','O','U','R','C','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_512 */

static const short
   isc_544l = 257;
static const char
   isc_544 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 13,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 12, 'R','D','B','$','P','A','C','K','A','G','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 23, 'R','D','B','$','P','A','C','K','A','G','E','_','B','O','D','Y','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 12,0, 
		     blr_field, 0, 25, 'R','D','B','$','P','A','C','K','A','G','E','_','H','E','A','D','E','R','_','S','O','U','R','C','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_544 */

static const short
   isc_559l = 129;
static const char
   isc_559 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_erase, 0, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_559 */

static const short
   isc_568l = 190;
static const char
   isc_568 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 1,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
		     blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 1, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			      blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
			   blr_and, 
			      blr_eql, 
				 blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
				 blr_parameter, 0, 1,0, 
			      blr_eql, 
				 blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
				 blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 0,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_568 */

static const short
   isc_574l = 116;
static const char
   isc_574 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 3,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','I','N','D','E','X','_','S','E','G','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_574 */

static const short
   isc_579l = 349;
static const char
   isc_579 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 17,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 17, 'R','D','B','$','S','E','G','M','E','N','T','_','C','O','U','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 10,0, 
		     blr_field, 0, 21, 'R','D','B','$','E','X','P','R','E','S','S','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 11,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 15,0, 
		     blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
		  blr_assignment, 
		     blr_parameter, 0, 16,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','N','I','Q','U','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_579 */

static const short
   isc_598l = 852;
static const char
   isc_598 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 51,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 0,0, 128,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 14,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 15,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 19,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 20,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 22,0, 21,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 25,0, 24,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 27,0, 26,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 29,0, 28,0, 
		     blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 32,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 34,0, 33,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 36,0, 35,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 37,0, 
		     blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 38,0, 
		     blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 39,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 40,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 41,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 42,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 43,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 44,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 45,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 46,0, 18,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 47,0, 16,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 48,0, 17,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 49,0, 23,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 50,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_598 */

static const short
   isc_651l = 885;
static const char
   isc_651 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 53,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 0,0, 128,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 14,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 15,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 22,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 24,0, 23,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 27,0, 26,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 29,0, 28,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 33,0, 32,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 34,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 36,0, 35,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 38,0, 37,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 39,0, 
		     blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 40,0, 
		     blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 41,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 42,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 43,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 44,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 45,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 46,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 47,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 48,0, 20,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 49,0, 18,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 50,0, 19,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 51,0, 25,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 52,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_651 */

static const short
   isc_706l = 951;
static const char
   isc_706 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 57,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 0,0, 128,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 10, 'R','D','B','$','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 16,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 17,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 18,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 19,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 21,0, 20,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 25,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 26,0, 
		     blr_field, 0, 18, 'R','D','B','$','M','I','S','S','I','N','G','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 28,0, 27,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','T','E','R','N','A','L','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 33,0, 32,0, 
		     blr_field, 0, 17, 'R','D','B','$','E','X','T','E','R','N','A','L','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 35,0, 34,0, 
		     blr_field, 0, 19, 'R','D','B','$','E','X','T','E','R','N','A','L','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 37,0, 36,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','I','M','E','N','S','I','O','N','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 38,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 40,0, 39,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 42,0, 41,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 43,0, 
		     blr_field, 0, 21, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 44,0, 
		     blr_field, 0, 18, 'R','D','B','$','V','A','L','I','D','A','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 45,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 46,0, 
		     blr_field, 0, 17, 'R','D','B','$','M','I','S','S','I','N','G','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 47,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 48,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 49,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 13,0, 50,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','M','P','U','T','E','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 51,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','U','T','E','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 52,0, 24,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 53,0, 22,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 54,0, 23,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 55,0, 29,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','G','M','E','N','T','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter2, 0, 56,0, 15,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_706 */

static const short
   isc_765l = 263;
static const char
   isc_765 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_765 */

static const short
   isc_777l = 296;
static const char
   isc_777 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_777 */

static const short
   isc_791l = 675;
static const char
   isc_791 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 36,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 22, 'R','D','B','$','F','U','N','C','T','I','O','N','_','A','R','G','U','M','E','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 9,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','E','L','D','_','S','C','A','L','E', 
		  blr_assignment, 
		     blr_parameter, 0, 11,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 12,0, 
		     blr_field, 0, 13, 'R','D','B','$','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter, 0, 13,0, 
		     blr_field, 0, 21, 'R','D','B','$','A','R','G','U','M','E','N','T','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 16,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 17,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 18,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 20,0, 19,0, 
		     blr_field, 0, 22, 'R','D','B','$','A','R','G','U','M','E','N','T','_','M','E','C','H','A','N','I','S','M', 
		  blr_assignment, 
		     blr_parameter2, 0, 22,0, 21,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 24,0, 23,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 25,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 26,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 27,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 28,0, 
		     blr_field, 0, 17, 'R','D','B','$','A','R','G','U','M','E','N','T','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 29,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','I','E','L','D','_','P','R','E','C','I','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 33,0, 32,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 35,0, 34,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','S','U','B','_','T','Y','P','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_791 */

static const short
   isc_829l = 255;
static const char
   isc_829 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 10,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','F','U','N','C','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 6,0, 
		     blr_field, 0, 19, 'R','D','B','$','R','E','T','U','R','N','_','A','R','G','U','M','E','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_829 */

static const short
   isc_841l = 599;
static const char
   isc_841 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 13, 'R','D','B','$','F','U','N','C','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 12,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 13,0, 
		     blr_field, 0, 19, 'R','D','B','$','R','E','T','U','R','N','_','A','R','G','U','M','E','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','L','E','G','A','C','Y','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 22, 'R','D','B','$','D','E','T','E','R','M','I','N','I','S','T','I','C','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 19,0, 18,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 20,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 22,0, 
		     blr_field, 0, 14, 'R','D','B','$','D','E','B','U','G','_','I','N','F','O', 
		  blr_assignment, 
		     blr_parameter2, 0, 24,0, 23,0, 
		     blr_field, 0, 13, 'R','D','B','$','V','A','L','I','D','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 25,0, 
		     blr_field, 0, 19, 'R','D','B','$','F','U','N','C','T','I','O','N','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 26,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','U','N','C','T','I','O','N','_','B','L','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 28,0, 27,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','R','I','V','A','T','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 29,0, 
		     blr_field, 0, 16, 'R','D','B','$','P','A','C','K','A','G','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 30,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','N','G','I','N','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 31,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_841 */

static const short
   isc_875l = 227;
static const char
   isc_875 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 9,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 11, 'R','D','B','$','F','I','L','T','E','R','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 19, 'R','D','B','$','O','U','T','P','U','T','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 18, 'R','D','B','$','I','N','P','U','T','_','S','U','B','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','E','N','T','R','Y','P','O','I','N','T', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 15, 'R','D','B','$','M','O','D','U','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_875 */

static const short
   isc_886l = 178;
static const char
   isc_886 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 6,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 17, 'R','D','B','$','S','H','A','D','O','W','_','N','U','M','B','E','R', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','I','L','E','_','L','E','N','G','T','H', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','S','T','A','R','T', 
		  blr_assignment, 
		     blr_parameter, 0, 4,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','I','L','E','_','S','E','Q','U','E','N','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 13, 'R','D','B','$','F','I','L','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter, 0, 5,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','F','L','A','G','S', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_886 */

static const short
   isc_894l = 136;
static const char
   isc_894 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_long, 0, 
	    blr_long, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 20, 'R','D','B','$','F','I','E','L','D','_','D','I','M','E','N','S','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','P','E','R','_','B','O','U','N','D', 
		  blr_assignment, 
		     blr_parameter, 0, 2,0, 
		     blr_field, 0, 15, 'R','D','B','$','L','O','W','E','R','_','B','O','U','N','D', 
		  blr_assignment, 
		     blr_parameter, 0, 3,0, 
		     blr_field, 0, 13, 'R','D','B','$','D','I','M','E','N','S','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_894 */

static const short
   isc_900l = 582;
static const char
   isc_900 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 33,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 0,0, 128,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 13,0, 12,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 14,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 16,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 17,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 19,0, 18,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 20,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','L','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 22,0, 21,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 24,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 25,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 26,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 27,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 28,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 29,0, 
		     blr_field, 0, 14, 'R','D','B','$','B','A','S','E','_','F','I','E','L','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 31,0, 30,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 32,0, 23,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 11,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_900 */

static const short
   isc_935l = 648;
static const char
   isc_935 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 37,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 0,0, 128,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 19, 'R','D','B','$','R','E','L','A','T','I','O','N','_','F','I','E','L','D','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 16, 'R','D','B','$','F','I','E','L','D','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','E','L','D','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 17, 'R','D','B','$','I','D','E','N','T','I','T','Y','_','T','Y','P','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 15,0, 
		     blr_field, 0, 18, 'R','D','B','$','G','E','N','E','R','A','T','O','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 19,0, 18,0, 
		     blr_field, 0, 13, 'R','D','B','$','N','U','L','L','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 20,0, 
		     blr_field, 0, 17, 'R','D','B','$','D','E','F','A','U','L','T','_','V','A','L','U','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','D','E','F','A','U','L','T','_','S','O','U','R','C','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 23,0, 22,0, 
		     blr_field, 0, 15, 'R','D','B','$','U','P','D','A','T','E','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 24,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','M','P','L','E','X','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 26,0, 25,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 28,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 29,0, 
		     blr_field, 0, 15, 'R','D','B','$','E','D','I','T','_','S','T','R','I','N','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 30,0, 
		     blr_field, 0, 16, 'R','D','B','$','Q','U','E','R','Y','_','H','E','A','D','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 9,0, 31,0, 
		     blr_field, 0, 14, 'R','D','B','$','Q','U','E','R','Y','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 32,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 33,0, 
		     blr_field, 0, 14, 'R','D','B','$','B','A','S','E','_','F','I','E','L','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 35,0, 34,0, 
		     blr_field, 0, 16, 'R','D','B','$','V','I','E','W','_','C','O','N','T','E','X','T', 
		  blr_assignment, 
		     blr_parameter2, 0, 36,0, 27,0, 
		     blr_field, 0, 18, 'R','D','B','$','F','I','E','L','D','_','P','O','S','I','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter, 0, 12,0, 
		     blr_field, 0, 17, 'R','D','B','$','R','E','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_935 */

static const short
   isc_974l = 151;
static const char
   isc_974 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 8,0, 
	    blr_cstring2, 0,0, 0,4, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','E','X','C','E','P','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 3,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 5,0, 
		     blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 7,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','C','E','P','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_974 */

static const short
   isc_984l = 217;
static const char
   isc_984 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 12,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 0,0, 0,4, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','E','X','C','E','P','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 5,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 8,0, 7,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 11, 'R','D','B','$','M','E','S','S','A','G','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 18, 'R','D','B','$','E','X','C','E','P','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_984 */

static const short
   isc_998l = 178;
static const char
   isc_998 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 2, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				       blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_998 */

static const short
   isc_1008l = 336;
static const char
   isc_1008 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','C','O','L','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 5,0, 
		     blr_field, 0, 23, 'R','D','B','$','S','P','E','C','I','F','I','C','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','A','S','E','_','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 7,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 24, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 17,0, 
		     blr_field, 0, 18, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1008 */

static const short
   isc_1028l = 336;
static const char
   isc_1028 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','C','O','L','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 5,0, 
		     blr_field, 0, 23, 'R','D','B','$','S','P','E','C','I','F','I','C','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 6,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','A','S','E','_','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 7,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 8,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 10,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 12,0, 11,0, 
		     blr_field, 0, 24, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 17,0, 
		     blr_field, 0, 18, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1028 */

static const short
   isc_1048l = 402;
static const char
   isc_1048 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 22,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 14, 'R','D','B','$','C','O','L','L','A','T','I','O','N','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 7,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 8,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 9,0, 
		     blr_field, 0, 23, 'R','D','B','$','S','P','E','C','I','F','I','C','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 10,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','A','S','E','_','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 11,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 12,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 14,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 16,0, 15,0, 
		     blr_field, 0, 24, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','A','T','T','R','I','B','U','T','E','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 18,0, 17,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 20,0, 19,0, 
		     blr_field, 0, 16, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 21,0, 
		     blr_field, 0, 18, 'R','D','B','$','C','O','L','L','A','T','I','O','N','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1048 */

static const short
   isc_1072l = 106;
static const char
   isc_1072 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 4,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 21, 'R','D','B','$','C','H','E','C','K','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 2,0, 
		     blr_field, 0, 16, 'R','D','B','$','T','R','I','G','G','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 3,0, 
		     blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1072 */

static const short
   isc_1078l = 347;
static const char
   isc_1078 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 18,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 6,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R','A','C','T','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 8,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 13,0, 12,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 14,0, 
		     blr_field, 0, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 15,0, 
		     blr_field, 0, 24, 'R','D','B','$','N','U','M','B','E','R','_','O','F','_','C','H','A','R','A','C','T','E','R','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 16,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','O','R','M','_','O','F','_','U','S','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 17,0, 
		     blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1078 */

static const short
   isc_1098l = 413;
static const char
   isc_1098 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 22,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_quad, 0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_long, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 18, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter2, 0, 0,0, 8,0, 
		     blr_field, 0, 14, 'R','D','B','$','O','W','N','E','R','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 1,0, 9,0, 
		     blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 11,0, 10,0, 
		     blr_field, 0, 23, 'R','D','B','$','B','Y','T','E','S','_','P','E','R','_','C','H','A','R','A','C','T','E','R', 
		  blr_assignment, 
		     blr_parameter2, 0, 2,0, 12,0, 
		     blr_field, 0, 17, 'R','D','B','$','F','U','N','C','T','I','O','N','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 3,0, 13,0, 
		     blr_field, 0, 15, 'R','D','B','$','D','E','S','C','R','I','P','T','I','O','N', 
		  blr_assignment, 
		     blr_parameter2, 0, 15,0, 14,0, 
		     blr_field, 0, 15, 'R','D','B','$','S','Y','S','T','E','M','_','F','L','A','G', 
		  blr_assignment, 
		     blr_parameter2, 0, 17,0, 16,0, 
		     blr_field, 0, 20, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','I','D', 
		  blr_assignment, 
		     blr_parameter2, 0, 4,0, 18,0, 
		     blr_field, 0, 24, 'R','D','B','$','D','E','F','A','U','L','T','_','C','O','L','L','A','T','E','_','N','A','M','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 7,0, 19,0, 
		     blr_field, 0, 24, 'R','D','B','$','N','U','M','B','E','R','_','O','F','_','C','H','A','R','A','C','T','E','R','S', 
		  blr_assignment, 
		     blr_parameter2, 0, 5,0, 20,0, 
		     blr_field, 0, 15, 'R','D','B','$','F','O','R','M','_','O','F','_','U','S','E', 
		  blr_assignment, 
		     blr_parameter2, 0, 6,0, 21,0, 
		     blr_field, 0, 22, 'R','D','B','$','C','H','A','R','A','C','T','E','R','_','S','E','T','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1098 */

static const short
   isc_1122l = 75;
static const char
   isc_1122 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 0,0, 0,1, 
	    blr_long, 0, 
	 blr_receive, 0, 
	    blr_store, 
	       blr_relation, 9, 'R','D','B','$','F','I','L','E','S', 0, 
	       blr_begin, 
		  blr_assignment, 
		     blr_parameter, 0, 1,0, 
		     blr_field, 0, 14, 'R','D','B','$','F','I','L','E','_','S','T','A','R','T', 
		  blr_assignment, 
		     blr_parameter, 0, 0,0, 
		     blr_field, 0, 13, 'R','D','B','$','F','I','L','E','_','N','A','M','E', 
		  blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1122 */

static const short
   isc_1126l = 152;
static const char
   isc_1126 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_begin, 
	    blr_for, 
	       blr_rse, 1, 
		  blr_relation, 12, 'R','D','B','$','D','A','T','A','B','A','S','E', 0, 
		  blr_end, 
	       blr_begin, 
		  blr_send, 0, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 0, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
			   blr_parameter, 0, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 0, 1,0, 
			blr_end, 
		  blr_label, 0, 
		     blr_loop, 
			blr_select, 
			   blr_receive, 2, 
			      blr_leave, 0, 
			   blr_receive, 1, 
			      blr_handler, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 1, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','S','E','C','U','R','I','T','Y','_','C','L','A','S','S', 
				       blr_end, 
			   blr_end, 
		  blr_end, 
	    blr_send, 0, 
	       blr_assignment, 
		  blr_literal, blr_long, 0, 0,0,0,0,
		  blr_parameter, 0, 1,0, 
	    blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1126 */

static const short
   isc_1134l = 178;
static const char
   isc_1134 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 2, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				       blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1134 */

static const short
   isc_1144l = 218;
static const char
   isc_1144 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 1, 2,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	 blr_message, 0, 2,0, 
	    blr_cstring2, 0,0, 12,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 2, 
		     blr_relation, 24, 'R','D','B','$','R','E','L','A','T','I','O','N','_','C','O','N','S','T','R','A','I','N','T','S', 0, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 1, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 19, 'R','D','B','$','C','O','N','S','T','R','A','I','N','T','_','T','Y','P','E', 
			      blr_parameter, 0, 0,0, 
			   blr_and, 
			      blr_eql, 
				 blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
				 blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			      blr_eql, 
				 blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				 blr_parameter, 0, 1,0, 
		     blr_end, 
		  blr_send, 1, 
		     blr_begin, 
			blr_assignment, 
			   blr_field, 1, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 1, 0,0, 
			blr_assignment, 
			   blr_literal, blr_long, 0, 1,0,0,0,
			   blr_parameter, 1, 1,0, 
			blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1144 */

static const short
   isc_1151l = 267;
static const char
   isc_1151 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 4, 1,0, 
	    blr_short, 0, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 3,0, 
	    blr_cstring2, 3,0, 32,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_short, 0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_and, 
			   blr_eql, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 0, 0,0, 
			   blr_missing, 
			      blr_field, 0, 15, 'R','D','B','$','F','O','R','E','I','G','N','_','K','E','Y', 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 1,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 2,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_handler, 
				    blr_modify, 0, 2, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 2, 0,0, 
					     blr_field, 2, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_receive, 4, 
				 blr_handler, 
				    blr_modify, 0, 1, 
				       blr_begin, 
					  blr_assignment, 
					     blr_parameter, 4, 0,0, 
					     blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
					  blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 1,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1151 */

static const short
   isc_1164l = 178;
static const char
   isc_1164 [] = {
      blr_version4,
      blr_begin, 
	 blr_message, 3, 1,0, 
	    blr_short, 0, 
	 blr_message, 2, 1,0, 
	    blr_short, 0, 
	 blr_message, 1, 2,0, 
	    blr_short, 0, 
	    blr_short, 0, 
	 blr_message, 0, 1,0, 
	    blr_cstring2, 3,0, 32,0, 
	 blr_receive, 0, 
	    blr_begin, 
	       blr_for, 
		  blr_rse, 1, 
		     blr_relation, 11, 'R','D','B','$','I','N','D','I','C','E','S', 0, 
		     blr_boolean, 
			blr_eql, 
			   blr_field, 0, 14, 'R','D','B','$','I','N','D','E','X','_','N','A','M','E', 
			   blr_parameter, 0, 0,0, 
		     blr_end, 
		  blr_begin, 
		     blr_send, 1, 
			blr_begin, 
			   blr_assignment, 
			      blr_literal, blr_long, 0, 1,0,0,0,
			      blr_parameter, 1, 0,0, 
			   blr_assignment, 
			      blr_field, 0, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
			      blr_parameter, 1, 1,0, 
			   blr_end, 
		     blr_label, 0, 
			blr_loop, 
			   blr_select, 
			      blr_receive, 3, 
				 blr_leave, 0, 
			      blr_receive, 2, 
				 blr_modify, 0, 1, 
				    blr_begin, 
				       blr_assignment, 
					  blr_parameter, 2, 0,0, 
					  blr_field, 1, 18, 'R','D','B','$','I','N','D','E','X','_','I','N','A','C','T','I','V','E', 
				       blr_end, 
			      blr_end, 
		     blr_end, 
	       blr_send, 1, 
		  blr_assignment, 
		     blr_literal, blr_long, 0, 0,0,0,0,
		     blr_parameter, 1, 0,0, 
	       blr_end, 
	 blr_end, 
      blr_eoc
   };	/* end of blr string for request isc_1164 */


#define gds_blob_null	isc_blob_null	/* compatibility symbols */
#define gds_status	isc_status
#define gds_status2	isc_status2
#define gds_array_length	isc_array_length
#define gds_count	isc_count
#define gds_slack	isc_slack
#define gds_utility	isc_utility	/* end of compatibility symbols */

#ifndef isc_version4
    Generate a compile-time error.
    Picking up a V3 include file after preprocessing with V4 GPRE.
#endif

/**** end of GPRE definitions ****/


#define DB			tdgbl->db_handle
#define gds_trans	tdgbl->tr_handle
#define isc_status	tdgbl->status_vector


namespace // unnamed, private
{

const int DEFERRED_ACTIVE		= 3;	// RDB$INDEX_INACTIVE setting for Foreign Keys
										// This setting is used temporarily while
										// restoring a database. This was required
										// in order to differentiate a partial
										// "inactive" state of SOME indices from
										// "inactive" state of ALL indices (gbak -i)
										// -bsriram, 11-May-1999      BUG: 10016


const int burp_msg_fac				= 12;

enum scan_attr_t
{
	NO_SKIP		= 0,	// Not in skipping and scanning mode
	BEFORE_SKIP	= 1,	// After skipping, before scanning next byte for valid attribute
	AFTER_SKIP	= 2	// After skipping and after scanning next byte for valid attribute
};

void	add_access_dpb(BurpGlobals* tdgbl, Firebird::ClumpletWriter& dpb);
void	add_files(BurpGlobals* tdgbl, const char*);
void	bad_attribute(scan_attr_t, att_type, USHORT);
void	create_database(BurpGlobals* tdgbl, const TEXT*);
void	decompress(BurpGlobals* tdgbl, UCHAR*, USHORT);
void	eat_blob(BurpGlobals* tdgbl);
void	eat_text(BurpGlobals* tdgbl);
void	eat_text2(BurpGlobals* tdgbl);
burp_rel*	find_relation(BurpGlobals* tdgbl, const TEXT*);
void	fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field);
// CVC: when do these functions return false indeed???
// get_acl and get_index are the only exceptions but ironically their
// returned value is not checked by the caller!
bool	get_acl(BurpGlobals* tdgbl, const TEXT*, ISC_QUAD*, ISC_QUAD*);
void	get_array(BurpGlobals* tdgbl, burp_rel*, UCHAR*);
void	get_blob(BurpGlobals* tdgbl, const burp_fld*, UCHAR*);
void	get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
bool	get_character_set(BurpGlobals* tdgbl);
bool	get_chk_constraint(BurpGlobals* tdgbl);
bool	get_collation(BurpGlobals* tdgbl);
rec_type	get_data(BurpGlobals* tdgbl, burp_rel*, bool);
bool	get_exception(BurpGlobals* tdgbl);
burp_fld*	get_field(BurpGlobals* tdgbl, burp_rel*);
bool	get_field_dimensions(BurpGlobals* tdgbl);
bool	get_files(BurpGlobals* tdgbl);
bool	get_filter(BurpGlobals* tdgbl);
bool	get_function(BurpGlobals* tdgbl);
void	get_function_arg(BurpGlobals* tdgbl, bool skip_arguments);
bool	get_generator(BurpGlobals* tdgbl);
bool	get_global_field(BurpGlobals* tdgbl);
bool	get_index(BurpGlobals* tdgbl, const burp_rel*);
void	get_misc_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
SLONG	get_int32(BurpGlobals* tdgbl);
SINT64  get_int64(BurpGlobals* tdgbl);
bool	get_package(BurpGlobals* tdgbl);
bool	get_procedure(BurpGlobals* tdgbl);
bool	get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME, GDS_NAME);
bool	get_ref_constraint(BurpGlobals* tdgbl);
bool	get_rel_constraint(BurpGlobals* tdgbl);
bool	get_relation(BurpGlobals* tdgbl);
bool	get_relation_data(BurpGlobals* tdgbl);
bool	get_sql_roles(BurpGlobals* tdgbl);
bool	get_mapping(BurpGlobals* tdgbl);
bool	get_security_class(BurpGlobals* tdgbl);
void	get_source_blob(BurpGlobals* tdgbl, ISC_QUAD&, bool);
USHORT	get_text(BurpGlobals* tdgbl, TEXT*, ULONG);
USHORT	get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length);
bool	get_trigger(BurpGlobals* tdgbl);
bool	get_trigger_message(BurpGlobals* tdgbl);
bool	get_trigger_old (BurpGlobals* tdgbl, burp_rel*);
bool	get_type(BurpGlobals* tdgbl);
bool	get_user_privilege(BurpGlobals* tdgbl);
bool	get_view(BurpGlobals* tdgbl, burp_rel*);
void	ignore_array(BurpGlobals* tdgbl, burp_rel*);
void	ignore_blob(BurpGlobals* tdgbl);
rec_type	ignore_data(BurpGlobals* tdgbl, burp_rel*);
void	realign(BurpGlobals* tdgbl, UCHAR*, const burp_rel*);
#ifdef sparc
USHORT	recompute_length(BurpGlobals* tdgbl, burp_rel*);
#endif
bool	restore(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
void	restore_security_class(BurpGlobals* tdgbl, const TEXT*, const TEXT*);
USHORT	get_view_base_relation_count(BurpGlobals* tdgbl, const TEXT*, USHORT, bool* error);
void	store_blr_gen_id(BurpGlobals* tdgbl, const TEXT* gen_name, SINT64 value, SINT64 initial_value,
	const ISC_QUAD* gen_desc, const char* secclass, const char* ownername, fb_sysflag sysFlag,
	SLONG increment);
void	update_global_field(BurpGlobals* tdgbl);
void	update_ownership(BurpGlobals* tdgbl);
void	update_view_dbkey_lengths(BurpGlobals* tdgbl);
void	fix_missing_privileges(BurpGlobals* tdgbl);
void	fix_system_generators(BurpGlobals* tdgbl);
void	general_on_error();
#ifdef DEBUG
UCHAR	debug_on = 0;   // able to turn this on in the debugger
#endif

#ifdef sparc
const SSHORT old_sparcs[] =
    {0, 0, 0, 2, 0, 0, 0, 0, 2, 4, 4, 4, 8, 8, 0, 0, 8, 8, 8};
#endif

//MVOL_read returns int
static inline int get(BurpGlobals* tdgbl)
{
	if (--(tdgbl->io_cnt) >= 0)
		return *(tdgbl->io_ptr)++;

	return MVOL_read(&tdgbl->io_cnt, &tdgbl->io_ptr);
}

static inline att_type get_attribute(att_type* att, BurpGlobals* tdgbl)
{
	*att = (att_type) get(tdgbl);
	return *att;
}

static inline rec_type get_record(rec_type *rec, BurpGlobals* tdgbl)
{
	*rec = (rec_type) get(tdgbl);
	return *rec;
}

#define GET_TEXT(text)	get_text(tdgbl, (text), sizeof(text))
#define GET_TEXT2(text)	get_text2(tdgbl, (text), sizeof(text))

static inline void get_skip(BurpGlobals* tdgbl, ULONG n)
{
	MVOL_skip_block(tdgbl, n);
}

static inline UCHAR* get_block(BurpGlobals* tdgbl, UCHAR* p, ULONG n)
{
	return MVOL_read_block(tdgbl, p, n);
}

// When skipping started, scan_next_attr will be changed from NO_SKIP
// to BEFORE_SKIP. When scanning for next valid attribute after skipping,
// it will flip-flop between BEFORE_SKIP and AFTER_SKIP. When next valid
// attribute is found, it will be changed back to NO_SKIP by 'skip_scan'

static inline void skip_init(scan_attr_t* scan_next_attr)
{
	*scan_next_attr = NO_SKIP;
}

static inline void skip_scan(scan_attr_t* scan_next_attr)
{
	if (*scan_next_attr == AFTER_SKIP)
		*scan_next_attr = BEFORE_SKIP;
	else if (*scan_next_attr == BEFORE_SKIP)
		*scan_next_attr = NO_SKIP;
	//else 0; => nothing, no change in the original macro
}

// User Privilege Flags

const int USER_PRIV_USER			= 1;
const int USER_PRIV_GRANTOR			= 2;
const int USER_PRIV_PRIVILEGE		= 4;
const int USER_PRIV_GRANT_OPTION	= 8;
const int USER_PRIV_OBJECT_NAME		= 16;
const int USER_PRIV_FIELD_NAME		= 32;
const int USER_PRIV_USER_TYPE		= 64;
const int USER_PRIV_OBJECT_TYPE		= 128;

static inline void collect_missing_privs(BurpGlobals* tdgbl, USHORT type, const GDS_NAME name)
{
	burp_meta_obj* object = (burp_meta_obj*) BURP_alloc_zero(sizeof(burp_meta_obj));
	object->obj_next = tdgbl->miss_privs;
	object->obj_type = type;
	strcpy(object->obj_name, name);
	tdgbl->miss_privs = object;
}

} // namespace


int RESTORE_restore (const TEXT* file_name, const TEXT* database_name)
{
   struct isc_1132_struct {
          short isc_1133;	/* isc_utility */
   } isc_1132;
   struct isc_1130_struct {
          char  isc_1131 [32];	/* RDB$SECURITY_CLASS */
   } isc_1130;
   struct isc_1127_struct {
          char  isc_1128 [32];	/* RDB$SECURITY_CLASS */
          short isc_1129;	/* isc_utility */
   } isc_1127;
   struct isc_1142_struct {
          short isc_1143;	/* isc_utility */
   } isc_1142;
   struct isc_1140_struct {
          short isc_1141;	/* RDB$INDEX_INACTIVE */
   } isc_1140;
   struct isc_1137_struct {
          short isc_1138;	/* isc_utility */
          short isc_1139;	/* RDB$INDEX_INACTIVE */
   } isc_1137;
   struct isc_1135_struct {
          char  isc_1136 [32];	/* RDB$INDEX_NAME */
   } isc_1135;
   struct isc_1148_struct {
          char  isc_1149 [32];	/* RDB$INDEX_NAME */
          short isc_1150;	/* isc_utility */
   } isc_1148;
   struct isc_1145_struct {
          char  isc_1146 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_1147;	/* RDB$INDEX_INACTIVE */
   } isc_1145;
   struct isc_1162_struct {
          short isc_1163;	/* RDB$INDEX_INACTIVE */
   } isc_1162;
   struct isc_1160_struct {
          short isc_1161;	/* isc_utility */
   } isc_1160;
   struct isc_1158_struct {
          short isc_1159;	/* RDB$INDEX_INACTIVE */
   } isc_1158;
   struct isc_1154_struct {
          char  isc_1155 [32];	/* RDB$INDEX_NAME */
          short isc_1156;	/* isc_utility */
          short isc_1157;	/* RDB$INDEX_INACTIVE */
   } isc_1154;
   struct isc_1152_struct {
          short isc_1153;	/* RDB$INDEX_INACTIVE */
   } isc_1152;
   struct isc_1172_struct {
          short isc_1173;	/* isc_utility */
   } isc_1172;
   struct isc_1170_struct {
          short isc_1171;	/* RDB$INDEX_INACTIVE */
   } isc_1170;
   struct isc_1167_struct {
          short isc_1168;	/* isc_utility */
          short isc_1169;	/* RDB$INDEX_INACTIVE */
   } isc_1167;
   struct isc_1165_struct {
          char  isc_1166 [32];	/* RDB$INDEX_NAME */
   } isc_1165;
/**************************************
 *
 *	R E S T O R E _ r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Recreate a database from a backup.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0, req_handle3 = 0, req_handle5 = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	tdgbl->io_ptr = NULL;
	tdgbl->io_cnt = 0;

	tdgbl->relations = NULL;
	tdgbl->packages = NULL;
	tdgbl->procedures = NULL;
	tdgbl->miss_privs = NULL;
	tdgbl->RESTORE_format = 0;
	tdgbl->runtimeODS = 0;
	tdgbl->global_trans = 0;

	tdgbl->gbl_sw_transportable = tdgbl->gbl_sw_compress = false;

	if (!restore(tdgbl, file_name, database_name))
		return FINI_ERROR;

	BURP_verbose (76);
	// msg 76 creating indexes

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		// Fix for bug_no 8055:
		// don't throw away the database just because an index
		// could not be made
		long error_code;
		while (error_code = tdgbl->status_vector[1])
		{
			switch (error_code)
			{
				case isc_sort_mem_err:
				case isc_no_dup:
					strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
					BURP_print_status(false, tdgbl->status_vector);
					/*FOR (REQUEST_HANDLE req_handle3)
						IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
					{
                                        if (!req_handle3)
                                           isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_1164), (char*) isc_1164);
					isc_vtov ((const char*) index_name, (char*) isc_1165.isc_1166, 32);
                                        isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_1165, (short) 0);
					while (1)
					   {
                                           isc_receive (NULL, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_1167, (short) 0);
					   if (!isc_1167.isc_1168) break;

						BURP_verbose(243, index_name);
						/*MODIFY IDX USING*/
						{
							/*IDX.RDB$INDEX_INACTIVE*/
							isc_1167.isc_1169 = TRUE;
						/*END_MODIFY;*/
						isc_1170.isc_1171 = isc_1167.isc_1169;
                                                isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_1170, (short) 0);
						}
						BURP_print(false, 240, index_name);
						// msg 240 Index \"%s\" failed to activate because:
						if ( error_code == isc_no_dup )
						{
							BURP_print(false, 241);
							// msg 241 The unique index has duplicate values or NULLs
							BURP_print(false, 242);
							// msg 242 Delete or Update duplicate values or NULLs, and activate index with
						}
						else
						{
							BURP_print(false, 244);
							// msg 244 Not enough disk space to create the sort file for an index
							BURP_print(false, 245);
							// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
						}
						BURP_print(false, 243, index_name);
						// msg 243 ALTER INDEX \"%s\" ACTIVE;
					/*END_FOR;*/
                                           isc_send (NULL, (FB_API_HANDLE*) &req_handle3, (short) 3, (short) 2, &isc_1172, (short) 0);
					   }
					}
					// don't bring the database on-line
					tdgbl->flag_on_line = false;
					break;
				default:
					general_on_error ();
				break;
			}
			/*COMMIT*/
			{
			isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				continue;
			/*END_ERROR*/
			   }
			}
		}
	/*END_ERROR;*/
	   }
	}

	// Activate the indices for foreign keys and do another commit
	if (!tdgbl->gbl_sw_deactivate_indexes)
	{

		// Block added to verbose index creation by Toni Martir
		// Always try to activate deferred indices - it helps for some broken backups,
		// and in normal cases doesn't take much time to look for such indices. AP-2008.
		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_0);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_1);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Activate first indexes that are not foreign keys
		/*FOR (REQUEST_HANDLE req_handle1) IDS IN RDB$INDICES WITH
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE AND
			IDS.RDB$FOREIGN_KEY MISSING*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_1151), (char*) isc_1151);
		isc_1152.isc_1153 = DEFERRED_ACTIVE;
		if (req_handle1)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 2, &isc_1152, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 36, &isc_1154, (short) 0);
		   if (!isc_1154.isc_1156 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_1154.isc_1155, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_1154.isc_1155, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_1154.isc_1155)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s
			/*MODIFY IDS USING*/
			{
				/*IDS.RDB$INDEX_INACTIVE*/
				isc_1154.isc_1157 = FALSE;
			/*END_MODIFY;*/
			isc_1162.isc_1163 = isc_1154.isc_1157;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 4, (short) 2, &isc_1162, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error();
			/*END_ERROR;*/
			   }
			}

			/*SAVE*/
			{
			isc_commit_retaining (isc_status, (FB_API_HANDLE*) &gds_trans);;
			// existing ON_ERROR continues past error, beck
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				BURP_print (false, 173, index_name);
				BURP_print_status(false, isc_status);
				/*MODIFY IDS USING*/
				{
					/*IDS.RDB$INDEX_INACTIVE*/
					isc_1154.isc_1157 = TRUE;
				/*END_MODIFY;*/
				isc_1158.isc_1159 = isc_1154.isc_1157;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_1158, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_1160, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_2);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_3);
			SQLCODE = isc_sqlcode(isc_status);
			}

		// Only activate Foreign keys that have been marked for deferred
		// activation.
		// -bsriram, 11-May-1999             BUG: 10016

		// In case error happens creating FK, triggers don't let set
		// INACTIVE = TRUE for FK index. Therefore use separate
		// transaction be able to rollback when needed.
		// AP, 2005

		/*FOR (REQUEST_HANDLE req_handle1)
			CNST IN RDB$RELATION_CONSTRAINTS
			CROSS IDS IN RDB$INDICES WITH
			CNST.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			CNST.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME AND
			IDS.RDB$INDEX_INACTIVE EQ DEFERRED_ACTIVE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_1144), (char*) isc_1144);
		isc_vtov ((const char*) FOREIGN_KEY, (char*) isc_1145.isc_1146, 12);
		isc_1145.isc_1147 = DEFERRED_ACTIVE;
		if (req_handle1)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 14, &isc_1145, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 34, &isc_1148, (short) 0);
		   if (!isc_1148.isc_1150 || isc_status [1]) break;

			MISC_terminate(/*IDS.RDB$INDEX_NAME*/
				       isc_1148.isc_1149, index_name,
				(ULONG) MISC_symbol_length(/*IDS.RDB$INDEX_NAME*/
							   isc_1148.isc_1149, sizeof(/*IDS.RDB$INDEX_NAME*/
	 isc_1148.isc_1149)),
				sizeof(index_name));
			BURP_verbose(285, index_name);
			// activating and creating deferred index %s

			bool fError = false;
			isc_tr_handle activateIndexTran = 0;
			ISC_STATUS_ARRAY local_status_vector;
			ISC_STATUS* local_status = local_status_vector;

			/*START_TRANSACTION activateIndexTran;*/
			{
			isc_start_transaction (NULL, (FB_API_HANDLE*) &activateIndexTran, (short) 1, &DB, (short) 4, isc_tpb_4);
			}
			/*FOR (TRANSACTION_HANDLE activateIndexTran REQUEST_HANDLE req_handle5)
				IND1 IN RDB$INDICES WITH IND1.RDB$INDEX_NAME EQ IDS.RDB$INDEX_NAME*/
			{
                        if (!req_handle5)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_1134), (char*) isc_1134);
			isc_vtov ((const char*) isc_1148.isc_1149, (char*) isc_1135.isc_1136, 32);
			if (req_handle5)
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &activateIndexTran, (short) 0, (short) 32, &isc_1135, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 4, &isc_1137, (short) 0);
			   if (!isc_1137.isc_1138 || isc_status [1]) break;
				/*MODIFY IND1 USING*/
				{
						/*IND1.RDB$INDEX_INACTIVE*/
						isc_1137.isc_1139 = FALSE;
				/*END_MODIFY;*/
				isc_1140.isc_1141 = isc_1137.isc_1139;
                                isc_send (NULL, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_1140, (short) 0);
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 3, (short) 2, &isc_1142, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				fError = true;
				memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
			/*END_ERROR;*/
			   }
			}
			MISC_release_request_silent(req_handle5);

			if (!fError)
			{
				/*COMMIT activateIndexTran;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					fError = true;
					memcpy(local_status, isc_status, sizeof (ISC_STATUS_ARRAY));
				/*END_ERROR;*/
				   }
				}
			}
			if (fError)
			{
				/*ROLLBACK activateIndexTran;*/
				{
				isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &activateIndexTran);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				BURP_print (false, 173, index_name);
				BURP_print_status(false, local_status);
				tdgbl->flag_on_line = false;
			}
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		MISC_release_request_silent(req_handle1);
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (tdgbl->global_trans)
	{
		BURP_verbose (68);
		// msg 68 committing meta data
		/*EXEC SQL COMMIT TRANSACTION tdgbl->global_trans;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			general_on_error ();
		// Check to see if there is a warning
		if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
		{
			BURP_print_warning(gds_status);
		}
	}

	/*EXEC SQL SET TRANSACTION ISOLATION LEVEL READ COMMITTED NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 6, isc_tpb_5);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_6);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// AB: Recalculate RDB$DBKEY_LENGTH for VIEWS
	// When VIEWs are not processed in correct dependency order
	// then on create time it doesn't know anything from the
	// VIEW that's referenced.
	//
	update_view_dbkey_lengths(tdgbl);

	update_ownership(tdgbl);

	// Now that changing ownership of tables is over, it is safe to
	// update the database security class in RDB$DATABASE

	if (tdgbl->database_security_class[0]) // Do it only if it's not NULL
	{
		/*FOR (REQUEST_HANDLE req_handle1)
		X IN RDB$DATABASE*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_1126), (char*) isc_1126);
		if (req_handle1)
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 34, &isc_1127, (short) 0);
		   if (!isc_1127.isc_1129 || isc_status [1]) break;
			/*MODIFY X USING*/
			{
				strncpy(/*X.RDB$SECURITY_CLASS*/
					isc_1127.isc_1128, tdgbl->database_security_class,
					sizeof(/*X.RDB$SECURITY_CLASS*/
					       isc_1127.isc_1128));
			/*END_MODIFY;*/
			isc_ftof (isc_1127.isc_1128, 32, isc_1130.isc_1131, 32);
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 32, &isc_1130, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle1);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 2, &isc_1132, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle1);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle1);
	}

	// Add missing privileges
	fix_missing_privileges(tdgbl);

	// Fix values of system generators.
	fix_system_generators(tdgbl);

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// Check to see if there is a warning
	if (gds_status[0] == isc_arg_gds && gds_status[1] == 0 && gds_status[2] != isc_arg_end)
	{
		BURP_print_warning(gds_status);
	}

	BURP_verbose (88);
	// msg 88 finishing, closing, and going home

	//FB_UINT64 cumul_count =
	MVOL_fini_read();

	// Close database before we attach to it again.
	/*FINISH*/
	{
	if (DB)
	   isc_detach_database (isc_status, &DB);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	// attach database again to put it online

	BURP_verbose(360);

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	add_access_dpb(tdgbl, dpb);

	if (tdgbl->flag_on_line)
	{
		dpb.insertTag(isc_dpb_online);
	}

	// set forced writes to the value which was in the header
	dpb.insertByte(isc_dpb_force_write, tdgbl->hdr_forced_writes ? 1 : 0);

	FB_API_HANDLE db_handle = 0;
	if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
	{
		general_on_error();
	}
	if (isc_detach_database (tdgbl->status_vector, &db_handle))
		general_on_error();

	if (!tdgbl->flag_on_line)
	{
		BURP_print(false, 246);
		// msg 246 Database is not online due to failure to activate one or more indices.
		BURP_print(false, 247);
		// msg 247 Run gfix -online to bring database online without active indices.
		return FINI_DB_NOT_ONLINE;
	}

	// If the database is to be restored ReadOnly, set it to read_only now!
	if (tdgbl->gbl_sw_mode && tdgbl->gbl_sw_mode_val)
	{
		BURP_verbose (280);
		// msg 280: setting database to read-only access

		dpb.reset(isc_dpb_version1);
		add_access_dpb(tdgbl, dpb);

		dpb.insertByte(isc_dpb_set_db_readonly, 1);

		if (isc_attach_database(tdgbl->status_vector, 0, database_name, &db_handle,
								dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer())))
		{
			general_on_error();
		}
		if (isc_detach_database (tdgbl->status_vector, &db_handle))
			general_on_error();

	}

	return FINI_OK;
}

namespace // unnamed, private
{

// Add the common DPB params to the two attach calls in RESTORE_restore()
void add_access_dpb(BurpGlobals* tdgbl, Firebird::ClumpletWriter& dpb)
{
	tdgbl->uSvc->fillDpb(dpb);

	const UCHAR* authBlock;
	unsigned int authSize = tdgbl->uSvc->getAuthBlock(&authBlock);
	if (authBlock)
	{
		dpb.insertBytes(isc_dpb_auth_block, authBlock, authSize);
	}

	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}

	dpb.insertByte(isc_dpb_no_db_triggers, 1);
}

void add_files(BurpGlobals* tdgbl, const char* file_name)
{
   struct isc_1123_struct {
          char  isc_1124 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_1125;	/* RDB$FILE_START */
   } isc_1123;
/**************************************
 *
 *	a d d _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	This should be a multi-file database.
 *	Store files and starting
 *	addresses & commit this much.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	// store the RDB$FILES records

	FB_UINT64 start = FB_CONST64(201); // Magic number, can be taken from some constant?
	SLONG count = 0;
	const char* prev_file_name = NULL;

	for (burp_fil* file = tdgbl->gbl_sw_files; file; file = file->fil_next)
	{
		if (file->fil_name != file_name)
		{
			if (start > MAX_ULONG)
			{
				BURP_error(262, true, prev_file_name ? prev_file_name : file->fil_name.c_str());
			}
			count++;
			/*STORE (REQUEST_HANDLE req_handle1)
				X IN RDB$FILES*/
			{
			
                        if (!req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_1122), (char*) isc_1122);
			if (req_handle1)
			   {
				strcpy (/*X.RDB$FILE_NAME*/
					isc_1123.isc_1124, file->fil_name.c_str());
				/*X.RDB$FILE_START*/
				isc_1123.isc_1125 = start;
			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 260, &isc_1123, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
				MISC_release_request_silent(req_handle1);
			BURP_verbose (57, SafeArg() << file->fil_name.c_str() << start);
			// msg 57 adding file %s, starting at page %ld
		}
		else if (file->fil_length >= start - 1)
			file->fil_length -= start - 1;
		else
		{
			BURP_print (false, 96, SafeArg() << file->fil_length << (start - 1));
			// msg 96  length given for initial file (%ld) is less than minimum (%ld)
			file->fil_length = 0;
		}

		start += file->fil_length;
		prev_file_name = file->fil_name.c_str();
	}

	if (count)
	{
		BURP_verbose (70);
		// msg 70 committing secondary files
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 174);
			// msg 174 cannot commit files
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_7);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_8);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
}

void bad_attribute(scan_attr_t scan_next_attr, att_type bad_attr, USHORT type)
{
/**************************************
 *
 *	b a d _ a t t r i b u t e
 *
 **************************************
 *
 * Functional description
 *	We ran into an unsupported attribute.
 *	but it isn't the end of the world.
 *	We will try to skip some bad data and
 *	look for next valid attribute to continue the process.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	SLONG skip_count = 0;

	if (!tdgbl->gbl_sw_skip_count)
	{
		static const SafeArg dummy;
		TEXT t_name[128];
		fb_msg_format(NULL, burp_msg_fac, type, sizeof(t_name), t_name, dummy);
		BURP_print (false, 80, SafeArg() << t_name << int(bad_attr));
		// msg 80  don't recognize %s attribute %ld -- continuing
		int skip_l = get(tdgbl);
		if (skip_l)
			get_skip(tdgbl, skip_l);
	}
	else
	{
		if (scan_next_attr == NO_SKIP)
		{
			skip_count = tdgbl->gbl_sw_skip_count;
			get_skip(tdgbl, skip_count);
			BURP_print (false, 203, SafeArg() << skip_count << int(bad_attr));
			// msg 203: skipped %d bytes after reading a bad attribute %d
		}
		else
		{
			++skip_count;
			BURP_print (false, 205, SafeArg() << skip_count << int(bad_attr));
			// msg 205: skipped %d bytes looking for next valid attribute, encountered attribute %d
		}
		scan_next_attr = AFTER_SKIP;
	}
}


void create_database(BurpGlobals* tdgbl, const TEXT* file_name)
{
/**************************************
 *
 *	c r e a t e _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	create the new database, looking
 *	to see if there are any interesting
 *	things to do.
 *
 **************************************/

	// Get (physical) database record

	ULONG page_size = DEFAULT_PAGE_SIZE;
	// sweep_interval = -1;
	// sweep_interval = 0xFFFFFFFF;
	ULONG sweep_interval = MAX_ULONG;
	bool no_reserve = false;
	bool db_read_only = false, SQL_dialect_flag = false;
	bool forced_writes = true; // turned on by default
	ULONG page_buffers = 0;
	USHORT SQL_dialect = 0;

	att_type attribute;
	rec_type record;
	if (get_record(&record, tdgbl) == rec_physical_db)
	{
		while (get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_SQL_dialect:
				SQL_dialect_flag = true;
				SQL_dialect = (USHORT) get_int32(tdgbl);
				break;

			case att_page_size:
				page_size = get_int32(tdgbl);
				break;

			case att_sweep_interval:
				sweep_interval = get_int32(tdgbl);
				break;

			case att_forced_writes:
				forced_writes = get_int32(tdgbl) != FALSE;
				break;

			case att_no_reserve:
				no_reserve = get_int32(tdgbl) != FALSE;
				break;

			case att_db_read_only:
				db_read_only = get_int32(tdgbl) != FALSE;
				break;

			case att_page_buffers:
				page_buffers = get_int32(tdgbl);
				break;

			default:
				{
					const SSHORT l = get(tdgbl);
					if (l) {
						get_skip(tdgbl, l);
					}
				}
				break;
			}
		}
		get_record(&record, tdgbl);
	}

	if (record != rec_database)
		BURP_error_redirect (NULL, 32);
		// msg 32 Expected database description record

	if (tdgbl->gbl_sw_page_size)
	{
		if (tdgbl->gbl_sw_page_size < page_size)
		{
			BURP_print (false, 110, SafeArg() << page_size << tdgbl->gbl_sw_page_size);
			// msg 110 Reducing the database page size from %ld bytes to %ld bytes
		}
		page_size = tdgbl->gbl_sw_page_size;
	}

	tdgbl->hdr_forced_writes = forced_writes;

	if (tdgbl->gbl_sw_no_reserve)
		no_reserve = tdgbl->gbl_sw_no_reserve;

	// Override attribute setting with user requirement
	if (tdgbl->gbl_sw_mode)
		db_read_only = tdgbl->gbl_sw_mode_val;
	else
	{
		// No access mode specified by user. Use attribute settings. Since the
		// database is set to readOnly only after making it Online in
		// RESTORE_restore(), pass on this information through Global structures
		tdgbl->gbl_sw_mode = true;
		tdgbl->gbl_sw_mode_val = db_read_only;
	}

	if (tdgbl->gbl_sw_page_buffers)
		page_buffers = tdgbl->gbl_sw_page_buffers;

	Firebird::ClumpletWriter dpb(Firebird::ClumpletReader::Tagged, MAX_DPB_SIZE, isc_dpb_version1);
	tdgbl->uSvc->fillDpb(dpb);

	const UCHAR* authBlock;
	unsigned int authSize = tdgbl->uSvc->getAuthBlock(&authBlock);
	if (authBlock)
	{
		dpb.insertBytes(isc_dpb_auth_block, authBlock, authSize);
	}

	dpb.insertInt(isc_dpb_page_size, page_size & 0xff00);
	dpb.insertString(isc_dpb_gbak_attach, FB_VERSION, strlen(FB_VERSION));

	if (sweep_interval != MAX_ULONG)
	{
		dpb.insertInt(isc_dpb_sweep_interval, sweep_interval);
	}

	// If the database is to be restored "read_only", fillup the data pages
	if (no_reserve || db_read_only)
	{
		dpb.insertByte(isc_dpb_no_reserve, 1);
	}
	if (tdgbl->gbl_sw_user)
	{
		dpb.insertString(isc_dpb_user_name, tdgbl->gbl_sw_user, strlen(tdgbl->gbl_sw_user));
	}
	if (tdgbl->gbl_sw_password)
	{
		dpb.insertString(tdgbl->uSvc->isService() ? isc_dpb_password_enc : isc_dpb_password,
							 tdgbl->gbl_sw_password, strlen(tdgbl->gbl_sw_password));
	}
	if (tdgbl->gbl_sw_tr_user)
	{
		dpb.insertString(isc_dpb_trusted_auth, tdgbl->gbl_sw_tr_user, strlen(tdgbl->gbl_sw_tr_user));
	}
	if (page_buffers)
	{
		dpb.insertInt(isc_dpb_set_page_buffers, page_buffers);
	}

	// Turn off sync writes during restore
	dpb.insertByte(isc_dpb_force_write, 0);

	// which SQL dialect that this database speaks
	// When we restore backup files that came from prior
	// to V6, we force the SQL database dialect to 1

	dpb.insertByte(isc_dpb_sql_dialect, SQL_dialect_flag ? SQL_dialect : SQL_DIALECT_V5);

	// start database up shut down,
	// use single-user mode to avoid conflicts during restore process
	dpb.insertByte(isc_dpb_shutdown, isc_dpb_shut_attachment | isc_dpb_shut_single);
	dpb.insertInt(isc_dpb_shutdown_delay, 0);
	dpb.insertInt(isc_dpb_overwrite, tdgbl->gbl_sw_overwrite);

	dpb.insertByte(isc_dpb_no_db_triggers, 1);

	ISC_STATUS_ARRAY status_vector;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		dpb.insertString(isc_dpb_lc_ctype, tdgbl->gbl_sw_fix_fss_metadata,
			strlen(tdgbl->gbl_sw_fix_fss_metadata));
	}

	if (isc_create_database(status_vector, 0, file_name, &DB,
							dpb.getBufferLength(), reinterpret_cast<const SCHAR*>(dpb.getBuffer()),
							0))
	{
		BURP_error_redirect (status_vector, 33, SafeArg() << file_name);
		// msg 33 failed to create database %s
	}

	if (tdgbl->gbl_sw_version && !tdgbl->uSvc->isService())
	{
		BURP_print(false, 139, file_name);
		// msg 139 Version(s) for database "%s"
		isc_version(&DB, BURP_output_version, (void*)"\t%s\n");
	}

	BURP_verbose (74, SafeArg() << file_name << page_size);
	// msg 74 created database %s, page_size %ld bytes
}

void decompress(BurpGlobals* tdgbl, UCHAR* buffer, USHORT length)
{
/**************************************
 *
 *	d e c o m p r e s s
 *
 **************************************
 *
 * Functional description
 *	Get a number of compressed bytes.
 *
 **************************************/
	UCHAR* p = buffer;
	const UCHAR* const end = p + length;

	while (p < end)
	{
		// This change was made to restore National Semi-Conductor's corrupted
		// gbak file and it is in the code base now.  -Andrew

		// so count really only between -128..127
		SSHORT count = (signed char) get(tdgbl);
		if (count > 0)
		{
			if (end - p < count)
			{
				BURP_print (false, 202, SafeArg() << count << (end - p));
				// msg 202: adjusting a decompression length error: invalid length  %d was adjusted to %d
				count = end - p;
			}
			p = get_block(tdgbl, p, count);
		}
		else if (count < 0)
		{
			if (end + count < p)
			{
				BURP_print(false, 202, SafeArg() << count << (p - end));
				// msg 202: adjusting a decompression length error: invalid length %d was adjusted to %d
				count = p - end;
			}
			const UCHAR c = get(tdgbl);
			memset (p, c, -count);
			p += -count;
		}
	}

	if (p > end) {
		BURP_error_redirect (NULL, 34); // msg 34 RESTORE: decompression length error
	}
}

void eat_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	e a t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Discard a blob from backup file
 *
 **************************************/

	const SLONG length = get_int32(tdgbl);

	get_skip(tdgbl, length);
}

// *****************************
// e a t _ t e x t
// *****************************
// Discard a text field from the backup file.
void eat_text(BurpGlobals* tdgbl)
{
	const ULONG l = get(tdgbl);
	if (l)
		MVOL_skip_block(tdgbl, l);
}

// *****************************
// e a t _ t e x t 2
// *****************************
// Discard a text field from the backup file, using USHORT length indicator.
void eat_text2(BurpGlobals* tdgbl)
{
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));
	if (len)
		MVOL_skip_block(tdgbl, len);
}

burp_rel* find_relation(BurpGlobals* tdgbl, const TEXT* name)
{
/**************************************
 *
 *	f i n d _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Given a relation name, find the relation block.  If there isn't
 *	one, produce a fatal error.
 *
 **************************************/

	// Why isn't strcmp used here?
	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		for (const TEXT* p = relation->rel_name, *q = name; *p == *q; p++, q++)
		{
			if (!*p)
				return relation;
		}
	}

	BURP_error_redirect (NULL, 35, SafeArg() << name);
	// msg 35 can't find relation %s

	return NULL;
}

void fix_security_class_name(BurpGlobals* tdgbl, TEXT* sec_class, bool is_field)
{
/**************************************
 *
 *	f i x _ s e c u r i t y _ c l a s s _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Reassign a proper (unique) name for auto-generated
 *  security classes.
 *
 **************************************/

	const char* const prefix = is_field ? SQL_FLD_SECCLASS_PREFIX : SQL_SECCLASS_PREFIX;
	const int prefix_length = is_field ? SQL_FLD_SECCLASS_PREFIX_LEN : SQL_SECCLASS_PREFIX_LEN;

	if (strncmp(sec_class, prefix, prefix_length))
		return;

	if (tdgbl->runtimeODS < DB_VERSION_DDL11_2)
		return;

	ISC_STATUS_ARRAY status_vector;

	isc_req_handle& handle = tdgbl->handles_fix_security_class_name_req_handle1;

	if (!handle)
	{
		UCHAR blr_buffer[BUFFER_TINY];
		UCHAR* blr = blr_buffer;

		add_byte(blr, blr_version5);
		add_byte(blr, blr_begin);

		add_byte(blr, blr_message);
		add_byte(blr, 0);
		add_word(blr, 1);

		add_byte(blr, blr_int64);
		add_byte(blr, 0);

		add_byte(blr, blr_send);
		add_byte(blr, 0);

		add_byte(blr, blr_begin);
		add_byte(blr, blr_assignment);

		add_byte(blr, blr_gen_id);
		add_string(blr, SQL_SECCLASS_GENERATOR);

		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, 1);

		add_byte(blr, blr_parameter);
		add_byte(blr, 0);
		add_word(blr, 0);

		add_byte(blr, blr_end);
		add_byte(blr, blr_end);
		add_byte(blr, blr_eoc);

		const USHORT blr_length = blr - blr_buffer;
		fb_assert(blr_length <= sizeof(blr_buffer));

		if (isc_compile_request(status_vector, &DB, &handle,
							    blr_length, (const SCHAR*) blr_buffer))
		{
			BURP_error_redirect(status_vector, 316);
			// msg 316 Failed while fixing the security class name
		}
	}

	if (isc_start_request(status_vector, &handle, &gds_trans, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	SINT64 id = 0;

	if (isc_receive(status_vector, &handle, 0, sizeof(SINT64), &id, 0))
	{
		BURP_error_redirect(status_vector, 316);
		// msg 316 Failed while fixing the security class name
	}

	fb_assert(id);

	snprintf(sec_class, MAX_SQL_IDENTIFIER_SIZE, "%s%"SQUADFORMAT, prefix, id);
}

void general_on_error()
{
/**************************************
 *
 *	g e n e r a l _ o n _ e r r o r
 *
 **************************************
 *
 * Functional description
 *	Handle any general ON_ERROR clause during restore.
 *
 **************************************/
	BurpGlobals* tdgbl = BurpGlobals::getSpecific();

	if (isc_status[1] == isc_malformed_string)
	{
		Firebird::Arg::StatusVector oldVector(isc_status);
		Firebird::Arg::Gds newVector(isc_gbak_invalid_metadata);
		newVector.append(oldVector);
		newVector.copyTo(isc_status);
	}
	BURP_print_status (true, isc_status);

	BURP_abort ();
}

bool get_acl(BurpGlobals* tdgbl, const TEXT* owner_nm, ISC_QUAD* blob_id, ISC_QUAD* new_blob_id)
{
/**************************************
 *
 *	g e t _ a c l
 *
 **************************************
 *
 * Functional description
 *
 *	open the blob that contains the ACL list
 *	get the ACL list of a relation
 *	replace the owner of the relation in the ACL list with
 *	  the creator of the relation
 *	create a new blob
 *	store the new ACL list in the new blob
 *
 **************************************/

	static const UCHAR blr_items[] =
	{
		isc_info_blob_max_segment,
		isc_info_blob_total_length,
		isc_info_blob_num_segments
	};

	// If the blob is null, don't store it.  It will be restored as null.

	if (!blob_id->gds_quad_high && !blob_id->gds_quad_low)
		return false;

	// Open the blob and get it's vital statistics

	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);

	if (! blob.open(DB, gds_trans, *blob_id))
	{
		// msg 24 isc_open_blob failed
		BURP_error_redirect (status_vector, 24);
	}

	UCHAR blob_info[32];
	if (!blob.getInfo(sizeof(blr_items), blr_items, sizeof(blob_info), blob_info))
	{
		// msg 20 isc_blob_info failed
		BURP_error_redirect (status_vector, 20);
	}

	ULONG length = 0;
	UCHAR item;
	USHORT max_segment;
	ULONG num_segments;
	const UCHAR* p = blob_info;

	while ((item = *p++) != isc_info_end)
	{
		const USHORT len = (USHORT) gds__vax_integer (p, 2);
		p += 2;
		const SLONG n = gds__vax_integer (p, len);
		p += len;
		switch (item)
		{
		case isc_info_blob_max_segment:
			max_segment = (USHORT) n;
			break;

		case isc_info_blob_total_length:
			length = n;
			break;

		case isc_info_blob_num_segments:
			num_segments = n;

			// we assume that the ACL list was written out as
			// in one big segment

			if (num_segments > 1)
			{
				// CVC: I can't see the effect of assert(true)
				fb_assert (num_segments > 1);
			}
			break;

		default:
			// msg 79 don't understand blob info item %ld
			BURP_print (false, 79, SafeArg() << int(item));
			// CVC: do you return, without closing the blob, dear function???
			if (!blob.close())
			{
				BURP_error_redirect (status_vector, 23);
				// msg 23 isc_close_blob failed
			}
			return false;
		}
	}

	if (!length)
	{
		if (!blob.close())
		{
			BURP_error_redirect (status_vector, 23);
			// msg 23 isc_close_blob failed
		}
		return false;
	}

	// Rdb sometimes gets the length messed up

	if (length < max_segment)
		length = max_segment;

	fb_assert(length <= ULONG(MAX_SLONG));

	// Allocate a buffer large enough for the largest segment and start grinding.

	BlobBuffer static_buffer;
	UCHAR* buffer = static_buffer.getBuffer(length);

	size_t return_length = 0;
	if (!blob.getData(length, buffer, return_length))
	{
		// msg 22 gds_$get_segment failed
		BURP_error_redirect (status_vector, 22);
	}
	// protect ourselves
	length = return_length;

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	const UCHAR* from = buffer + 3; // skip ACL_version, ACL_id_list, and id_person
	const SLONG id_person_len = (SLONG) *from;

	const UCHAR* c_1 = (UCHAR*) owner_nm;
	const size_t owner_nm_len = strlen(owner_nm);
	fb_assert(owner_nm_len <= size_t(MAX_UCHAR));

	// If some day, ACLs become bigger than MAX_SLONG, we should review this code.
	const SLONG bufSize = SLONG(length) - id_person_len + SLONG(owner_nm_len);
	fb_assert(bufSize > 0);
	BlobBuffer new_static_buffer;
	UCHAR* const new_buffer = new_static_buffer.getBuffer(bufSize);

	from = buffer;
	UCHAR* to = new_buffer;
	*to++ = *from++; // copy ACL_verion
	*to++ = *from++; // copy ACL_id_list
	*to++ = *from++; // copy id_person
	*to++ = UCHAR(owner_nm_len);

	size_t new_len = 4; //new_len + 4; Previously, new_len was set to zero at the top
	// from = buffer + id_person_len + 4; redundant, see 2nd loop below.
	for (ULONG cnt = 0; cnt < owner_nm_len; cnt++)
	{
		*to++ = *c_1++;
		new_len++;
	}

	const UCHAR* const end_buffer = buffer + length;
	for (from = buffer + id_person_len + 4; from < end_buffer; from++)
	{
		*to++ = *from;
		new_len++;
	}

	if (!blob.create(DB, gds_trans, *new_blob_id))
	{
		// msg 37 isc_create_blob failed
		BURP_error_redirect (status_vector, 37);
	}

	if (!blob.putData(new_len, new_buffer))
	{
		// msg 38 isc_put_segment failed
		BURP_error_redirect (status_vector, 38);
	}

	if (!blob.close())
	{
		// msg 23 isc_close_blob failed
		BURP_error_redirect (status_vector, 23);
	}

	return true;
}

void get_array(BurpGlobals* tdgbl, burp_rel* relation, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Read array data from input file to nice,
 *	shiney, new array.
 *
 **************************************/
	burp_fld*		field = NULL;
	ISC_STATUS_ARRAY	status_vector;
	USHORT		count, field_number, field_length = 0;
	UCHAR*		buffer = NULL;
	UCHAR*		p = NULL;
	UCHAR		blr_buffer[200]; // enough for a sdl with 16 dimensions
	lstring		xdr_slice;

	// don't free something you don't allocate
	lstring xdr_buffer;
	xdr_buffer.lstr_allocated = 0;
	xdr_buffer.lstr_address = NULL;

	// Pick up attributes
	SLONG		fld_ranges[2 * MAX_DIMENSION];
	SLONG       slice_length = 0;
	SLONG       *range;
	const SLONG* end_ranges;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);
	att_type	attribute;
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_int32(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next)
			{
				if (field->fld_number == field_number)
					break;
			}
			if (!field) {
				BURP_error_redirect (NULL, 36);	// msg 36 Can't find field for blob
			}

			field_length = field->fld_length;
			if (field->fld_type == blr_varying)
				field_length += sizeof(USHORT);
			slice_length = field_length;
			//
			// Copy the ranges onto a buffer and let the program
			// mess with the copy rather than the original
			//
			memcpy(fld_ranges, field->fld_ranges, sizeof(fld_ranges));
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_int32(tdgbl);
			end_ranges = fld_ranges + 2 * field->fld_dimensions;
			for (range = fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_int32(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute (scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_int32(tdgbl);
				slice_length *= (range[1] - range[0] + 1);
			}
			break;

		default:
			bad_attribute (scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG return_length = get(tdgbl);
	return_length |= get(tdgbl) << 8;
	return_length |= get(tdgbl) << 16;
	return_length |= get(tdgbl) << 24;

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);

	SLONG last_element_dim[MAX_DIMENSION];
	if (return_length != slice_length)
	{
		int upper, lower;
		//
		// Ugh!  The full array wasn't returned and versions of gbak prior to
		// V3.2I don't explicitly signal this.  We must recompute the top
		// element to restore.
		//
		// Double Ugh!  gbak (Versions prior to 5.0) while backing up calculates
		// the top dimensions incorrectly So whatever was written as top dimensions
		// is useless. 5.0 gbak has written correct dimensions, but what the heck
		// we'll calculate it again
		//

		int elements_remaining = return_length / field_length;
		//
		// Backup (versions prior to 5.0) has surely written wrong dimensions.
		// Ignore whatever is read in fld_ranges and calculate the dimensions
		// of the last element. field->fld_ranges has the max dimensions.
		// last_element_dim holds only the upper bounds of each dimension.
		//
		for (int i1 = 0, i3 = 0; i1 < field->fld_dimensions; i1++)
		{
			int divisor = 1;
			for (int i2 = (2 * (i1 + 1) + 1); i2 <= field->fld_dimensions * 2; i2 += 2)
				divisor *= (field->fld_ranges[i2] - field->fld_ranges[i2 - 1] + 1);
			last_element_dim[i1] = (elements_remaining - 1) / divisor + field->fld_ranges[i3];
			elements_remaining  -= (last_element_dim[i1] - field->fld_ranges[i3]) * divisor;
			i3 += 2;
		}

		int current_dim;
#ifdef DEBUG
		fprintf(stderr, "\nLast element upper bounds read from backup file:\n");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", fld_ranges[current_dim]);
		fprintf(stderr, "\nCalculated Last element upper bounds :\n");
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
			fprintf(stderr, "%ld ", last_element_dim[current_dim]);
		fprintf(stderr, "return_length = %ld\n", return_length);
		fprintf(stderr, "elements_returned = %ld\n", return_length / field_length);
		fprintf(stderr, "Max dims[");
		for (current_dim = 1; current_dim < field->fld_dimensions * 2; current_dim += 2)
			fprintf(stderr, "%ld ", field->fld_ranges[current_dim]);
		fprintf(stderr, "]");
#endif
		int data_at = 0;
		//
		// We have an irregurlar shaped slice to write. The following for loop
		// chops the array into writable rectangular/square slice and sends it
		// to the engine. When the loop cycles through all dimensions, we would
		// have written the whole of the irregular slice.
		//
		for (current_dim = 0; current_dim < field->fld_dimensions; current_dim++)
		{
			UCHAR* blr = blr_buffer;
			bool dont_write = false;

			// build the sdl

			add_byte(blr, isc_sdl_version1);

			add_byte(blr, isc_sdl_struct);
			add_byte(blr, 1);

			switch (field->fld_type)
			{
			case blr_text:
			case blr_varying:
				if (field->fld_type == blr_text)
					add_byte(blr, blr_text2);
				else
					add_byte(blr, blr_varying2);
				add_word(blr, field->fld_character_set_id);
				add_word(blr, field->fld_length);
				break;
			case blr_short:
			case blr_long:
			case blr_quad:
			case blr_int64:
				add_byte(blr, field->fld_type);
				add_byte(blr, field->fld_scale);
				break;
			default:
				add_byte(blr, field->fld_type);
			}

			add_byte(blr, isc_sdl_relation);
			add_string(blr, relation->rel_name);
			add_byte(blr, isc_sdl_field);
			add_string(blr, field->fld_name);

			// each element spec starts here

#ifdef DEBUG
			fprintf(stderr, "\nBounds written[");
#endif
			int elements_written = 1;
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			//
			// Here is the important work. Calculate the the bounds to be written
			// so that the resulting slice is a rectangular/square slice.
			// For a 2 dimensional array of size 1..N, 1..M, which is partially
			// filled, we have already calculated the dims of last element. Say
			// if this was x,y (x is row, y is column) then we do
			//    isc_put_slice(1..x-1, 1..M);
			//    isc_put_slice(x..x, 1..y);
			// similarly for a 3D array [N,M,K] whose last element dims are (x,y,z)
			//    isc_put_slice(1..x-1, 1..M, 1..K);
			//    isc_put_slice(x..x, 1..y-1, 1..K);
			//    isc_put_slice(x..x, y..y, 1..z);
			// This is applicable for any number of dimensions.
			// Special cases:
			// for example in case of a 2D array (10,10) and if the last element
			// dims were (1,2), we would just do a isc_put_slice(1..1, 1..2).
			// This is applied for any number of dimensions.
			//
			for (range = field->fld_ranges, count = 0; range < end_ranges; range += 2, count++)
			{
				add_byte(blr, isc_sdl_do2);
				add_byte(blr, count);
				//
				// Normally we loop through all dimensions chopping off slices
				// and writing them. This works fine but this also means that
				// we blindly put slices without actually figuring out if we
				// really need to do so. For eg: if we have a 2D array of
				// size [10,4] and the last element dims are [6,4] then all
				// we need to do is is to put one slice as
				//   isc_put_slice(1..6,1..4)
				// rather than looping through the dimensions and putting
				//   isc_put_slice(1..5,1..4)
				//   isc_put_slice(6..6,1..4)
				// we could extend this logic to any no of dims. The following
				// if condition figures out such cases. This combined with
				// the Special case should optimize the no of isc_put_slice
				// we perform.
				//
				if (current_dim + 1 == field->fld_dimensions - 1 &&
					field->fld_dimensions - count == 2 && last_element_dim[count + 1]  == range[3])
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					range += 2;
					count++;
					add_byte(blr, isc_sdl_do2);
					add_byte(blr, count);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = last_element_dim[count];
					elements_written *= (upper - lower + 1);
					++current_dim;
					break;
				}
				if (current_dim == count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					lower = range[0];
					add_byte(blr, isc_sdl_long_integer);
					upper = (current_dim == field->fld_dimensions - 1) ?
						last_element_dim[count] : (last_element_dim[count] - 1);
					if (upper < range[0])
					{
						// see Special Case above

						dont_write = true;
						break;
					}
					add_long(blr, upper);
				}
				else if (current_dim < count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[0]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, range[1]);
					upper = range[1];
					lower = range[0];
				}
				else if (current_dim > count)
				{
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					add_byte(blr, isc_sdl_long_integer);
					add_long(blr, last_element_dim[count]);
					upper = lower = last_element_dim[count];
				}
				elements_written *= (upper - lower + 1);
#ifdef DEBUG
				fprintf(stderr, "%d..%d ", lower, upper);
#endif
			}
			if (dont_write)
				continue;
#ifdef DEBUG
			fprintf(stderr, "]");
			fprintf(stderr, "\n Elements Written=%d  ", elements_written);
#endif

			add_byte(blr, isc_sdl_element);
			add_byte(blr, 1);
			add_byte(blr, isc_sdl_scalar);
			add_byte(blr, 0);
			add_byte(blr, field->fld_dimensions);

			for (count = 0; count < field->fld_dimensions; count++)
			{
				add_byte(blr, isc_sdl_variable);
				add_byte(blr, count);
			}

			add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
			if (debug_on)
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

			const USHORT blr_length = blr - blr_buffer;

			if (data_at == 0)
			{
				buffer = BURP_alloc (return_length);
				SLONG lcount = 0;
				if (tdgbl->gbl_sw_transportable)
				{
					if (get_attribute(&attribute, tdgbl) != att_xdr_array)
					{
						// msg 55 Expected XDR record length
						BURP_error_redirect (NULL, 55);
					}
					else
					{
						lcount = get(tdgbl);
						lcount |= get(tdgbl) << 8;
						lcount |= get(tdgbl) << 16;
						lcount |= get(tdgbl) << 24;
						xdr_buffer.lstr_length = xdr_buffer.lstr_allocated = lcount;
						xdr_buffer.lstr_address = BURP_alloc(lcount);
						xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
						xdr_slice.lstr_address = buffer;
						p = xdr_buffer.lstr_address;
					}
				}
				else
				{
					p = buffer;
					lcount = return_length;
				}

				if (lcount)
					get_block(tdgbl, p, lcount);

				if (tdgbl->gbl_sw_transportable)
					CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);
			}

			if (isc_put_slice(status_vector, &DB, &gds_trans,
							  blob_id, blr_length, reinterpret_cast<const char*>(blr_buffer),
							  0,	// param length for subset of an array handling
							  NULL,	// param for subset of an array handling
							  elements_written * field->fld_length, buffer + data_at))
			{
				BURP_print (false, 81, field->fld_name);
				// msg 81 error accessing blob field %s -- continuing
				BURP_print_status (true, status_vector);
#ifdef DEBUG
				PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
				return;
			}
			data_at += elements_written * field->fld_length;
#ifdef DEBUG
			fprintf(stderr, "next data_at = %d\n", data_at);
#endif
		}
	}
	else
	{
		// This is the regular case we've got the entire array
		UCHAR* blr = blr_buffer;

		// build the sdl

		add_byte(blr, isc_sdl_version1);

		add_byte(blr, isc_sdl_struct);
		add_byte(blr, 1);

		switch (field->fld_type)
		{
		case blr_text:
		case blr_varying:
			if (field->fld_type == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);
			add_word(blr, field->fld_character_set_id);
			add_word(blr, field->fld_length);
			break;
		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;
		default:
			add_byte(blr, field->fld_type);
		}

		add_byte(blr, isc_sdl_relation);
		add_string(blr, relation->rel_name);
		add_byte(blr, isc_sdl_field);
		add_string(blr, field->fld_name);

		// each element spec starts here

		for (range = fld_ranges, count = 0; range < end_ranges; range += 2, count++)
		{
			add_byte(blr, isc_sdl_do2);
			add_byte(blr, count);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[0]);
			add_byte(blr, isc_sdl_long_integer);
			add_long(blr, range[1]);
		}

		add_byte(blr, isc_sdl_element);
		add_byte(blr, 1);
		add_byte(blr, isc_sdl_scalar);
		add_byte(blr, 0);
		add_byte(blr, field->fld_dimensions);

		for (count = 0; count < field->fld_dimensions; count++)
		{
			add_byte(blr, isc_sdl_variable);
			add_byte(blr, count);
		}

		add_byte(blr, isc_sdl_eoc);

#ifdef DEBUG
		if (debug_on)
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif

		const USHORT blr_length = blr - blr_buffer;

		buffer = BURP_alloc (return_length);
		SLONG lcount = 0;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get_attribute(&attribute, tdgbl) != att_xdr_array)
			{
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			}
			else
			{
				xdr_buffer.lstr_allocated = get(tdgbl);
				xdr_buffer.lstr_allocated |= get(tdgbl) << 8;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 16;
				xdr_buffer.lstr_allocated |= get(tdgbl) << 24;
				lcount = xdr_buffer.lstr_length = xdr_buffer.lstr_allocated;
				xdr_buffer.lstr_address = BURP_alloc (xdr_buffer.lstr_allocated);
				xdr_slice.lstr_allocated = xdr_slice.lstr_length = return_length;
				xdr_slice.lstr_address = buffer;
				p = xdr_buffer.lstr_address;
			}
		}
		else
		{
			p = buffer;
			lcount = return_length;
		}

		if (lcount)
			get_block(tdgbl, p, lcount);

		if (tdgbl->gbl_sw_transportable)
			CAN_slice (&xdr_buffer, &xdr_slice, FALSE, /*blr_length,*/ blr_buffer);


		if (isc_put_slice(status_vector, &DB, &gds_trans,
						  blob_id, blr_length,
						  reinterpret_cast<const char*>(blr_buffer),
						  0,	  // param length for subset of an array handling
						  NULL,  // param for subset of an array handling
						  return_length, buffer))
		{
			BURP_print (false, 81, field->fld_name);
			// msg 81 error accessing blob field %s -- continuing
			BURP_print_status (false, status_vector);
#ifdef DEBUG
			PRETTY_print_sdl (blr_buffer, NULL, NULL, 0);
#endif
			return;
		}
	}

	BURP_free (buffer);
	if (tdgbl->gbl_sw_transportable && xdr_buffer.lstr_allocated)
		BURP_free (xdr_buffer.lstr_address);
}

void get_blob(BurpGlobals* tdgbl, const burp_fld* fields, UCHAR* record_buffer)
{
/**************************************
 *
 *	g e t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiny, new blob.
 *
 **************************************/

	// Pick up attributes

	ULONG segments = 0;
	USHORT field_number = MAX_USHORT;
	USHORT max_segment = 0;
	UCHAR blob_type = 0;

	att_type	attribute;
	scan_attr_t	scan_next_attr;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_int32(tdgbl);
			break;

		case att_blob_max_segment:
			max_segment = (USHORT) get_int32(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_int32(tdgbl);
			break;

		case att_blob_type:
			blob_type = (UCHAR) get_int32(tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Find the field associated with the blob
	const burp_fld* field;
	for (field = fields; field; field = field->fld_next)
	{
		if (field->fld_number == field_number)
			break;
	}

	if (!field)
	{
		BURP_error_redirect (NULL, 36);
		// msg 36 Can't find field for blob
	}

	// Create new blob

	ISC_QUAD* blob_id = (ISC_QUAD*) ((UCHAR*) record_buffer + field->fld_offset);
	ISC_STATUS_ARRAY status_vector;
	UserBlob blob(status_vector);
	const UCHAR blob_desc[] = {isc_bpb_version1, isc_bpb_type, 1, blob_type};

	if (!blob.create(DB, gds_trans, *blob_id, sizeof(blob_desc), blob_desc))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(max_segment);

	// Eat up blob segments

	for (; segments > 0; --segments )
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
		{
			get_block(tdgbl, buffer, length);
		}
		if (!blob.putSegment(length, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}


void get_blr_blob(BurpGlobals* tdgbl, ISC_QUAD& blob_id, bool glb_trans)
{
/**************************************
 *
 *	g e t _ b l r _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/

	size_t length = get_int32(tdgbl);

	// Create new blob

	isc_tr_handle local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	ISC_STATUS_ARRAY	status_vector;
	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length + 1);

	if (length)
	{
		UCHAR* p = get_block(tdgbl, buffer, length);
		// Make sure it has an eoc
		if (p[-1] != blr_eoc)
		{
			p[0] = blr_eoc;
			length++;
		}
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

bool get_character_set(BurpGlobals* tdgbl)
{
   struct isc_1079_struct {
          char  isc_1080 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_1081;	/* RDB$DESCRIPTION */
          char  isc_1082 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_1083 [32];	/* RDB$FORM_OF_USE */
          char  isc_1084 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_LONG isc_1085;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_1086;	/* gds__null_flag */
          short isc_1087;	/* RDB$BYTES_PER_CHARACTER */
          short isc_1088;	/* gds__null_flag */
          short isc_1089;	/* gds__null_flag */
          short isc_1090;	/* gds__null_flag */
          short isc_1091;	/* RDB$SYSTEM_FLAG */
          short isc_1092;	/* gds__null_flag */
          short isc_1093;	/* RDB$CHARACTER_SET_ID */
          short isc_1094;	/* gds__null_flag */
          short isc_1095;	/* gds__null_flag */
          short isc_1096;	/* gds__null_flag */
          short isc_1097;	/* gds__null_flag */
   } isc_1079;
   struct isc_1099_struct {
          char  isc_1100 [32];	/* RDB$OWNER_NAME */
          char  isc_1101 [32];	/* RDB$SECURITY_CLASS */
          char  isc_1102 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_1103;	/* RDB$DESCRIPTION */
          char  isc_1104 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_1105 [32];	/* RDB$FORM_OF_USE */
          char  isc_1106 [32];	/* RDB$CHARACTER_SET_NAME */
          ISC_LONG isc_1107;	/* RDB$NUMBER_OF_CHARACTERS */
          short isc_1108;	/* gds__null_flag */
          short isc_1109;	/* gds__null_flag */
          short isc_1110;	/* gds__null_flag */
          short isc_1111;	/* RDB$BYTES_PER_CHARACTER */
          short isc_1112;	/* gds__null_flag */
          short isc_1113;	/* gds__null_flag */
          short isc_1114;	/* gds__null_flag */
          short isc_1115;	/* RDB$SYSTEM_FLAG */
          short isc_1116;	/* gds__null_flag */
          short isc_1117;	/* RDB$CHARACTER_SET_ID */
          short isc_1118;	/* gds__null_flag */
          short isc_1119;	/* gds__null_flag */
          short isc_1120;	/* gds__null_flag */
          short isc_1121;	/* gds__null_flag */
   } isc_1099;
/**************************************
 *
 *	g e t _ c h a r a c t e r _ s e t
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined character sets
 *
 **************************************/
	class AbortException
	{
	};

	att_type		attribute;
	scan_attr_t		scan_next_attr;

	try
	{
		if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
		{
			GDS_NAME charset_name;
			bool securityClass = false;

			/*STORE (REQUEST_HANDLE tdgbl->handles_get_character_sets_req_handle1)
				X IN RDB$CHARACTER_SETS*/
			{
			
                        if (!tdgbl->handles_get_character_sets_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (short) sizeof(isc_1098), (char*) isc_1098);
			if (tdgbl->handles_get_character_sets_req_handle1)
			   {
			   isc_1099.isc_1103 = isc_blob_null;
				/*X.RDB$CHARACTER_SET_NAME.NULL*/
				isc_1099.isc_1121 = TRUE;
				/*X.RDB$FORM_OF_USE.NULL*/
				isc_1099.isc_1120 = TRUE;
				/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
				isc_1099.isc_1119 = TRUE;
				/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
				isc_1099.isc_1118 = TRUE;
				/*X.RDB$CHARACTER_SET_ID.NULL*/
				isc_1099.isc_1116 = TRUE;
				/*X.RDB$SYSTEM_FLAG*/
				isc_1099.isc_1115 = 0;
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_1099.isc_1114 = FALSE;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_1099.isc_1113 = TRUE;
				/*X.RDB$FUNCTION_NAME.NULL*/
				isc_1099.isc_1112 = TRUE;
				/*X.RDB$BYTES_PER_CHARACTER.NULL*/
				isc_1099.isc_1110 = TRUE;
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_1099.isc_1109 = TRUE;
				/*X.RDB$OWNER_NAME.NULL*/
				isc_1099.isc_1108 = TRUE;

				skip_init(&scan_next_attr);
				while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
				{
					switch (attribute)
					{
					case att_charset_name:
						/*X.RDB$CHARACTER_SET_NAME.NULL*/
						isc_1099.isc_1121 = FALSE;
						GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
							 isc_1099.isc_1106);
						BURP_verbose (msgVerbose_restore_charset, /*X.RDB$CHARACTER_SET_NAME*/
											  isc_1099.isc_1106);
						break;

					case att_charset_form:
						/*X.RDB$FORM_OF_USE.NULL*/
						isc_1099.isc_1120 = FALSE;
						GET_TEXT(/*X.RDB$FORM_OF_USE*/
							 isc_1099.isc_1105);
						break;

					case att_charset_numchar:
						/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
						isc_1099.isc_1119 = FALSE;
						/*X.RDB$NUMBER_OF_CHARACTERS*/
						isc_1099.isc_1107 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_coll:
						/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
						isc_1099.isc_1118 = FALSE;
						GET_TEXT(/*X.RDB$DEFAULT_COLLATE_NAME*/
							 isc_1099.isc_1104);
						break;

					case att_charset_id:
						/*X.RDB$CHARACTER_SET_ID.NULL*/
						isc_1099.isc_1116 = FALSE;
						/*X.RDB$CHARACTER_SET_ID*/
						isc_1099.isc_1117 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_sysflag:
						/*X.RDB$SYSTEM_FLAG.NULL*/
						isc_1099.isc_1114 = FALSE;
						/*X.RDB$SYSTEM_FLAG*/
						isc_1099.isc_1115 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_description:
						/*X.RDB$DESCRIPTION.NULL*/
						isc_1099.isc_1113 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_1099.isc_1103, false);
						break;

					case att_charset_funct:
						/*X.RDB$FUNCTION_NAME.NULL*/
						isc_1099.isc_1112 = FALSE;
						GET_TEXT(/*X.RDB$FUNCTION_NAME*/
							 isc_1099.isc_1102);
						break;

					case att_charset_bytes_char:
						/*X.RDB$BYTES_PER_CHARACTER.NULL*/
						isc_1099.isc_1110 = FALSE;
						/*X.RDB$BYTES_PER_CHARACTER*/
						isc_1099.isc_1111 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_security_class:
						if (tdgbl->RESTORE_format >= 10)
						{
							GET_TEXT(/*X.RDB$SECURITY_CLASS*/
								 isc_1099.isc_1101);
							/*X.RDB$SECURITY_CLASS.NULL*/
							isc_1099.isc_1109 = FALSE;
							securityClass = true;
						}
						else
							bad_attribute(scan_next_attr, attribute, msgErr_restore_charset);
						break;

					case att_charset_owner_name:
						if (tdgbl->RESTORE_format >= 10)
						{
							GET_TEXT(/*X.RDB$OWNER_NAME*/
								 isc_1099.isc_1100);
							/*X.RDB$OWNER_NAME.NULL*/
							isc_1099.isc_1108 = FALSE;
						}
						else
							bad_attribute(scan_next_attr, attribute, msgErr_restore_charset);
						break;

					default:
						bad_attribute(scan_next_attr, attribute, msgErr_restore_charset);
						// 213 character set
						break;
					}
				}

				if (/*X.RDB$CHARACTER_SET_ID.NULL*/
				    isc_1099.isc_1116 && !/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
     isc_1099.isc_1118 &&
					!/*X.RDB$CHARACTER_SET_NAME.NULL*/
					 isc_1099.isc_1121)
				{
					tdgbl->defaultCollations.add(
						Firebird::Pair<Firebird::NonPooled<Firebird::MetaName, Firebird::MetaName> >(
							/*X.RDB$CHARACTER_SET_NAME*/
							isc_1099.isc_1106, /*X.RDB$DEFAULT_COLLATE_NAME*/
  isc_1099.isc_1104));
					throw AbortException();	// prevent the STORE
				}

				strcpy(charset_name, /*X.RDB$CHARACTER_SET_NAME*/
						     isc_1099.isc_1106);

			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 232, &isc_1099, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}

			if (!securityClass)
				collect_missing_privs(tdgbl, obj_charset, charset_name);
		}
		else
		{
			/*STORE (REQUEST_HANDLE tdgbl->handles_get_character_sets_req_handle1)
				X IN RDB$CHARACTER_SETS*/
			{
			
                        if (!tdgbl->handles_get_character_sets_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (short) sizeof(isc_1078), (char*) isc_1078);
			if (tdgbl->handles_get_character_sets_req_handle1)
			   {
			   isc_1079.isc_1081 = isc_blob_null;
				/*X.RDB$CHARACTER_SET_NAME.NULL*/
				isc_1079.isc_1097 = TRUE;
				/*X.RDB$FORM_OF_USE.NULL*/
				isc_1079.isc_1096 = TRUE;
				/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
				isc_1079.isc_1095 = TRUE;
				/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
				isc_1079.isc_1094 = TRUE;
				/*X.RDB$CHARACTER_SET_ID.NULL*/
				isc_1079.isc_1092 = TRUE;
				/*X.RDB$SYSTEM_FLAG*/
				isc_1079.isc_1091 = 0;
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_1079.isc_1090 = FALSE;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_1079.isc_1089 = TRUE;
				/*X.RDB$FUNCTION_NAME.NULL*/
				isc_1079.isc_1088 = TRUE;
				/*X.RDB$BYTES_PER_CHARACTER.NULL*/
				isc_1079.isc_1086 = TRUE;

				skip_init(&scan_next_attr);
				while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
				{
					switch (attribute)
					{
					case att_charset_name:
						/*X.RDB$CHARACTER_SET_NAME.NULL*/
						isc_1079.isc_1097 = FALSE;
						GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
							 isc_1079.isc_1084);
						BURP_verbose (msgVerbose_restore_charset, /*X.RDB$CHARACTER_SET_NAME*/
											  isc_1079.isc_1084);
						break;

					case att_charset_form:
						/*X.RDB$FORM_OF_USE.NULL*/
						isc_1079.isc_1096 = FALSE;
						GET_TEXT(/*X.RDB$FORM_OF_USE*/
							 isc_1079.isc_1083);
						break;

					case att_charset_numchar:
						/*X.RDB$NUMBER_OF_CHARACTERS.NULL*/
						isc_1079.isc_1095 = FALSE;
						/*X.RDB$NUMBER_OF_CHARACTERS*/
						isc_1079.isc_1085 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_coll:
						/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
						isc_1079.isc_1094 = FALSE;
						GET_TEXT(/*X.RDB$DEFAULT_COLLATE_NAME*/
							 isc_1079.isc_1082);
						break;

					case att_charset_id:
						/*X.RDB$CHARACTER_SET_ID.NULL*/
						isc_1079.isc_1092 = FALSE;
						/*X.RDB$CHARACTER_SET_ID*/
						isc_1079.isc_1093 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_sysflag:
						/*X.RDB$SYSTEM_FLAG.NULL*/
						isc_1079.isc_1090 = FALSE;
						/*X.RDB$SYSTEM_FLAG*/
						isc_1079.isc_1091 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_description:
						/*X.RDB$DESCRIPTION.NULL*/
						isc_1079.isc_1089 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_1079.isc_1081, false);
						break;

					case att_charset_funct:
						/*X.RDB$FUNCTION_NAME.NULL*/
						isc_1079.isc_1088 = FALSE;
						GET_TEXT(/*X.RDB$FUNCTION_NAME*/
							 isc_1079.isc_1080);
						break;

					case att_charset_bytes_char:
						/*X.RDB$BYTES_PER_CHARACTER.NULL*/
						isc_1079.isc_1086 = FALSE;
						/*X.RDB$BYTES_PER_CHARACTER*/
						isc_1079.isc_1087 = (USHORT) get_int32(tdgbl);
						break;

					case att_charset_security_class:
					case att_charset_owner_name:
						if (tdgbl->RESTORE_format >= 10)
							eat_text(tdgbl);
						else
							bad_attribute(scan_next_attr, attribute, msgErr_restore_charset);
						break;

					default:
						bad_attribute(scan_next_attr, attribute, msgErr_restore_charset);
						// 213 character set
						break;
					}
				}

				if (/*X.RDB$CHARACTER_SET_ID.NULL*/
				    isc_1079.isc_1092 && !/*X.RDB$DEFAULT_COLLATE_NAME.NULL*/
     isc_1079.isc_1094 &&
					!/*X.RDB$CHARACTER_SET_NAME.NULL*/
					 isc_1079.isc_1097)
				{
					tdgbl->defaultCollations.add(
						Firebird::Pair<Firebird::NonPooled<Firebird::MetaName, Firebird::MetaName> >(
							/*X.RDB$CHARACTER_SET_NAME*/
							isc_1079.isc_1084, /*X.RDB$DEFAULT_COLLATE_NAME*/
  isc_1079.isc_1082));
					throw AbortException();	// prevent the STORE
				}

			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_character_sets_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 164, &isc_1079, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}
	catch (const AbortException&)
	{
	}

	return true;
}

bool get_chk_constraint(BurpGlobals* tdgbl)
{
   struct isc_1073_struct {
          char  isc_1074 [32];	/* RDB$TRIGGER_NAME */
          char  isc_1075 [32];	/* RDB$CONSTRAINT_NAME */
          short isc_1076;	/* gds__null_flag */
          short isc_1077;	/* gds__null_flag */
   } isc_1073;
/**************************************
 *
 *	g e t _ c h k _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for check constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_chk_constraint_req_handle1)
		X IN RDB$CHECK_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_chk_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (short) sizeof(isc_1072), (char*) isc_1072);
	if (tdgbl->handles_get_chk_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_1073.isc_1077 = TRUE;
		/*X.RDB$TRIGGER_NAME.NULL*/
		isc_1073.isc_1076 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_chk_constraint_name:
				/*X.RDB$CONSTRAINT_NAME.NULL*/
				isc_1073.isc_1077 = FALSE;
				GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
					 isc_1073.isc_1075);
				break;

			case att_chk_trigger_name:
				/*X.RDB$TRIGGER_NAME.NULL*/
				isc_1073.isc_1076 = FALSE;
				GET_TEXT(/*X.RDB$TRIGGER_NAME*/
					 isc_1073.isc_1074);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 286);
				// msg 286 check constraint
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_chk_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_1073, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_collation(BurpGlobals* tdgbl)
{
   struct isc_1009_struct {
          ISC_QUAD isc_1010;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_1011 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_1012 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_1013;	/* RDB$DESCRIPTION */
          char  isc_1014 [32];	/* RDB$COLLATION_NAME */
          short isc_1015;	/* gds__null_flag */
          short isc_1016;	/* gds__null_flag */
          short isc_1017;	/* gds__null_flag */
          short isc_1018;	/* gds__null_flag */
          short isc_1019;	/* gds__null_flag */
          short isc_1020;	/* RDB$SYSTEM_FLAG */
          short isc_1021;	/* gds__null_flag */
          short isc_1022;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_1023;	/* gds__null_flag */
          short isc_1024;	/* RDB$CHARACTER_SET_ID */
          short isc_1025;	/* gds__null_flag */
          short isc_1026;	/* RDB$COLLATION_ID */
          short isc_1027;	/* gds__null_flag */
   } isc_1009;
   struct isc_1029_struct {
          ISC_QUAD isc_1030;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_1031 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_1032 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_1033;	/* RDB$DESCRIPTION */
          char  isc_1034 [32];	/* RDB$COLLATION_NAME */
          short isc_1035;	/* gds__null_flag */
          short isc_1036;	/* gds__null_flag */
          short isc_1037;	/* gds__null_flag */
          short isc_1038;	/* gds__null_flag */
          short isc_1039;	/* gds__null_flag */
          short isc_1040;	/* RDB$SYSTEM_FLAG */
          short isc_1041;	/* gds__null_flag */
          short isc_1042;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_1043;	/* gds__null_flag */
          short isc_1044;	/* RDB$CHARACTER_SET_ID */
          short isc_1045;	/* gds__null_flag */
          short isc_1046;	/* RDB$COLLATION_ID */
          short isc_1047;	/* gds__null_flag */
   } isc_1029;
   struct isc_1049_struct {
          char  isc_1050 [32];	/* RDB$OWNER_NAME */
          char  isc_1051 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_1052;	/* RDB$SPECIFIC_ATTRIBUTES */
          char  isc_1053 [32];	/* RDB$BASE_COLLATION_NAME */
          char  isc_1054 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_1055;	/* RDB$DESCRIPTION */
          char  isc_1056 [32];	/* RDB$COLLATION_NAME */
          short isc_1057;	/* gds__null_flag */
          short isc_1058;	/* gds__null_flag */
          short isc_1059;	/* gds__null_flag */
          short isc_1060;	/* gds__null_flag */
          short isc_1061;	/* gds__null_flag */
          short isc_1062;	/* gds__null_flag */
          short isc_1063;	/* gds__null_flag */
          short isc_1064;	/* RDB$SYSTEM_FLAG */
          short isc_1065;	/* gds__null_flag */
          short isc_1066;	/* RDB$COLLATION_ATTRIBUTES */
          short isc_1067;	/* gds__null_flag */
          short isc_1068;	/* RDB$CHARACTER_SET_ID */
          short isc_1069;	/* gds__null_flag */
          short isc_1070;	/* RDB$COLLATION_ID */
          short isc_1071;	/* gds__null_flag */
   } isc_1049;
/**************************************
 *
 *	g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Restore data for user defined collations
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		GDS_NAME coll_name;
		bool securityClass = false;

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_1048), (char*) isc_1048);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_1049.isc_1052 = isc_blob_null;
		   isc_1049.isc_1055 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_1049.isc_1071 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_1049.isc_1069 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_1049.isc_1067 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_1049.isc_1065 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_1049.isc_1064 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_1049.isc_1063 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_1049.isc_1062 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_1049.isc_1061 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_1049.isc_1060 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_1049.isc_1059 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_1049.isc_1058 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_1049.isc_1057 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_1049.isc_1071 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_1049.isc_1056);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_1049.isc_1056);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_1049.isc_1069 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_1049.isc_1070 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_1049.isc_1067 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_1049.isc_1068 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_1049.isc_1065 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_1049.isc_1066 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_int32(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_1049.isc_1063 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_1049.isc_1064 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_1049.isc_1062 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_1049.isc_1055, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_1049.isc_1061 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_1049.isc_1054);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$BASE_COLLATION_NAME.NULL*/
						isc_1049.isc_1060 = FALSE;
						GET_TEXT(/*X.RDB$BASE_COLLATION_NAME*/
							 isc_1049.isc_1053);
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
						isc_1049.isc_1059 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$SPECIFIC_ATTRIBUTES*/
									isc_1049.isc_1052, false);
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_security_class:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$SECURITY_CLASS*/
							 isc_1049.isc_1051);
						/*X.RDB$SECURITY_CLASS.NULL*/
						isc_1049.isc_1058 = FALSE;
						securityClass = true;
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_owner_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$OWNER_NAME*/
							 isc_1049.isc_1050);
						/*X.RDB$OWNER_NAME.NULL*/
						isc_1049.isc_1057 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}

			strcpy(coll_name, /*X.RDB$COLLATION_NAME*/
					  isc_1049.isc_1056);

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 206, &isc_1049, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (!securityClass)
			collect_missing_privs(tdgbl, obj_collation, coll_name);
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL11)
	{
		// This includes DDL11_0 that doesn't know to ignore unknown system fields.
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_1028), (char*) isc_1028);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_1029.isc_1030 = isc_blob_null;
		   isc_1029.isc_1033 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_1029.isc_1047 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_1029.isc_1045 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_1029.isc_1043 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_1029.isc_1041 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_1029.isc_1040 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_1029.isc_1039 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_1029.isc_1038 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_1029.isc_1037 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_1029.isc_1036 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_1029.isc_1035 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_1029.isc_1047 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_1029.isc_1034);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_1029.isc_1034);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_1029.isc_1045 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_1029.isc_1046 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_1029.isc_1043 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_1029.isc_1044 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_1029.isc_1041 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_1029.isc_1042 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_int32(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_1029.isc_1039 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_1029.isc_1040 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_1029.isc_1038 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_1029.isc_1033, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_1029.isc_1037 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_1029.isc_1032);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$BASE_COLLATION_NAME.NULL*/
						isc_1029.isc_1036 = FALSE;
						GET_TEXT(/*X.RDB$BASE_COLLATION_NAME*/
							 isc_1029.isc_1031);
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
					{
						/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
						isc_1029.isc_1035 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$SPECIFIC_ATTRIBUTES*/
									isc_1029.isc_1030, false);
					}
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_security_class:
				case att_coll_owner_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_1029, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_collation_req_handle1)
			X IN RDB$COLLATIONS*/
		{
		
                if (!tdgbl->handles_get_collation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (short) sizeof(isc_1008), (char*) isc_1008);
		if (tdgbl->handles_get_collation_req_handle1)
		   {
		   isc_1009.isc_1010 = isc_blob_null;
		   isc_1009.isc_1013 = isc_blob_null;
			/*X.RDB$COLLATION_NAME.NULL*/
			isc_1009.isc_1027 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_1009.isc_1025 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_1009.isc_1023 = TRUE;
			/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
			isc_1009.isc_1021 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_1009.isc_1020 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_1009.isc_1019 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_1009.isc_1018 = TRUE;
			/*X.RDB$FUNCTION_NAME.NULL*/
			isc_1009.isc_1017 = TRUE;
			/*X.RDB$BASE_COLLATION_NAME.NULL*/
			isc_1009.isc_1016 = TRUE;
			/*X.RDB$SPECIFIC_ATTRIBUTES.NULL*/
			isc_1009.isc_1015 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{

				case att_coll_name:
					/*X.RDB$COLLATION_NAME.NULL*/
					isc_1009.isc_1027 = FALSE;
					GET_TEXT(/*X.RDB$COLLATION_NAME*/
						 isc_1009.isc_1014);
					BURP_verbose(msgVerbose_restore_collation, /*X.RDB$COLLATION_NAME*/
										   isc_1009.isc_1014);
					break;

				case att_coll_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_1009.isc_1025 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_1009.isc_1026 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_cs_id:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_1009.isc_1023 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_1009.isc_1024 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_attr:
					/*X.RDB$COLLATION_ATTRIBUTES.NULL*/
					isc_1009.isc_1021 = FALSE;
					/*X.RDB$COLLATION_ATTRIBUTES*/
					isc_1009.isc_1022 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_subtype:	// No longer used: 93-11-15 DBS
					// still present to handle V4 R&D gbak files
					get_int32(tdgbl);
					break;

				case att_coll_sysflag:
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_1009.isc_1019 = FALSE;
					/*X.RDB$SYSTEM_FLAG*/
					isc_1009.isc_1020 = (USHORT) get_int32(tdgbl);
					break;

				case att_coll_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_1009.isc_1018 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_1009.isc_1013, false);
					break;

				case att_coll_funct:
					/*X.RDB$FUNCTION_NAME.NULL*/
					isc_1009.isc_1017 = FALSE;
					GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						 isc_1009.isc_1012);
					break;

				case att_coll_base_collation_name:
					if (tdgbl->RESTORE_format >= 7)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_specific_attr:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				case att_coll_security_class:
				case att_coll_owner_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, msgErr_restore_collation);
					// Msg 215 collation
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_collation_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 138, &isc_1009, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

rec_type get_data(BurpGlobals* tdgbl, burp_rel* relation, bool skip_relation)
{
   struct isc_1006_struct {
          short isc_1007;	/* isc_utility */
   } isc_1006;
   struct isc_1004_struct {
          short isc_1005;	/* RDB$INDEX_INACTIVE */
   } isc_1004;
   struct isc_1001_struct {
          short isc_1002;	/* isc_utility */
          short isc_1003;	/* RDB$INDEX_INACTIVE */
   } isc_1001;
   struct isc_999_struct {
          char  isc_1000 [32];	/* RDB$INDEX_NAME */
   } isc_999;
/**************************************
 *
 *	g e t _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Write data records for a relation.
 *
 **************************************/
	isc_req_handle  req_handle = 0;
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];


	// If we're only doing meta-data, ignore data records

	if (tdgbl->gbl_sw_meta || skip_relation)
		return ignore_data(tdgbl, relation);

	// Start by counting the interesting fields

	RCRD_OFFSET offset = 0;
	ULONG length = 0;
	USHORT count = 0;

	burp_fld* field;
	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (!(field->fld_flags & FLD_computed))
		{
			count++;
			length += field->fld_name_length;
		}
	}

	if (tdgbl->RESTORE_format >= 2)
		count += count;

	// Time to generate blr to store data.  Whoppee.

	UCHAR* const blr_buffer = (UCHAR*) BURP_alloc (200 + length + count * 18);
	UCHAR* blr = blr_buffer;

	add_byte(blr, blr_version4);
	add_byte(blr, blr_begin);
	add_byte(blr, blr_message);
	add_byte(blr, 0);				// Message number
	add_word(blr, count);	// Number of fields, counting eof

	// Let's reset count.
	count = 0;

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		// arrays are of various fld_types but are really blobs

		SSHORT dtype = field->fld_type;
		length = field->fld_length;
		SSHORT alignment = 4;

		if (field->fld_flags & FLD_array)
			dtype = blr_blob;

		if (dtype <= DTYPE_BLR_MAX)
		{
			USHORT l = gds_cvt_blr_dtype[dtype];
			alignment = type_alignments[l];
			if (l = type_lengths[l])
				length = l;
		}

		switch (dtype)
		{
		case blr_text:
		case blr_varying:
			if (dtype == blr_text)
				add_byte(blr, blr_text2);
			else
				add_byte(blr, blr_varying2);

			if (tdgbl->gbl_sw_fix_fss_data && field->fld_character_set_id == CS_UNICODE_FSS)
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			else
				add_word(blr, field->fld_character_set_id);

			add_word(blr, field->fld_length);
			if (dtype == blr_varying)
				length += sizeof(USHORT);
			break;

		case blr_short:
		case blr_long:
		case blr_quad:
		case blr_int64:
			add_byte(blr, field->fld_type);
			add_byte(blr, field->fld_scale);
			break;

		case blr_float:
		case blr_double:
		case blr_timestamp:
		case blr_sql_time:
		case blr_sql_date:
			add_byte(blr, field->fld_type);
			break;

		case blr_blob:
			alignment = type_alignments[dtype_blob];
			length = type_lengths[dtype_blob];

			if (tdgbl->gbl_sw_fix_fss_data && !(field->fld_flags & FLD_array) &&
				field->fld_sub_type == isc_blob_text && field->fld_character_set_id == CS_UNICODE_FSS)
			{
				add_byte(blr, blr_blob2);
				add_word(blr, field->fld_sub_type);
				add_word(blr, tdgbl->gbl_sw_fix_fss_data_id);
			}
			else
			{
				add_byte(blr, blr_quad);
				add_byte(blr, 0);
			}

			break;

		case blr_bool:
			add_byte(blr, field->fld_type);
			break;

		default:
			BURP_error(26, true, SafeArg() << field->fld_type);
			// msg 26 datatype %ld not understood
			break;
		}
		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_offset = offset;
		field->fld_parameter = count++;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			add_byte(blr, blr_short);
			add_byte(blr, 0);
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			field->fld_missing_parameter = count++;
			offset += sizeof(SSHORT);
		}

	length = offset;

	// Build STORE statement

	add_byte(blr, blr_loop);
	add_byte(blr, blr_receive);
	add_byte(blr, 0);
	add_byte(blr, blr_store);
	add_byte(blr, blr_relation);
	add_string(blr, relation->rel_name);
	add_byte(blr, 0);			// context variable
	add_byte(blr, blr_begin);

	for (field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		add_byte(blr, blr_assignment);
		if (tdgbl->RESTORE_format >= 2)
		{
			add_byte(blr, blr_parameter2);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
			add_word(blr, field->fld_missing_parameter);
		}
		else
		{
			add_byte(blr, blr_parameter);
			add_byte(blr, 0);
			add_word(blr, field->fld_parameter);
		}
		add_byte(blr, blr_field);
		add_byte(blr, 0);
		add_string(blr, field->fld_name);
	}

	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	// Compile request

	USHORT blr_length = blr - blr_buffer;

#ifdef DEBUG
	fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
#endif

	FB_API_HANDLE request = 0;
	ISC_STATUS_ARRAY status_vector;

	if (isc_compile_request (status_vector, &DB, &request,
							 blr_length, reinterpret_cast<const char*>(blr_buffer)))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		if (!tdgbl->gbl_sw_incremental)
			BURP_error_redirect (status_vector, 27); // msg 27 isc_compile_request failed
		else
		{
			BURP_print_status (false, status_vector);
			BURP_free (blr_buffer);
			return ignore_data(tdgbl, relation);
		}
	}

	BURP_free (blr_buffer);
	SSHORT* buffer = NULL;

	BURP_verbose (124, relation->rel_name); // msg 124  restoring data for relation %s

	lstring data;
	data.lstr_allocated = 0;
	data.lstr_address = NULL;
	ULONG old_length = 0;

	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39); // msg 39 expected record length
		USHORT len = (USHORT) get_int32(tdgbl);
		if (!tdgbl->gbl_sw_transportable && len != length)
		{
#ifdef sparc
			if (!old_length)
				old_length = recompute_length(tdgbl, relation);
#endif
			if (len != old_length)
			{
				BURP_error(40, true, SafeArg() << length << len);
				// msg 40 wrong length record, expected %ld encountered %ld
			}
		}
		if (!buffer) {
			buffer = (SSHORT *) BURP_alloc (MAX (length, len));
		}

		UCHAR* p;
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
			{
				data.lstr_length = len = (USHORT) get_int32(tdgbl);
				if (len > data.lstr_allocated)
				{
					data.lstr_allocated = len;
					if (data.lstr_address)
						BURP_free (data.lstr_address);
					data.lstr_address = BURP_alloc(data.lstr_allocated);
				}
				p = data.lstr_address;
			}
		}
		else
			p = reinterpret_cast<UCHAR*>(buffer);
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41); // msg 41 expected data attribute

		if (tdgbl->gbl_sw_compress)
			decompress (tdgbl, p, len);
		else
		{
			get_block(tdgbl, p, len);
		}

		if (old_length)
			realign (tdgbl, (UCHAR*) buffer, relation);

		if (tdgbl->gbl_sw_transportable)
			CAN_encode_decode (relation, &data, (UCHAR *)buffer, FALSE);

		records++;

		if ((records % tdgbl->verboseInterval) == 0)
			BURP_verbose(107, SafeArg() << records);

		for (field = relation->rel_fields; field; field = field->fld_next)
		{
			if (!(field->fld_flags & FLD_computed))
			{
				if (field->fld_type == blr_blob || (field->fld_flags & FLD_array))
				{
					ISC_QUAD* blob_id = (ISC_QUAD*) ((SCHAR*) buffer + field->fld_offset);
					blob_id->gds_quad_high = 0;
					blob_id->gds_quad_low = 0;
				}
			}
		}

		get_record(&record, tdgbl);
		while (record == rec_blob || record == rec_array)
		{
			if (record == rec_blob)
				get_blob (tdgbl, relation->rel_fields, (UCHAR *) buffer);
			else if (record == rec_array)
				get_array (tdgbl, relation, (UCHAR *) buffer);
			get_record(&record, tdgbl);
		}

		ISC_STATUS s;

		// ASF: Preferable we should call isc_start_and_send only when records == 1, but this leaks
		// memory when there are blobs and arrays fields - CORE-3802.
		if (records % 1000 == 1)
			s = isc_start_and_send(status_vector, &request, &gds_trans, 0, (USHORT) length, buffer, 0);
		else
			s = isc_send(status_vector, &request, 0, (USHORT) length, buffer, 0);

		if (s)
		{
			if (status_vector[1] == isc_not_valid)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 138, relation->rel_name);
					// msg 138 validation error on field in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 47);
					// msg 47 warning -- record could not be restored
			}
			else if (status_vector[1] == isc_malformed_string)
			{
				if (tdgbl->gbl_sw_incremental)
				{
					// msg 114 restore failed for record in relation %s
					BURP_print(false, 114, relation->rel_name);

					BURP_print_status(false, status_vector);
					BURP_print(false, 342);	// isc_gbak_invalid_data
				}
				else
					BURP_error_redirect(status_vector, 342);	// isc_gbak_invalid_data
			}
			else
			{
				if (tdgbl->gbl_sw_incremental)
				{
					BURP_print (false, 114, relation->rel_name);
					// msg 114 restore failed for record in relation %s
					BURP_print_status (false, status_vector);
				}
				else
					BURP_error_redirect (status_vector, 48);
					// msg 48 isc_send failed
			}
		}
		if (record != rec_data)
			break;
	} // while (true)

	BURP_free (buffer);
	if (data.lstr_address)
		BURP_free (data.lstr_address);

	isc_release_request(status_vector, &request);
	if (tdgbl->gbl_sw_incremental)
	{
		BURP_verbose (72, relation->rel_name);
		// msg 72  committing data for relation %s
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {

			// Fix for bug_no 8055:
			// don't throw away the database just because an index
			// could not be made
			ISC_STATUS error_code;
			while (error_code = tdgbl->status_vector[1])
			{
				switch (error_code)
				{
					case isc_sort_mem_err:
					case isc_no_dup:
						strcpy(index_name, (TEXT *)tdgbl->status_vector[3]);
						BURP_print_status(false, tdgbl->status_vector);
						/*FOR (REQUEST_HANDLE req_handle)
						 IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ index_name*/
						{
                                                if (!req_handle)
                                                   isc_compile_request (NULL, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle, (short) sizeof(isc_998), (char*) isc_998);
						isc_vtov ((const char*) index_name, (char*) isc_999.isc_1000, 32);
                                                isc_start_and_send (NULL, (FB_API_HANDLE*) &req_handle, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_999, (short) 0);
						while (1)
						   {
                                                   isc_receive (NULL, (FB_API_HANDLE*) &req_handle, (short) 1, (short) 4, &isc_1001, (short) 0);
						   if (!isc_1001.isc_1002) break;
							/*MODIFY IDX USING*/
							{
								/*IDX.RDB$INDEX_INACTIVE*/
								isc_1001.isc_1003 = TRUE;
								BURP_print(false, 240, index_name);
								// msg 240 Index \"%s\" failed to activate because:
								if ( error_code == isc_no_dup )
								{
									BURP_print(false, 241);
									// msg 241 The unique index has duplicate values or NULLs
									BURP_print(false, 242);
									// msg 242 Delete or Update duplicate values or NULLs, and activate index with
								}
								else
								{
									BURP_print(false, 244);
									// msg 244 Not enough disk space to create the sort file for an index
									BURP_print(false, 245);
									// msg 245 Set the TMP environment variable to a directory on a filesystem that does have enough space, and activate index with
								}
								BURP_print(false, 243, index_name);
								// msg 243 ALTER INDEX \"%s\" ACTIVE
							/*END_MODIFY;*/
							isc_1004.isc_1005 = isc_1001.isc_1003;
                                                        isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 2, (short) 2, &isc_1004, (short) 0);
							}
						/*END_FOR;*/
                                                   isc_send (NULL, (FB_API_HANDLE*) &req_handle, (short) 3, (short) 2, &isc_1006, (short) 0);
						   }
						}
						// don't bring the database on-line
						tdgbl->flag_on_line = false;
						// commit one more time
						/*COMMIT*/
						{
						isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							continue;
						/*END_ERROR*/
						   }
						}
						break;
					default:
						BURP_print (false, 69, relation->rel_name);
						// msg 69 commit failed on relation %s
						BURP_print_status (false, tdgbl->status_vector);
						/*ROLLBACK;*/
						{
						isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							general_on_error ();
						/*END_ERROR;*/
						   }
						}
						break;
				} // end of switch
			} // end of while
		/*END_ERROR;*/
		   }
		}

		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_9);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_10);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}
	BURP_verbose (107, SafeArg() << records);
	// msg 107 %ld records restored

	return record;
}

// We have a corrupt backup, save the restore process from becoming useless.
void fix_exception(BurpGlobals* tdgbl, const char* exc_name, scan_attr_t& scan_next_attr,
	const att_type attribute, att_type& failed_attrib, UCHAR*& msg_ptr, ULONG& l2, bool& msg_seen)
{
	if (msg_seen && (tdgbl->RESTORE_format == 7 || tdgbl->RESTORE_format == 8))
	{
		if (!failed_attrib)
		{
			failed_attrib = attribute;
			BURP_print(false, 313, SafeArg() << failed_attrib << exc_name);
		}

		// Notice we use 1021 instead of 1023 because this is the maximum length
		// for this field in v2.0 and v2.1 and they produce the corrupt backups.
		const unsigned int FIELD_LIMIT = 1021;

		if (FIELD_LIMIT < l2 + 1) // not enough space
		{
			bad_attribute(scan_next_attr, failed_attrib, 287);
			return;
		}
		const unsigned int remaining = FIELD_LIMIT - l2;

		*msg_ptr++ = char(attribute); // (1)

		UCHAR* rc_ptr = get_block(tdgbl, msg_ptr, MIN(remaining - 1, 255));
		if (remaining > 1 && rc_ptr == msg_ptr) // we couldn't read anything
		{
			bad_attribute(scan_next_attr, failed_attrib, 287);
			return;
		}

		l2 += rc_ptr - msg_ptr + 1; // + 1 because (1)
		msg_ptr = rc_ptr;
		*msg_ptr = 0;

		if (l2 == FIELD_LIMIT)
			msg_seen = false;
	}
	else
		bad_attribute(scan_next_attr, attribute, 287); // msg 287 exception
}

bool get_exception(BurpGlobals* tdgbl)
{
   struct isc_975_struct {
          char  isc_976 [1024];	/* RDB$MESSAGE */
          ISC_QUAD isc_977;	/* RDB$DESCRIPTION */
          char  isc_978 [32];	/* RDB$EXCEPTION_NAME */
          short isc_979;	/* gds__null_flag */
          short isc_980;	/* RDB$SYSTEM_FLAG */
          short isc_981;	/* gds__null_flag */
          short isc_982;	/* gds__null_flag */
          short isc_983;	/* gds__null_flag */
   } isc_975;
   struct isc_985_struct {
          char  isc_986 [32];	/* RDB$OWNER_NAME */
          char  isc_987 [32];	/* RDB$SECURITY_CLASS */
          char  isc_988 [1024];	/* RDB$MESSAGE */
          ISC_QUAD isc_989;	/* RDB$DESCRIPTION */
          char  isc_990 [32];	/* RDB$EXCEPTION_NAME */
          short isc_991;	/* gds__null_flag */
          short isc_992;	/* gds__null_flag */
          short isc_993;	/* gds__null_flag */
          short isc_994;	/* RDB$SYSTEM_FLAG */
          short isc_995;	/* gds__null_flag */
          short isc_996;	/* gds__null_flag */
          short isc_997;	/* gds__null_flag */
   } isc_985;
/**************************************
 *
 *	g e t _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a exception.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	ULONG		l2 = 0;
	scan_attr_t		scan_next_attr;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		GDS_NAME exception_name;
		bool securityClass = false;

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_exception_req_handle1)
			X IN RDB$EXCEPTIONS*/
		{
		
                if (!tdgbl->handles_get_exception_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (short) sizeof(isc_984), (char*) isc_984);
		if (tdgbl->handles_get_exception_req_handle1)
		   {
		   isc_985.isc_989 = isc_blob_null;
			/*X.RDB$EXCEPTION_NAME.NULL*/
			isc_985.isc_997 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_985.isc_996 = TRUE;
			/*X.RDB$MESSAGE.NULL*/
			isc_985.isc_995 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_985.isc_994 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_985.isc_993 = FALSE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_985.isc_992 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_985.isc_991 = TRUE;

			att_type failed_attrib = att_end;
			bool msg_seen = false; // only for att_exception_msg, not att_exception_msg2
			UCHAR* msg_ptr = reinterpret_cast<UCHAR*>(/*X.RDB$MESSAGE*/
								  isc_985.isc_988);

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_exception_name:
					if (!/*X.RDB$EXCEPTION_NAME.NULL*/
					     isc_985.isc_997)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					else
					{
						const ULONG l = GET_TEXT(/*X.RDB$EXCEPTION_NAME*/
									 isc_985.isc_990);
						/*X.RDB$EXCEPTION_NAME.NULL*/
						isc_985.isc_997 = FALSE;
						MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
								isc_985.isc_990, temp, l, sizeof(temp));
						BURP_verbose (199, temp);
						// msg 199 restoring exception %s
					}
					break;

				case att_exception_description:
					if (!/*X.RDB$DESCRIPTION.NULL*/
					     isc_985.isc_996)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					else
					{
						msg_seen = false;
						get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								      isc_985.isc_989, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_985.isc_996 = FALSE;
					}
					break;

				case att_exception_description2:
					if (!/*X.RDB$DESCRIPTION.NULL*/
					     isc_985.isc_996)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					else
					{
						msg_seen = false;
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_985.isc_989, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_985.isc_996 = FALSE;
					}
					break;

				case att_exception_msg:
					if (msg_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					else if (!/*X.RDB$MESSAGE.NULL*/
						  isc_985.isc_995)
					{
						msg_seen = true;
						BURP_print(false, 312, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												 isc_985.isc_990);
						eat_text(tdgbl);
					}
					else
					{
						msg_seen = true;
						l2 = GET_TEXT(/*X.RDB$MESSAGE*/
							      isc_985.isc_988);
						msg_ptr += l2;
						/*X.RDB$MESSAGE.NULL*/
						isc_985.isc_995 = FALSE;
					}
					break;

				case att_exception_msg2:
					if (msg_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					else if (!/*X.RDB$MESSAGE.NULL*/
						  isc_985.isc_995)
					{
						BURP_print(false, 312, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												 isc_985.isc_990);
						eat_text2(tdgbl);
					}
					else
					{
						GET_TEXT2(/*X.RDB$MESSAGE*/
							  isc_985.isc_988);
						/*X.RDB$MESSAGE.NULL*/
						isc_985.isc_995 = FALSE;
					}
					break;

				case att_exception_security_class:
					if (!/*X.RDB$SECURITY_CLASS.NULL*/
					     isc_985.isc_992)
					{
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					}
					else
					{
						msg_seen = false;
						if (tdgbl->RESTORE_format >= 10)
						{
							GET_TEXT(/*X.RDB$SECURITY_CLASS*/
								 isc_985.isc_987);
							/*X.RDB$SECURITY_CLASS.NULL*/
							isc_985.isc_992 = FALSE;
							securityClass = true;
						}
						else
						{
							fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
									     isc_985.isc_990, scan_next_attr, attribute,
								failed_attrib, msg_ptr, l2, msg_seen);
						}
					}
					break;

				case att_exception_owner_name:
					if (!/*X.RDB$OWNER_NAME.NULL*/
					     isc_985.isc_991)
					{
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_985.isc_990);
					}
					else
					{
						msg_seen = false;
						if (tdgbl->RESTORE_format >= 10)
						{
							GET_TEXT(/*X.RDB$OWNER_NAME*/
								 isc_985.isc_986);
							/*X.RDB$OWNER_NAME.NULL*/
							isc_985.isc_991 = FALSE;
						}
						else
						{
							fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
									     isc_985.isc_990, scan_next_attr, attribute,
								failed_attrib, msg_ptr, l2, msg_seen);
						}
					}
					break;

				default:
					// do we have a corrupt backup?
					fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
							     isc_985.isc_990, scan_next_attr, attribute,
						failed_attrib, msg_ptr, l2, msg_seen);
					break;
				}
			}

			strcpy(exception_name, /*X.RDB$EXCEPTION_NAME*/
					       isc_985.isc_990);

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 1142, &isc_985, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (!securityClass)
			collect_missing_privs(tdgbl, obj_exception, exception_name);
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_exception_req_handle1)
			X IN RDB$EXCEPTIONS*/
		{
		
                if (!tdgbl->handles_get_exception_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (short) sizeof(isc_974), (char*) isc_974);
		if (tdgbl->handles_get_exception_req_handle1)
		   {
		   isc_975.isc_977 = isc_blob_null;
			/*X.RDB$EXCEPTION_NAME.NULL*/
			isc_975.isc_983 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_975.isc_982 = TRUE;
			/*X.RDB$MESSAGE.NULL*/
			isc_975.isc_981 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_975.isc_980 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_975.isc_979 = FALSE;

			bool secclass_seen = false;
			bool ownername_seen = false;

			att_type failed_attrib = att_end;
			bool msg_seen = false; // only for att_exception_msg, not att_exception_msg2
			UCHAR* msg_ptr = reinterpret_cast<UCHAR*>(/*X.RDB$MESSAGE*/
								  isc_975.isc_976);

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_exception_name:
					if (!/*X.RDB$EXCEPTION_NAME.NULL*/
					     isc_975.isc_983)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else
					{
						const ULONG l = GET_TEXT(/*X.RDB$EXCEPTION_NAME*/
									 isc_975.isc_978);
						/*X.RDB$EXCEPTION_NAME.NULL*/
						isc_975.isc_983 = FALSE;
						MISC_terminate (/*X.RDB$EXCEPTION_NAME*/
								isc_975.isc_978, temp, l, sizeof(temp));
						BURP_verbose (199, temp);
						// msg 199 restoring exception %s
					}
					break;

				case att_exception_description:
					if (!/*X.RDB$DESCRIPTION.NULL*/
					     isc_975.isc_982)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else
					{
						msg_seen = false;
						get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								      isc_975.isc_977, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_975.isc_982 = FALSE;
					}
					break;

				case att_exception_description2:
					if (!/*X.RDB$DESCRIPTION.NULL*/
					     isc_975.isc_982)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else
					{
						msg_seen = false;
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_975.isc_977, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_975.isc_982 = FALSE;
					}
					break;

				case att_exception_msg:
					if (msg_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else if (!/*X.RDB$MESSAGE.NULL*/
						  isc_975.isc_981)
					{
						msg_seen = true;
						BURP_print(false, 312, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												 isc_975.isc_978);
						eat_text(tdgbl);
					}
					else
					{
						msg_seen = true;
						l2 = GET_TEXT(/*X.RDB$MESSAGE*/
							      isc_975.isc_976);
						msg_ptr += l2;
						/*X.RDB$MESSAGE.NULL*/
						isc_975.isc_981 = FALSE;
					}
					break;

				case att_exception_msg2:
					if (msg_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else if (!/*X.RDB$MESSAGE.NULL*/
						  isc_975.isc_981)
					{
						BURP_print(false, 312, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												 isc_975.isc_978);
						eat_text2(tdgbl);
					}
					else
					{
						GET_TEXT2(/*X.RDB$MESSAGE*/
							  isc_975.isc_976);
						/*X.RDB$MESSAGE.NULL*/
						isc_975.isc_981 = FALSE;
					}
					break;

				case att_exception_security_class:
					if (secclass_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else
					{
						msg_seen = false;
						if (tdgbl->RESTORE_format >= 10)
						{
							eat_text(tdgbl);
							secclass_seen = true;
						}
						else
						{
							fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
									     isc_975.isc_978, scan_next_attr, attribute,
								failed_attrib, msg_ptr, l2, msg_seen);
						}
					}
					break;

				case att_exception_owner_name:
					if (ownername_seen)
						BURP_error(311, true, SafeArg() << attribute << /*X.RDB$EXCEPTION_NAME*/
												isc_975.isc_978);
					else
					{
						msg_seen = false;
						if (tdgbl->RESTORE_format >= 10)
						{
							eat_text(tdgbl);
							ownername_seen = true;
						}
						else
						{
							fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
									     isc_975.isc_978, scan_next_attr, attribute,
								failed_attrib, msg_ptr, l2, msg_seen);
						}
					}
					break;

				default:
					// do we have a corrupt backup?
					fix_exception(tdgbl, /*X.RDB$EXCEPTION_NAME*/
							     isc_975.isc_978, scan_next_attr, attribute,
						failed_attrib, msg_ptr, l2, msg_seen);
					break;
				}
			}
			// Versions prior to FB2.0 don't support a field longer than varchar(78).
			// Versions prior to FB2.5 use a field length of 1021, not 1023.
			if (tdgbl->runtimeODS < DB_VERSION_DDL11)
				/*X.RDB$MESSAGE*/
				isc_975.isc_976[78] = 0;
			else if (tdgbl->runtimeODS < DB_VERSION_DDL11_2)
				/*X.RDB$MESSAGE*/
				isc_975.isc_976[1021] = 0;
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_exception_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 1074, &isc_975, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}


burp_fld* get_field(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_901_struct {
          char  isc_902 [32];	/* RDB$FIELD_SOURCE */
          char  isc_903 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_904;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_905;	/* RDB$DEFAULT_SOURCE */
          char  isc_906 [32];	/* RDB$COMPLEX_NAME */
          ISC_QUAD isc_907;	/* RDB$DESCRIPTION */
          char  isc_908 [128];	/* RDB$EDIT_STRING */
          ISC_QUAD isc_909;	/* RDB$QUERY_HEADER */
          char  isc_910 [32];	/* RDB$QUERY_NAME */
          char  isc_911 [32];	/* RDB$SECURITY_CLASS */
          char  isc_912 [32];	/* RDB$BASE_FIELD */
          char  isc_913 [32];	/* RDB$RELATION_NAME */
          short isc_914;	/* gds__null_flag */
          short isc_915;	/* RDB$COLLATION_ID */
          short isc_916;	/* gds__null_flag */
          short isc_917;	/* RDB$NULL_FLAG */
          short isc_918;	/* gds__null_flag */
          short isc_919;	/* gds__null_flag */
          short isc_920;	/* gds__null_flag */
          short isc_921;	/* RDB$UPDATE_FLAG */
          short isc_922;	/* gds__null_flag */
          short isc_923;	/* gds__null_flag */
          short isc_924;	/* RDB$SYSTEM_FLAG */
          short isc_925;	/* gds__null_flag */
          short isc_926;	/* gds__null_flag */
          short isc_927;	/* gds__null_flag */
          short isc_928;	/* gds__null_flag */
          short isc_929;	/* gds__null_flag */
          short isc_930;	/* gds__null_flag */
          short isc_931;	/* gds__null_flag */
          short isc_932;	/* gds__null_flag */
          short isc_933;	/* RDB$VIEW_CONTEXT */
          short isc_934;	/* RDB$FIELD_POSITION */
   } isc_901;
   struct isc_936_struct {
          char  isc_937 [32];	/* RDB$FIELD_SOURCE */
          char  isc_938 [32];	/* RDB$FIELD_NAME */
          char  isc_939 [32];	/* RDB$GENERATOR_NAME */
          ISC_QUAD isc_940;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_941;	/* RDB$DEFAULT_SOURCE */
          char  isc_942 [32];	/* RDB$COMPLEX_NAME */
          ISC_QUAD isc_943;	/* RDB$DESCRIPTION */
          char  isc_944 [128];	/* RDB$EDIT_STRING */
          ISC_QUAD isc_945;	/* RDB$QUERY_HEADER */
          char  isc_946 [32];	/* RDB$QUERY_NAME */
          char  isc_947 [32];	/* RDB$SECURITY_CLASS */
          char  isc_948 [32];	/* RDB$BASE_FIELD */
          char  isc_949 [32];	/* RDB$RELATION_NAME */
          short isc_950;	/* gds__null_flag */
          short isc_951;	/* RDB$IDENTITY_TYPE */
          short isc_952;	/* gds__null_flag */
          short isc_953;	/* gds__null_flag */
          short isc_954;	/* RDB$COLLATION_ID */
          short isc_955;	/* gds__null_flag */
          short isc_956;	/* RDB$NULL_FLAG */
          short isc_957;	/* gds__null_flag */
          short isc_958;	/* gds__null_flag */
          short isc_959;	/* gds__null_flag */
          short isc_960;	/* RDB$UPDATE_FLAG */
          short isc_961;	/* gds__null_flag */
          short isc_962;	/* gds__null_flag */
          short isc_963;	/* RDB$SYSTEM_FLAG */
          short isc_964;	/* gds__null_flag */
          short isc_965;	/* gds__null_flag */
          short isc_966;	/* gds__null_flag */
          short isc_967;	/* gds__null_flag */
          short isc_968;	/* gds__null_flag */
          short isc_969;	/* gds__null_flag */
          short isc_970;	/* gds__null_flag */
          short isc_971;	/* gds__null_flag */
          short isc_972;	/* RDB$VIEW_CONTEXT */
          short isc_973;	/* RDB$FIELD_POSITION */
   } isc_936;
/**************************************
 *
 *	g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a local field.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	// If it is a view and there is a global transaction then use it
	bool global_tr = false;
	isc_tr_handle local_trans;
	if ((relation->rel_flags & REL_view) && tdgbl->global_trans)
	{
		local_trans = tdgbl->global_trans;
		global_tr = true;
	}
	else
		local_trans = gds_trans;

	burp_fld* field = (burp_fld*) BURP_alloc_zero (sizeof(burp_fld));

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		/*STORE (TRANSACTION_HANDLE local_trans REQUEST_HANDLE tdgbl->handles_get_field_req_handle1)
			X IN RDB$RELATION_FIELDS*/
		{
		
                if (!tdgbl->handles_get_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (short) sizeof(isc_935), (char*) isc_935);
		if (tdgbl->handles_get_field_req_handle1)
		   {
		   isc_936.isc_940 = isc_blob_null;
		   isc_936.isc_941 = isc_blob_null;
		   isc_936.isc_943 = isc_blob_null;
		   isc_936.isc_945 = isc_blob_null;
		{
			strcpy (/*X.RDB$RELATION_NAME*/
				isc_936.isc_949, relation->rel_name);
			/*X.RDB$FIELD_POSITION*/
			isc_936.isc_973 = 0;
			/*X.RDB$VIEW_CONTEXT.NULL*/
			isc_936.isc_971 = TRUE;
			/*X.RDB$BASE_FIELD.NULL*/
			isc_936.isc_970 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_936.isc_969 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_936.isc_968 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_936.isc_967 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_936.isc_966 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_936.isc_965 = TRUE;
			/*X.RDB$FIELD_POSITION.NULL*/
			isc_936.isc_964 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_936.isc_963 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_936.isc_962 = FALSE;
			/*X.RDB$COMPLEX_NAME.NULL*/
			isc_936.isc_961 = TRUE;
			/*X.RDB$UPDATE_FLAG.NULL*/
			isc_936.isc_959 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_936.isc_958 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_936.isc_957 = TRUE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_936.isc_955 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_936.isc_953 = TRUE;
			// ODS 12
			/*X.RDB$GENERATOR_NAME.NULL*/
			isc_936.isc_952 = TRUE;
			/*X.RDB$IDENTITY_TYPE.NULL*/
			isc_936.isc_950 = TRUE;

			skip_init(&scan_next_attr);
			while (get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (skip_scan(&scan_next_attr), attribute)
				{
				case att_field_name:
					field->fld_name_length = GET_TEXT(field->fld_name);
					BURP_verbose (115, field->fld_name);
					// msg 115 restoring field %s
					strcpy (/*X.RDB$FIELD_NAME*/
						isc_936.isc_938, field->fld_name);
					break;

				case att_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_936.isc_937);
					break;

				case att_field_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_936.isc_947);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_936.isc_947, true);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_936.isc_969 = FALSE;
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_936.isc_946);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_936.isc_968 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_936.isc_967 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_936.isc_945, global_tr);
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_936.isc_944);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_936.isc_966 = FALSE;
					break;

				case att_field_position:
					/*X.RDB$FIELD_POSITION.NULL*/
					isc_936.isc_964 = FALSE;
					/*X.RDB$FIELD_POSITION*/
					isc_936.isc_973 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_number:
					field->fld_number = (USHORT) get_int32(tdgbl);
					break;

				case att_field_type:
					field->fld_type = (USHORT) get_int32(tdgbl);
					break;

				case att_field_length:
					field->fld_length = (USHORT) get_int32(tdgbl);
					break;

				case att_field_scale:
					field->fld_scale = (USHORT) get_int32(tdgbl);
					break;

				case att_field_sub_type:
					field->fld_sub_type = (USHORT) get_int32(tdgbl);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_936.isc_963 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_936.isc_962 = FALSE;
					break;

				case att_view_context:
					/*X.RDB$VIEW_CONTEXT*/
					isc_936.isc_972 = (USHORT) get_int32(tdgbl);
					/*X.RDB$VIEW_CONTEXT.NULL*/
					isc_936.isc_971 = FALSE;
					break;

				case att_field_computed_flag:
					if (get_int32(tdgbl))
						field->fld_flags |= FLD_computed;
					break;

				case att_base_field:
					GET_TEXT(/*X.RDB$BASE_FIELD*/
						 isc_936.isc_948);
					/*X.RDB$BASE_FIELD.NULL*/
					isc_936.isc_970 = FALSE;
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_936.isc_965 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_936.isc_943, global_tr);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_936.isc_965 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_936.isc_943, global_tr);
					break;

				case att_field_complex_name:
					GET_TEXT(/*X.RDB$COMPLEX_NAME*/
						 isc_936.isc_942);
					/*X.RDB$COMPLEX_NAME.NULL*/
					isc_936.isc_961 = FALSE;
					break;

				case att_field_dimensions:
					{
						field->fld_dimensions = (USHORT) get_int32(tdgbl);
						field->fld_flags |= FLD_array;
						USHORT n = field->fld_dimensions;
						for (SLONG* rp = field->fld_ranges; n; rp += 2, n--)
						{
							if (get_attribute(&attribute, tdgbl) != att_field_range_low)
								bad_attribute(scan_next_attr, attribute, 58);
							// msg 58 array
							else
								*rp = get_int32(tdgbl);
							if (get_attribute(&attribute, tdgbl) != att_field_range_high)
								bad_attribute(scan_next_attr, attribute, 58);
								// msg 58 array
							else
								*(rp + 1) = get_int32(tdgbl);
						}
					}
					break;

				case att_field_update_flag:
					/*X.RDB$UPDATE_FLAG.NULL*/
					isc_936.isc_959 = FALSE;
					/*X.RDB$UPDATE_FLAG*/
					isc_936.isc_960 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_936.isc_958 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_936.isc_941, global_tr);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_936.isc_957 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_936.isc_940, global_tr);
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_int32(tdgbl); // skip
					}
					else
					{
						/*X.RDB$NULL_FLAG.NULL*/
						isc_936.isc_955 = FALSE;
						/*X.RDB$NULL_FLAG*/
						isc_936.isc_956 = (USHORT) get_int32(tdgbl);
					}
					break;

				case att_field_character_set:
					field->fld_character_set_id = (USHORT) get_int32(tdgbl);
					break;

				case att_field_collation_id:
					field->fld_collation_id = (USHORT) get_int32(tdgbl);
					/*X.RDB$COLLATION_ID.NULL*/
					isc_936.isc_953 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_936.isc_954 = field->fld_collation_id;
					break;

				// ODS 12

				case att_field_generator_name:
					GET_TEXT(/*X.RDB$GENERATOR_NAME*/
						 isc_936.isc_939);
					/*X.RDB$GENERATOR_NAME.NULL*/
					isc_936.isc_952 = FALSE;
					break;

				case att_field_identity_type:
					/*X.RDB$IDENTITY_TYPE.NULL*/
					isc_936.isc_950 = FALSE;
					/*X.RDB$IDENTITY_TYPE*/
					isc_936.isc_951 = (SSHORT) get_int32(tdgbl);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 84);
					// msg 84 column
					break;
				}
			}
		}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 464, &isc_936, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans REQUEST_HANDLE tdgbl->handles_get_field_req_handle1)
			X IN RDB$RELATION_FIELDS*/
		{
		
                if (!tdgbl->handles_get_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (short) sizeof(isc_900), (char*) isc_900);
		if (tdgbl->handles_get_field_req_handle1)
		   {
		   isc_901.isc_904 = isc_blob_null;
		   isc_901.isc_905 = isc_blob_null;
		   isc_901.isc_907 = isc_blob_null;
		   isc_901.isc_909 = isc_blob_null;
		{
			strcpy (/*X.RDB$RELATION_NAME*/
				isc_901.isc_913, relation->rel_name);
			/*X.RDB$FIELD_POSITION*/
			isc_901.isc_934 = 0;
			/*X.RDB$VIEW_CONTEXT.NULL*/
			isc_901.isc_932 = TRUE;
			/*X.RDB$BASE_FIELD.NULL*/
			isc_901.isc_931 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_901.isc_930 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_901.isc_929 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_901.isc_928 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_901.isc_927 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_901.isc_926 = TRUE;
			/*X.RDB$FIELD_POSITION.NULL*/
			isc_901.isc_925 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_901.isc_924 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_901.isc_923 = FALSE;
			/*X.RDB$COMPLEX_NAME.NULL*/
			isc_901.isc_922 = TRUE;
			/*X.RDB$UPDATE_FLAG.NULL*/
			isc_901.isc_920 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_901.isc_919 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_901.isc_918 = TRUE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_901.isc_916 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_901.isc_914 = TRUE;

			skip_init(&scan_next_attr);
			while (get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (skip_scan(&scan_next_attr), attribute)
				{
				case att_field_name:
					field->fld_name_length = GET_TEXT(field->fld_name);
					BURP_verbose (115, field->fld_name);
					// msg 115 restoring field %s
					strcpy (/*X.RDB$FIELD_NAME*/
						isc_901.isc_903, field->fld_name);
					break;

				case att_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_901.isc_902);
					break;

				case att_field_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_901.isc_911);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_901.isc_911, true);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_901.isc_930 = FALSE;
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_901.isc_910);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_901.isc_929 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_901.isc_928 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_901.isc_909, global_tr);
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_901.isc_908);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_901.isc_927 = FALSE;
					break;

				case att_field_position:
					/*X.RDB$FIELD_POSITION.NULL*/
					isc_901.isc_925 = FALSE;
					/*X.RDB$FIELD_POSITION*/
					isc_901.isc_934 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_number:
					field->fld_number = (USHORT) get_int32(tdgbl);
					break;

				case att_field_type:
					field->fld_type = (USHORT) get_int32(tdgbl);
					break;

				case att_field_length:
					field->fld_length = (USHORT) get_int32(tdgbl);
					break;

				case att_field_scale:
					field->fld_scale = (USHORT) get_int32(tdgbl);
					break;

				case att_field_sub_type:
					field->fld_sub_type = (USHORT) get_int32(tdgbl);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_901.isc_924 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_901.isc_923 = FALSE;
					break;

				case att_view_context:
					/*X.RDB$VIEW_CONTEXT*/
					isc_901.isc_933 = (USHORT) get_int32(tdgbl);
					/*X.RDB$VIEW_CONTEXT.NULL*/
					isc_901.isc_932 = FALSE;
					break;

				case att_field_computed_flag:
					if (get_int32(tdgbl))
						field->fld_flags |= FLD_computed;
					break;

				case att_base_field:
					GET_TEXT(/*X.RDB$BASE_FIELD*/
						 isc_901.isc_912);
					/*X.RDB$BASE_FIELD.NULL*/
					isc_901.isc_931 = FALSE;
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_901.isc_926 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_901.isc_907, global_tr);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_901.isc_926 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_901.isc_907, global_tr);
					break;

				case att_field_complex_name:
					GET_TEXT(/*X.RDB$COMPLEX_NAME*/
						 isc_901.isc_906);
					/*X.RDB$COMPLEX_NAME.NULL*/
					isc_901.isc_922 = FALSE;
					break;

				case att_field_dimensions:
					{
						field->fld_dimensions = (USHORT) get_int32(tdgbl);
						field->fld_flags |= FLD_array;
						USHORT n = field->fld_dimensions;
						for (SLONG* rp = field->fld_ranges; n; rp += 2, n--)
						{
							if (get_attribute(&attribute, tdgbl) != att_field_range_low)
								bad_attribute(scan_next_attr, attribute, 58);
							// msg 58 array
							else
								*rp = get_int32(tdgbl);
							if (get_attribute(&attribute, tdgbl) != att_field_range_high)
								bad_attribute(scan_next_attr, attribute, 58);
								// msg 58 array
							else
								*(rp + 1) = get_int32(tdgbl);
						}
					}
					break;

				case att_field_update_flag:
					/*X.RDB$UPDATE_FLAG.NULL*/
					isc_901.isc_920 = FALSE;
					/*X.RDB$UPDATE_FLAG*/
					isc_901.isc_921 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_901.isc_919 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_901.isc_905, global_tr);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_901.isc_918 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_901.isc_904, global_tr);
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_int32(tdgbl); // skip
					}
					else
					{
						/*X.RDB$NULL_FLAG.NULL*/
						isc_901.isc_916 = FALSE;
						/*X.RDB$NULL_FLAG*/
						isc_901.isc_917 = (USHORT) get_int32(tdgbl);
					}
					break;

				case att_field_character_set:
					field->fld_character_set_id = (USHORT) get_int32(tdgbl);
					break;

				case att_field_collation_id:
					field->fld_collation_id = (USHORT) get_int32(tdgbl);
					/*X.RDB$COLLATION_ID.NULL*/
					isc_901.isc_914 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_901.isc_915 = field->fld_collation_id;
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 84);
					// msg 84 column
					break;
				}
			}
		}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 426, &isc_901, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error();
		/*END_ERROR*/
		   }
		}
	}

	return field;
}

bool get_field_dimensions(BurpGlobals* tdgbl)
{
   struct isc_895_struct {
          char  isc_896 [32];	/* RDB$FIELD_NAME */
          ISC_LONG isc_897;	/* RDB$UPPER_BOUND */
          ISC_LONG isc_898;	/* RDB$LOWER_BOUND */
          short isc_899;	/* RDB$DIMENSION */
   } isc_895;
/**************************************
 *
 *	g e t _ f i e l d _ d i m e n s i o n s
 *
 **************************************
 *
 * Functional description
 *	Get array field dimensions in rdb$field_dimensions.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_field_dimensions_req_handle1)
		X IN RDB$FIELD_DIMENSIONS*/
	{
	
        if (!tdgbl->handles_get_field_dimensions_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (short) sizeof(isc_894), (char*) isc_894);
	if (tdgbl->handles_get_field_dimensions_req_handle1)
	   {

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_895.isc_896);
				break;

			case att_field_dimensions:
				/*X.RDB$DIMENSION*/
				isc_895.isc_899 = (USHORT) get_int32(tdgbl);
				break;

			case att_field_range_low:
				/*X.RDB$LOWER_BOUND*/
				isc_895.isc_898 = get_int32(tdgbl);
				break;

			case att_field_range_high:
				/*X.RDB$UPPER_BOUND*/
				isc_895.isc_897 = get_int32(tdgbl);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 288);
				// msg 288 array dimensions
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_field_dimensions_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 42, &isc_895, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_files(BurpGlobals* tdgbl)
{
   struct isc_887_struct {
          char  isc_888 [256];	/* RDB$FILE_NAME */
          ISC_LONG isc_889;	/* RDB$FILE_LENGTH */
          ISC_LONG isc_890;	/* RDB$FILE_START */
          short isc_891;	/* RDB$SHADOW_NUMBER */
          short isc_892;	/* RDB$FILE_SEQUENCE */
          short isc_893;	/* RDB$FILE_FLAGS */
   } isc_887;
/**************************************
 *
 *	g e t _ f i l e s
 *
 **************************************
 *
 * Functional description
 *	Get any files that were stored; let
 *	somebody else worry about what to do with them.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_files_req_handle1)
		X IN RDB$FILES*/
	{
	
        if (!tdgbl->handles_get_files_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (short) sizeof(isc_886), (char*) isc_886);
	if (tdgbl->handles_get_files_req_handle1)
	   {
		/*X.RDB$FILE_FLAGS*/
		isc_887.isc_893 = 0;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_file_filename:
				GET_TEXT(/*X.RDB$FILE_NAME*/
					 isc_887.isc_888);
				BURP_verbose (116, /*X.RDB$FILE_NAME*/
						   isc_887.isc_888);
				// msg 116 restoring file %s
				break;

			case att_file_sequence:
				/*X.RDB$FILE_SEQUENCE*/
				isc_887.isc_892 = (USHORT) get_int32(tdgbl);
				break;

			case att_file_start:
				/*X.RDB$FILE_START*/
				isc_887.isc_890 = get_int32(tdgbl);
				break;

			case att_file_length:
				/*X.RDB$FILE_LENGTH*/
				isc_887.isc_889 = get_int32(tdgbl);
				break;

			case att_file_flags:
				/*X.RDB$FILE_FLAGS*/
				isc_887.isc_893 |= get_int32(tdgbl);
				break;

			case att_shadow_number:
				/*X.RDB$SHADOW_NUMBER*/
				isc_887.isc_891 = (USHORT) get_int32(tdgbl);
				if (tdgbl->gbl_sw_kill && /*X.RDB$SHADOW_NUMBER*/
							  isc_887.isc_891)
					/*X.RDB$FILE_FLAGS*/
					isc_887.isc_893 |= FILE_inactive;
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 85);
				// msg 85 file
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_files_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 270, &isc_887, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_filter(BurpGlobals* tdgbl)
{
   struct isc_876_struct {
          char  isc_877 [256];	/* RDB$ENTRYPOINT */
          char  isc_878 [256];	/* RDB$MODULE_NAME */
          char  isc_879 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_880;	/* RDB$DESCRIPTION */
          short isc_881;	/* RDB$OUTPUT_SUB_TYPE */
          short isc_882;	/* RDB$INPUT_SUB_TYPE */
          short isc_883;	/* gds__null_flag */
          short isc_884;	/* RDB$SYSTEM_FLAG */
          short isc_885;	/* gds__null_flag */
   } isc_876;
/**************************************
 *
 *	g e t _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$filters.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_filter_req_handle1)
		X IN RDB$FILTERS*/
	{
	
        if (!tdgbl->handles_get_filter_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (short) sizeof(isc_875), (char*) isc_875);
	if (tdgbl->handles_get_filter_req_handle1)
	   {
	   isc_876.isc_880 = isc_blob_null;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_876.isc_885 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_876.isc_884 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_876.isc_883 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_filter_name:
				GET_TEXT(/*X.RDB$FUNCTION_NAME*/
					 isc_876.isc_879);
				BURP_verbose (117, /*X.RDB$FUNCTION_NAME*/
						   isc_876.isc_879);
				// msg 117 restoring filter %s
				break;

			case att_filter_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_876.isc_885 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_876.isc_880, false);
				break;

			case att_filter_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_876.isc_885 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_876.isc_880, false);
				break;

			case att_filter_module_name:
				GET_TEXT(/*X.RDB$MODULE_NAME*/
					 isc_876.isc_878);
				break;

			case att_filter_entrypoint:
				GET_TEXT(/*X.RDB$ENTRYPOINT*/
					 isc_876.isc_877);
				break;

			case att_filter_input_sub_type:
				/*X.RDB$INPUT_SUB_TYPE*/
				isc_876.isc_882 = (USHORT) get_int32(tdgbl);
				break;

			case att_filter_output_sub_type:
				/*X.RDB$OUTPUT_SUB_TYPE*/
				isc_876.isc_881 = (USHORT) get_int32(tdgbl);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 87);
				// msg 87  filter
				break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_filter_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 562, &isc_876, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_function(BurpGlobals* tdgbl)
{
   struct isc_830_struct {
          char  isc_831 [32];	/* RDB$QUERY_NAME */
          char  isc_832 [256];	/* RDB$ENTRYPOINT */
          char  isc_833 [256];	/* RDB$MODULE_NAME */
          char  isc_834 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_835;	/* RDB$DESCRIPTION */
          short isc_836;	/* RDB$FUNCTION_TYPE */
          short isc_837;	/* RDB$RETURN_ARGUMENT */
          short isc_838;	/* gds__null_flag */
          short isc_839;	/* gds__null_flag */
          short isc_840;	/* RDB$SYSTEM_FLAG */
   } isc_830;
   struct isc_842_struct {
          char  isc_843 [32];	/* RDB$QUERY_NAME */
          char  isc_844 [256];	/* RDB$ENTRYPOINT */
          char  isc_845 [256];	/* RDB$MODULE_NAME */
          char  isc_846 [32];	/* RDB$FUNCTION_NAME */
          char  isc_847 [32];	/* RDB$OWNER_NAME */
          char  isc_848 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_849;	/* RDB$DEBUG_INFO */
          ISC_QUAD isc_850;	/* RDB$FUNCTION_SOURCE */
          ISC_QUAD isc_851;	/* RDB$FUNCTION_BLR */
          char  isc_852 [32];	/* RDB$PACKAGE_NAME */
          char  isc_853 [32];	/* RDB$ENGINE_NAME */
          ISC_QUAD isc_854;	/* RDB$DESCRIPTION */
          short isc_855;	/* RDB$FUNCTION_TYPE */
          short isc_856;	/* RDB$RETURN_ARGUMENT */
          short isc_857;	/* gds__null_flag */
          short isc_858;	/* RDB$LEGACY_FLAG */
          short isc_859;	/* gds__null_flag */
          short isc_860;	/* RDB$DETERMINISTIC_FLAG */
          short isc_861;	/* gds__null_flag */
          short isc_862;	/* RDB$SYSTEM_FLAG */
          short isc_863;	/* gds__null_flag */
          short isc_864;	/* gds__null_flag */
          short isc_865;	/* gds__null_flag */
          short isc_866;	/* gds__null_flag */
          short isc_867;	/* RDB$VALID_BLR */
          short isc_868;	/* gds__null_flag */
          short isc_869;	/* gds__null_flag */
          short isc_870;	/* gds__null_flag */
          short isc_871;	/* RDB$PRIVATE_FLAG */
          short isc_872;	/* gds__null_flag */
          short isc_873;	/* gds__null_flag */
          short isc_874;	/* gds__null_flag */
   } isc_842;
/**************************************
 *
 *	g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a function.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN * 2];
	SSHORT		l;
	scan_attr_t	scan_next_attr;

	bool existFlag = false;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		GDS_NAME function_name;
		bool securityClass = false;

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_req_handle1)
			X IN RDB$FUNCTIONS*/
		{
		
                if (!tdgbl->handles_get_function_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (short) sizeof(isc_841), (char*) isc_841);
		if (tdgbl->handles_get_function_req_handle1)
		   {
		   isc_842.isc_849 = isc_blob_null;
		   isc_842.isc_850 = isc_blob_null;
		   isc_842.isc_851 = isc_blob_null;
		   isc_842.isc_854 = isc_blob_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_842.isc_874 = TRUE;
			/*X.RDB$ENGINE_NAME.NULL*/
			isc_842.isc_873 = TRUE;
			/*X.RDB$PACKAGE_NAME.NULL*/
			isc_842.isc_872 = TRUE;
			/*X.RDB$PRIVATE_FLAG.NULL*/
			isc_842.isc_870 = TRUE;
			/*X.RDB$FUNCTION_BLR.NULL*/
			isc_842.isc_869 = TRUE;
			/*X.RDB$FUNCTION_SOURCE.NULL*/
			isc_842.isc_868 = TRUE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_842.isc_866 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_842.isc_865 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_842.isc_864 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_842.isc_863 = TRUE;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_842.isc_861 = FALSE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_842.isc_862 = 0;

			/*X.RDB$DETERMINISTIC_FLAG.NULL*/
			isc_842.isc_859 = FALSE;
			/*X.RDB$DETERMINISTIC_FLAG*/
			isc_842.isc_860 = 0;

			/*X.RDB$LEGACY_FLAG.NULL*/
			isc_842.isc_857 = FALSE;
			/*X.RDB$LEGACY_FLAG*/
			isc_842.isc_858 = 1;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_function_name:
				{
					SSHORT prefixLen = 0;
					if (!/*X.RDB$PACKAGE_NAME.NULL*/
					     isc_842.isc_872)
					{
						prefixLen = strlen(/*X.RDB$PACKAGE_NAME*/
								   isc_842.isc_852);
						memcpy(temp, /*X.RDB$PACKAGE_NAME*/
							     isc_842.isc_852, prefixLen);
						temp[prefixLen++] = '.';
					}

					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_842.isc_846);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_842.isc_846, temp + prefixLen, l,
						sizeof(temp) - prefixLen);
					BURP_verbose (118, temp);
					// msg 118 restoring function %s
					break;
				}

				case att_function_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_842.isc_874 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_842.isc_854, false);
					break;

				case att_function_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_842.isc_874 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_842.isc_854, false);
					break;

				case att_function_module_name:
					GET_TEXT(/*X.RDB$MODULE_NAME*/
						 isc_842.isc_845);
					break;

				case att_function_entrypoint:
					GET_TEXT(/*X.RDB$ENTRYPOINT*/
						 isc_842.isc_844);
					break;

				case att_function_return_arg:
					/*X.RDB$RETURN_ARGUMENT*/
					isc_842.isc_856 = (USHORT) get_int32(tdgbl);
					break;

				case att_function_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_842.isc_843);
					break;

				case att_function_type:
					/*X.RDB$FUNCTION_TYPE*/
					isc_842.isc_855 = (USHORT) get_int32(tdgbl);
					break;

				case att_function_engine_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ENGINE_NAME*/
							 isc_842.isc_853);
						/*X.RDB$ENGINE_NAME.NULL*/
						isc_842.isc_873 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_package_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$PACKAGE_NAME*/
							 isc_842.isc_852);
						fb_utils::exact_name(/*X.RDB$PACKAGE_NAME*/
								     isc_842.isc_852);
						/*X.RDB$PACKAGE_NAME.NULL*/
						isc_842.isc_872 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_private_flag:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$PRIVATE_FLAG*/
						isc_842.isc_871 = (USHORT) get_int32(tdgbl);
						/*X.RDB$PRIVATE_FLAG.NULL*/
						isc_842.isc_870 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_blr:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_blr_blob(tdgbl, /*X.RDB$FUNCTION_BLR*/
								    isc_842.isc_851, false);
						/*X.RDB$FUNCTION_BLR.NULL*/
						isc_842.isc_869 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_source:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_source_blob(tdgbl, /*X.RDB$FUNCTION_SOURCE*/
								       isc_842.isc_850, false);
						/*X.RDB$FUNCTION_SOURCE.NULL*/
						isc_842.isc_868 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_valid_blr:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$VALID_BLR*/
						isc_842.isc_867 = get_int32(tdgbl);
						/*X.RDB$VALID_BLR.NULL*/
						isc_842.isc_866 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_debug_info:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_blr_blob(tdgbl, /*X.RDB$DEBUG_INFO*/
								    isc_842.isc_849, false);
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_842.isc_865 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_security_class:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$SECURITY_CLASS*/
							 isc_842.isc_848);
						/*X.RDB$SECURITY_CLASS.NULL*/
						isc_842.isc_864 = FALSE;
						securityClass = true;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_owner_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$OWNER_NAME*/
							 isc_842.isc_847);
						/*X.RDB$OWNER_NAME.NULL*/
						isc_842.isc_863 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_legacy_flag:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$LEGACY_FLAG*/
						isc_842.isc_858 = get_int32(tdgbl);
						/*X.RDB$LEGACY_FLAG.NULL*/
						isc_842.isc_857 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_deterministic_flag:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$DETERMINISTIC_FLAG*/
						isc_842.isc_860 = get_int32(tdgbl);
						/*X.RDB$DETERMINISTIC_FLAG.NULL*/
						isc_842.isc_859 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 89);
					// msg 89 function
					break;
				}
			}

			strcpy(function_name, /*X.RDB$FUNCTION_NAME*/
					      isc_842.isc_846);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 776, &isc_842, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			if (gds_status[1] != isc_no_dup)
				general_on_error ();
			else
				existFlag = true;
		/*END_ERROR;*/
		   }
		}

		if (!securityClass)
			collect_missing_privs(tdgbl, obj_udf, function_name);
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_req_handle1)
			X IN RDB$FUNCTIONS*/
		{
		
                if (!tdgbl->handles_get_function_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (short) sizeof(isc_829), (char*) isc_829);
		if (tdgbl->handles_get_function_req_handle1)
		   {
		   isc_830.isc_835 = isc_blob_null;
			/*X.RDB$SYSTEM_FLAG*/
			isc_830.isc_840 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_830.isc_839 = FALSE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_830.isc_838 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_function_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_830.isc_834);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_830.isc_834, temp, l, sizeof(temp));
					BURP_verbose (118, temp);
					// msg 118 restoring function %s
					break;

				case att_function_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_830.isc_838 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_830.isc_835, false);
					break;

				case att_function_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_830.isc_838 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_830.isc_835, false);
					break;

				case att_function_module_name:
					GET_TEXT(/*X.RDB$MODULE_NAME*/
						 isc_830.isc_833);
					break;

				case att_function_entrypoint:
					GET_TEXT(/*X.RDB$ENTRYPOINT*/
						 isc_830.isc_832);
					break;

				case att_function_return_arg:
					/*X.RDB$RETURN_ARGUMENT*/
					isc_830.isc_837 = (USHORT) get_int32(tdgbl);
					break;

				case att_function_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_830.isc_831);
					break;

				case att_function_type:
					/*X.RDB$FUNCTION_TYPE*/
					isc_830.isc_836 = (USHORT) get_int32(tdgbl);
					break;

				case att_function_engine_name:
				case att_function_package_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_private_flag:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_blr:
				case att_function_source:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_valid_blr:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_debug_info:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_security_class:
				case att_function_owner_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				case att_function_legacy_flag:
				case att_function_deterministic_flag:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 89);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 89);
					// msg 89 function
					break;
				}
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 594, &isc_830, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			if (gds_status[1] != isc_no_dup)
				general_on_error ();
			else
				existFlag = true;
		/*END_ERROR;*/
		   }
		}
	}

	// at the end of args for a function is the rec_function_end marker
	while (get(tdgbl) == rec_function_arg)
		get_function_arg(tdgbl, existFlag);

	return true;
}

void get_function_arg(BurpGlobals* tdgbl, bool skip_arguments)
{
   struct isc_766_struct {
          char  isc_767 [32];	/* RDB$FUNCTION_NAME */
          short isc_768;	/* RDB$FIELD_LENGTH */
          short isc_769;	/* RDB$FIELD_SCALE */
          short isc_770;	/* RDB$FIELD_TYPE */
          short isc_771;	/* RDB$MECHANISM */
          short isc_772;	/* RDB$ARGUMENT_POSITION */
          short isc_773;	/* gds__null_flag */
          short isc_774;	/* RDB$CHARACTER_SET_ID */
          short isc_775;	/* gds__null_flag */
          short isc_776;	/* RDB$FIELD_SUB_TYPE */
   } isc_766;
   struct isc_778_struct {
          char  isc_779 [32];	/* RDB$FUNCTION_NAME */
          short isc_780;	/* RDB$FIELD_LENGTH */
          short isc_781;	/* RDB$FIELD_SCALE */
          short isc_782;	/* RDB$FIELD_TYPE */
          short isc_783;	/* RDB$MECHANISM */
          short isc_784;	/* RDB$ARGUMENT_POSITION */
          short isc_785;	/* gds__null_flag */
          short isc_786;	/* RDB$FIELD_PRECISION */
          short isc_787;	/* gds__null_flag */
          short isc_788;	/* RDB$CHARACTER_SET_ID */
          short isc_789;	/* gds__null_flag */
          short isc_790;	/* RDB$FIELD_SUB_TYPE */
   } isc_778;
   struct isc_792_struct {
          char  isc_793 [32];	/* RDB$FUNCTION_NAME */
          ISC_QUAD isc_794;	/* RDB$DESCRIPTION */
          char  isc_795 [32];	/* RDB$RELATION_NAME */
          char  isc_796 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_797;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_798;	/* RDB$DEFAULT_VALUE */
          char  isc_799 [32];	/* RDB$FIELD_SOURCE */
          char  isc_800 [32];	/* RDB$ARGUMENT_NAME */
          char  isc_801 [32];	/* RDB$PACKAGE_NAME */
          short isc_802;	/* RDB$FIELD_LENGTH */
          short isc_803;	/* RDB$FIELD_SCALE */
          short isc_804;	/* RDB$FIELD_TYPE */
          short isc_805;	/* RDB$MECHANISM */
          short isc_806;	/* RDB$ARGUMENT_POSITION */
          short isc_807;	/* gds__null_flag */
          short isc_808;	/* RDB$SYSTEM_FLAG */
          short isc_809;	/* gds__null_flag */
          short isc_810;	/* gds__null_flag */
          short isc_811;	/* gds__null_flag */
          short isc_812;	/* gds__null_flag */
          short isc_813;	/* RDB$ARGUMENT_MECHANISM */
          short isc_814;	/* gds__null_flag */
          short isc_815;	/* RDB$NULL_FLAG */
          short isc_816;	/* gds__null_flag */
          short isc_817;	/* RDB$COLLATION_ID */
          short isc_818;	/* gds__null_flag */
          short isc_819;	/* gds__null_flag */
          short isc_820;	/* gds__null_flag */
          short isc_821;	/* gds__null_flag */
          short isc_822;	/* gds__null_flag */
          short isc_823;	/* gds__null_flag */
          short isc_824;	/* RDB$FIELD_PRECISION */
          short isc_825;	/* gds__null_flag */
          short isc_826;	/* RDB$CHARACTER_SET_ID */
          short isc_827;	/* gds__null_flag */
          short isc_828;	/* RDB$FIELD_SUB_TYPE */
   } isc_792;
/**************************************
 *
 *	g e t _ f u n c t i o n _ a r g
 *
 **************************************
 *
 * Functional description
 *	Reconstruct function argument.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	if (skip_arguments)
	{
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_functionarg_name:
				eat_text(tdgbl);
				break;

			case att_functionarg_position:
				get_int32(tdgbl);
				break;

			case att_functionarg_passing_mechanism:
				get_int32(tdgbl);
				break;

			case att_functionarg_field_type:
				get_int32(tdgbl);
				break;

			case att_functionarg_field_scale:
				get_int32(tdgbl);
				break;

			case att_functionarg_field_length:
				get_int32(tdgbl);
				break;

			case att_functionarg_field_sub_type:
				get_int32(tdgbl);
				break;

			case att_functionarg_character_set:
				get_int32(tdgbl);
				break;

			case att_functionarg_field_precision:
				get_int32(tdgbl);
				break;

			case att_functionarg_package_name:
			case att_functionarg_arg_name:
			case att_functionarg_field_source:
				if (tdgbl->RESTORE_format >= 10)
					eat_text(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 90);
				break;

			case att_functionarg_default_value:
			case att_functionarg_default_source:
				if (tdgbl->RESTORE_format >= 10)
					eat_blob(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 90);
				break;

			case att_functionarg_collation_id:
			case att_functionarg_null_flag:
			case att_functionarg_type_mechanism:
				if (tdgbl->RESTORE_format >= 10)
					get_int32(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 90);
				break;

			case att_functionarg_field_name:
			case att_functionarg_relation_name:
				if (tdgbl->RESTORE_format >= 10)
					eat_text(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 90);
				break;

			case att_functionarg_description:
				if (tdgbl->RESTORE_format >= 10)
					eat_blob(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 90);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 90);
				// msg 90 function argument
				break;
			}
		}
		return;
	}

	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN * 2];

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		// with RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_791), (char*) isc_791);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
		   isc_792.isc_794 = isc_blob_null;
		   isc_792.isc_797 = isc_blob_null;
		   isc_792.isc_798 = isc_blob_null;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_792.isc_827 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_792.isc_825 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_792.isc_823 = TRUE;
			/*X.RDB$PACKAGE_NAME.NULL*/
			isc_792.isc_822 = TRUE;
			/*X.RDB$ARGUMENT_NAME.NULL*/
			isc_792.isc_821 = TRUE;
			/*X.RDB$FIELD_SOURCE.NULL*/
			isc_792.isc_820 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_792.isc_819 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_792.isc_818 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_792.isc_816 = TRUE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_792.isc_814 = TRUE;
			/*X.RDB$ARGUMENT_MECHANISM.NULL*/
			isc_792.isc_812 = TRUE;
			/*X.RDB$FIELD_NAME.NULL*/
			isc_792.isc_811 = TRUE;
			/*X.RDB$RELATION_NAME.NULL*/
			isc_792.isc_810 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_792.isc_809 = TRUE;

			/*X.RDB$SYSTEM_FLAG*/
			isc_792.isc_808 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_792.isc_807 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					{
						SSHORT prefixLen = 0;
						if (!/*X.RDB$PACKAGE_NAME.NULL*/
						     isc_792.isc_822)
						{
							prefixLen = strlen(/*X.RDB$PACKAGE_NAME*/
									   isc_792.isc_801);
							memcpy(temp, /*X.RDB$PACKAGE_NAME*/
								     isc_792.isc_801, prefixLen);
							temp[prefixLen++] = '.';
						}

						l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
							     isc_792.isc_793);
						MISC_terminate(/*X.RDB$FUNCTION_NAME*/
							       isc_792.isc_793, temp + prefixLen, l,
							sizeof(temp) - prefixLen);

						// msg 119 restoring argument for function %s
						BURP_verbose(119, temp);
					}
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_792.isc_806 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_passing_mechanism:
					/*X.RDB$MECHANISM*/
					isc_792.isc_805 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_792.isc_804 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_792.isc_803 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_792.isc_802 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_792.isc_827 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_792.isc_828 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_792.isc_825 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_792.isc_826 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_792.isc_823 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_792.isc_824 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_package_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$PACKAGE_NAME*/
							 isc_792.isc_801);
						/*X.RDB$PACKAGE_NAME.NULL*/
						isc_792.isc_822 = FALSE;
						fb_utils::exact_name(/*X.RDB$PACKAGE_NAME*/
								     isc_792.isc_801);
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_arg_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ARGUMENT_NAME*/
							 isc_792.isc_800);
						/*X.RDB$ARGUMENT_NAME.NULL*/
						isc_792.isc_821 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_field_source:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$FIELD_SOURCE*/
							 isc_792.isc_799);
						/*X.RDB$FIELD_SOURCE.NULL*/
						isc_792.isc_820 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_default_value:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_blr_blob(tdgbl, /*X.RDB$DEFAULT_VALUE*/
								    isc_792.isc_798, false);
						/*X.RDB$DEFAULT_VALUE.NULL*/
						isc_792.isc_819 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_default_source:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_source_blob(tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								       isc_792.isc_797, false);
						/*X.RDB$DEFAULT_SOURCE.NULL*/
						isc_792.isc_818 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_collation_id:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$COLLATION_ID*/
						isc_792.isc_817 = get_int32(tdgbl);
						/*X.RDB$COLLATION_ID.NULL*/
						isc_792.isc_816 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_null_flag:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$NULL_FLAG*/
						isc_792.isc_815 = get_int32(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_792.isc_814 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_type_mechanism:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$ARGUMENT_MECHANISM*/
						isc_792.isc_813 = get_int32(tdgbl);
						/*X.RDB$ARGUMENT_MECHANISM.NULL*/
						isc_792.isc_812 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_field_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$FIELD_NAME*/
							 isc_792.isc_796);
						/*X.RDB$FIELD_NAME.NULL*/
						isc_792.isc_811 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_relation_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$RELATION_NAME*/
							 isc_792.isc_795);
						/*X.RDB$RELATION_NAME.NULL*/
						isc_792.isc_810 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_description:
					if (tdgbl->RESTORE_format >= 10)
					{
						get_source_blob(tdgbl, /*X.RDB$DESCRIPTION*/
								       isc_792.isc_794, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_792.isc_809 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 270, &isc_792, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL10)
	{
		// with RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_777), (char*) isc_777);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_778.isc_789 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_778.isc_787 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_778.isc_785  = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_778.isc_779);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_778.isc_779, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_778.isc_784 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_passing_mechanism:
					/*X.RDB$MECHANISM*/
					isc_778.isc_783 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_778.isc_782 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_778.isc_781 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_778.isc_780 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_778.isc_789 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_778.isc_790 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_778.isc_787 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_778.isc_788 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_778.isc_785 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_778.isc_786 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_package_name:
				case att_functionarg_arg_name:
				case att_functionarg_field_source:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_default_value:
				case att_functionarg_default_source:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_collation_id:
				case att_functionarg_null_flag:
				case att_functionarg_type_mechanism:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_field_name:
				case att_functionarg_relation_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_description:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 54, &isc_778, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// without RDB$FIELD_PRECISION
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_function_arg_req_handle1)
			X IN RDB$FUNCTION_ARGUMENTS*/
		{
		
                if (!tdgbl->handles_get_function_arg_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (short) sizeof(isc_765), (char*) isc_765);
		if (tdgbl->handles_get_function_arg_req_handle1)
		   {
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_766.isc_775 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_766.isc_773 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_functionarg_name:
					l = GET_TEXT(/*X.RDB$FUNCTION_NAME*/
						     isc_766.isc_767);
					MISC_terminate (/*X.RDB$FUNCTION_NAME*/
							isc_766.isc_767, temp, l, sizeof(temp));
					BURP_verbose (119, temp);
					// msg 119 restoring argument for function %s
					break;

				case att_functionarg_position:
					/*X.RDB$ARGUMENT_POSITION*/
					isc_766.isc_772 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_passing_mechanism:
					/*X.RDB$MECHANISM*/
					isc_766.isc_771 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_766.isc_770 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_766.isc_769 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_766.isc_768 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_766.isc_775 = FALSE;
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_766.isc_776 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_766.isc_773 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_766.isc_774 = (USHORT) get_int32(tdgbl);
					break;

				case att_functionarg_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_package_name:
				case att_functionarg_arg_name:
				case att_functionarg_field_source:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_default_value:
				case att_functionarg_default_source:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_collation_id:
				case att_functionarg_null_flag:
				case att_functionarg_type_mechanism:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_field_name:
				case att_functionarg_relation_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				case att_functionarg_description:
					if (tdgbl->RESTORE_format >= 10)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 90);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 90);
					// msg 90 function argument
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_function_arg_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_766, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
}

bool get_generator(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Pick up a gen-id.  Like most things, there is ughly history.
 *	In the modern world, gen_id are free floating records.  In the
 *	bad old days they were attributes of relations.  Handle both
 *	nicely.
 *
 **************************************/
	SINT64 value = 0, initial_value = 0;

	/*BASED_ON RDB$GENERATORS.RDB$GENERATOR_NAME name*/
	char
	   name[32]
 = "";
	/*BASED_ON RDB$GENERATORS.RDB$SECURITY_CLASS secclass*/
	char
	   secclass[32]
 = "";
	/*BASED_ON RDB$GENERATORS.RDB$OWNER_NAME ownername*/
	char
	   ownername[32]
 = "";
	/*BASED_ON RDB$GENERATORS.RDB$GENERATOR_INCREMENT increment*/
	ISC_LONG
	   increment
 = 1;
	fb_sysflag sysFlag = fb_sysflag_user;
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	ISC_QUAD gen_desc = {0, 0};

	ISC_QUAD* descPtr = NULL;
	const char* secPtr = NULL;
	const char* ownerPtr = NULL;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_gen_generator:
			GET_TEXT(name);
			break;

		case att_gen_value:
			// IB v5 or earlier, gen_id value is an SLONG
			value = (SINT64) get_int32(tdgbl);
			break;

		case att_gen_value_int64:
			// IB v6 or later, gen_id value is an SINT64
			value = get_int64(tdgbl);
			break;

		case att_gen_description:
			if (tdgbl->RESTORE_format >= 7)
			{
				get_source_blob (tdgbl, gen_desc, false);
				if (gen_desc.gds_quad_high || gen_desc.gds_quad_low)
					descPtr = &gen_desc;
			}
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		case att_gen_sysflag:
			sysFlag = (fb_sysflag) get_int32(tdgbl);
			break;

		case att_gen_security_class:
			if (tdgbl->RESTORE_format >= 10)
			{
				GET_TEXT(secclass);
				secPtr = reinterpret_cast<const char*>(&secclass);
			}
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		case att_gen_owner_name:
			if (tdgbl->RESTORE_format >= 10)
			{
				GET_TEXT(ownername);
				ownerPtr = reinterpret_cast<const char*>(&ownername);
			}
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		case att_gen_init_val:
			if (tdgbl->RESTORE_format >= 10)
				initial_value = get_int64(tdgbl);
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		case att_gen_id_increment:
			if (tdgbl->RESTORE_format >= 10)
				increment = get_int32(tdgbl);
			else
				bad_attribute(scan_next_attr, attribute, 289);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 289);
			// msg 289 generator
			break;
		}
	}

	if (tdgbl->gbl_sw_meta)
	{
		value = 0;
	}

	store_blr_gen_id(tdgbl, name, value, initial_value, descPtr, secPtr, ownerPtr, sysFlag, increment);

	return true;
}

bool get_global_field(BurpGlobals* tdgbl)
{
   struct isc_599_struct {
          char  isc_600 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_601;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_602;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_603;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_604;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_605;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_606;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_607;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_608;	/* RDB$QUERY_HEADER */
          char  isc_609 [128];	/* RDB$EDIT_STRING */
          char  isc_610 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_611;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_612;	/* RDB$COMPUTED_BLR */
          short isc_613;	/* gds__null_flag */
          short isc_614;	/* RDB$FIELD_LENGTH */
          short isc_615;	/* RDB$FIELD_TYPE */
          short isc_616;	/* gds__null_flag */
          short isc_617;	/* gds__null_flag */
          short isc_618;	/* gds__null_flag */
          short isc_619;	/* gds__null_flag */
          short isc_620;	/* gds__null_flag */
          short isc_621;	/* gds__null_flag */
          short isc_622;	/* RDB$CHARACTER_LENGTH */
          short isc_623;	/* gds__null_flag */
          short isc_624;	/* gds__null_flag */
          short isc_625;	/* RDB$EXTERNAL_SCALE */
          short isc_626;	/* gds__null_flag */
          short isc_627;	/* RDB$EXTERNAL_TYPE */
          short isc_628;	/* gds__null_flag */
          short isc_629;	/* RDB$EXTERNAL_LENGTH */
          short isc_630;	/* gds__null_flag */
          short isc_631;	/* RDB$DIMENSIONS */
          short isc_632;	/* gds__null_flag */
          short isc_633;	/* gds__null_flag */
          short isc_634;	/* RDB$NULL_FLAG */
          short isc_635;	/* gds__null_flag */
          short isc_636;	/* RDB$SYSTEM_FLAG */
          short isc_637;	/* gds__null_flag */
          short isc_638;	/* gds__null_flag */
          short isc_639;	/* gds__null_flag */
          short isc_640;	/* gds__null_flag */
          short isc_641;	/* gds__null_flag */
          short isc_642;	/* gds__null_flag */
          short isc_643;	/* gds__null_flag */
          short isc_644;	/* gds__null_flag */
          short isc_645;	/* gds__null_flag */
          short isc_646;	/* RDB$FIELD_SUB_TYPE */
          short isc_647;	/* RDB$COLLATION_ID */
          short isc_648;	/* RDB$CHARACTER_SET_ID */
          short isc_649;	/* RDB$SEGMENT_LENGTH */
          short isc_650;	/* RDB$FIELD_SCALE */
   } isc_599;
   struct isc_652_struct {
          char  isc_653 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_654;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_655;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_656;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_657;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_658;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_659;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_660;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_661;	/* RDB$QUERY_HEADER */
          char  isc_662 [128];	/* RDB$EDIT_STRING */
          char  isc_663 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_664;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_665;	/* RDB$COMPUTED_BLR */
          short isc_666;	/* gds__null_flag */
          short isc_667;	/* RDB$FIELD_LENGTH */
          short isc_668;	/* RDB$FIELD_TYPE */
          short isc_669;	/* gds__null_flag */
          short isc_670;	/* RDB$FIELD_PRECISION */
          short isc_671;	/* gds__null_flag */
          short isc_672;	/* gds__null_flag */
          short isc_673;	/* gds__null_flag */
          short isc_674;	/* gds__null_flag */
          short isc_675;	/* gds__null_flag */
          short isc_676;	/* gds__null_flag */
          short isc_677;	/* RDB$CHARACTER_LENGTH */
          short isc_678;	/* gds__null_flag */
          short isc_679;	/* gds__null_flag */
          short isc_680;	/* RDB$EXTERNAL_SCALE */
          short isc_681;	/* gds__null_flag */
          short isc_682;	/* RDB$EXTERNAL_TYPE */
          short isc_683;	/* gds__null_flag */
          short isc_684;	/* RDB$EXTERNAL_LENGTH */
          short isc_685;	/* gds__null_flag */
          short isc_686;	/* RDB$DIMENSIONS */
          short isc_687;	/* gds__null_flag */
          short isc_688;	/* gds__null_flag */
          short isc_689;	/* RDB$NULL_FLAG */
          short isc_690;	/* gds__null_flag */
          short isc_691;	/* RDB$SYSTEM_FLAG */
          short isc_692;	/* gds__null_flag */
          short isc_693;	/* gds__null_flag */
          short isc_694;	/* gds__null_flag */
          short isc_695;	/* gds__null_flag */
          short isc_696;	/* gds__null_flag */
          short isc_697;	/* gds__null_flag */
          short isc_698;	/* gds__null_flag */
          short isc_699;	/* gds__null_flag */
          short isc_700;	/* gds__null_flag */
          short isc_701;	/* RDB$FIELD_SUB_TYPE */
          short isc_702;	/* RDB$COLLATION_ID */
          short isc_703;	/* RDB$CHARACTER_SET_ID */
          short isc_704;	/* RDB$SEGMENT_LENGTH */
          short isc_705;	/* RDB$FIELD_SCALE */
   } isc_652;
   struct isc_707_struct {
          char  isc_708 [32];	/* RDB$FIELD_NAME */
          char  isc_709 [32];	/* RDB$OWNER_NAME */
          char  isc_710 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_711;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_712;	/* RDB$MISSING_SOURCE */
          ISC_QUAD isc_713;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_714;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_715;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_716;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_717;	/* RDB$MISSING_VALUE */
          ISC_QUAD isc_718;	/* RDB$QUERY_HEADER */
          char  isc_719 [128];	/* RDB$EDIT_STRING */
          char  isc_720 [32];	/* RDB$QUERY_NAME */
          ISC_QUAD isc_721;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_722;	/* RDB$COMPUTED_BLR */
          short isc_723;	/* gds__null_flag */
          short isc_724;	/* RDB$FIELD_LENGTH */
          short isc_725;	/* RDB$FIELD_TYPE */
          short isc_726;	/* gds__null_flag */
          short isc_727;	/* gds__null_flag */
          short isc_728;	/* gds__null_flag */
          short isc_729;	/* RDB$FIELD_PRECISION */
          short isc_730;	/* gds__null_flag */
          short isc_731;	/* gds__null_flag */
          short isc_732;	/* gds__null_flag */
          short isc_733;	/* gds__null_flag */
          short isc_734;	/* gds__null_flag */
          short isc_735;	/* gds__null_flag */
          short isc_736;	/* RDB$CHARACTER_LENGTH */
          short isc_737;	/* gds__null_flag */
          short isc_738;	/* gds__null_flag */
          short isc_739;	/* RDB$EXTERNAL_SCALE */
          short isc_740;	/* gds__null_flag */
          short isc_741;	/* RDB$EXTERNAL_TYPE */
          short isc_742;	/* gds__null_flag */
          short isc_743;	/* RDB$EXTERNAL_LENGTH */
          short isc_744;	/* gds__null_flag */
          short isc_745;	/* RDB$DIMENSIONS */
          short isc_746;	/* gds__null_flag */
          short isc_747;	/* gds__null_flag */
          short isc_748;	/* RDB$NULL_FLAG */
          short isc_749;	/* gds__null_flag */
          short isc_750;	/* RDB$SYSTEM_FLAG */
          short isc_751;	/* gds__null_flag */
          short isc_752;	/* gds__null_flag */
          short isc_753;	/* gds__null_flag */
          short isc_754;	/* gds__null_flag */
          short isc_755;	/* gds__null_flag */
          short isc_756;	/* gds__null_flag */
          short isc_757;	/* gds__null_flag */
          short isc_758;	/* gds__null_flag */
          short isc_759;	/* gds__null_flag */
          short isc_760;	/* RDB$FIELD_SUB_TYPE */
          short isc_761;	/* RDB$COLLATION_ID */
          short isc_762;	/* RDB$CHARACTER_SET_ID */
          short isc_763;	/* RDB$SEGMENT_LENGTH */
          short isc_764;	/* RDB$FIELD_SCALE */
   } isc_707;
/**************************************
 *
 *	g e t _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a global field.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	gfld* gfield = NULL;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		GDS_NAME field_name;
		bool securityClass = false;

		// with rdb$field_precision, rdb$security_class and rdb$owner_name.
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_706), (char*) isc_706);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_707.isc_711 = isc_blob_null;
		   isc_707.isc_712 = isc_blob_null;
		   isc_707.isc_713 = isc_blob_null;
		   isc_707.isc_714 = isc_blob_null;
		   isc_707.isc_715 = isc_blob_null;
		   isc_707.isc_716 = isc_blob_null;
		   isc_707.isc_717 = isc_blob_null;
		   isc_707.isc_718 = isc_blob_null;
		   isc_707.isc_721 = isc_blob_null;
		   isc_707.isc_722 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_707.isc_764 = /*X.RDB$SEGMENT_LENGTH*/
   isc_707.isc_763 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_707.isc_762 = /*X.RDB$COLLATION_ID*/
   isc_707.isc_761 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_707.isc_760 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_707.isc_759 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_707.isc_758 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_707.isc_757 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_707.isc_756 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_707.isc_755 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_707.isc_754 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_707.isc_753 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_707.isc_752 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_707.isc_751 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_707.isc_750 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_707.isc_749 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_707.isc_747 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_707.isc_746 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_707.isc_744 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_707.isc_742 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_707.isc_740 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_707.isc_738 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_707.isc_737 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_707.isc_735 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_707.isc_734 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_707.isc_733 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_707.isc_732 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_707.isc_731 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_707.isc_730 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_707.isc_728 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_707.isc_727 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_707.isc_726 = TRUE;
			memset(/*X.RDB$QUERY_NAME*/
			       isc_707.isc_720, ' ', sizeof(/*X.RDB$QUERY_NAME*/
	      isc_707.isc_720));

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_707.isc_708);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_707.isc_708, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_707.isc_720);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_707.isc_757 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_707.isc_719);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_707.isc_756 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_707.isc_755 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_707.isc_718, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_707.isc_725 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_707.isc_724 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_707.isc_764 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_707.isc_723 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_707.isc_760 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_707.isc_732 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_707.isc_763 = (USHORT) get_int32(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_707.isc_763)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_707.isc_737 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_707.isc_759 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_707.isc_722, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_707.isc_758 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_707.isc_721, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_707.isc_758 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_707.isc_721, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_707.isc_752 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_707.isc_715, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_707.isc_751 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_707.isc_714, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_707.isc_751 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_707.isc_714, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_707.isc_754 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_707.isc_717, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_707.isc_753 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_707.isc_716, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_707.isc_750 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_707.isc_749 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_int32(tdgbl); // skip
					}
					else
					{
						/*X.RDB$NULL_FLAG*/
						isc_707.isc_748 = (USHORT) get_int32(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_707.isc_747 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_707.isc_746 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_707.isc_713, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_707.isc_746 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_707.isc_713, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_707.isc_742 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_707.isc_743 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_707.isc_738 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_707.isc_739 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_707.isc_740 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_707.isc_741 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_707.isc_744 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_707.isc_745 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_707.isc_735 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_707.isc_736 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_707.isc_733 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_707.isc_711, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_707.isc_734 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_707.isc_712, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_707.isc_731 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_707.isc_762 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_707.isc_730 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_707.isc_761 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_707.isc_728 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_707.isc_729 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				case att_field_security_class:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$SECURITY_CLASS*/
							 isc_707.isc_710);
						/*X.RDB$SECURITY_CLASS.NULL*/
						isc_707.isc_727 = FALSE;
						securityClass = true;
					}
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				case att_field_owner_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$OWNER_NAME*/
							 isc_707.isc_709);
						/*X.RDB$OWNER_NAME.NULL*/
						isc_707.isc_726 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_707.isc_725 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_707.isc_725];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_707.isc_724 = l;
			}

			strcpy(field_name, /*X.RDB$FIELD_NAME*/
					   isc_707.isc_708);

			if (gfield)
				strcpy(gfield->gfld_name, field_name);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_707.isc_731 && /*X.RDB$CHARACTER_SET_ID*/
    isc_707.isc_762 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_707.isc_735 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_707.isc_725 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_707.isc_725 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_707.isc_725 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_707.isc_725 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_707.isc_736 = /*X.RDB$FIELD_LENGTH*/
   isc_707.isc_724;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_707.isc_762 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_707.isc_761 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 420, &isc_707, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (!securityClass)
			collect_missing_privs(tdgbl, obj_field, field_name);
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL10)
	{
		// with rdb$field_precision
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_651), (char*) isc_651);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_652.isc_654 = isc_blob_null;
		   isc_652.isc_655 = isc_blob_null;
		   isc_652.isc_656 = isc_blob_null;
		   isc_652.isc_657 = isc_blob_null;
		   isc_652.isc_658 = isc_blob_null;
		   isc_652.isc_659 = isc_blob_null;
		   isc_652.isc_660 = isc_blob_null;
		   isc_652.isc_661 = isc_blob_null;
		   isc_652.isc_664 = isc_blob_null;
		   isc_652.isc_665 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_652.isc_705 = /*X.RDB$SEGMENT_LENGTH*/
   isc_652.isc_704 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_652.isc_703 = /*X.RDB$COLLATION_ID*/
   isc_652.isc_702 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_652.isc_701 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_652.isc_700 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_652.isc_699 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_652.isc_698 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_652.isc_697 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_652.isc_696 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_652.isc_695 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_652.isc_694 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_652.isc_693 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_652.isc_692 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_652.isc_691 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_652.isc_690 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_652.isc_688 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_652.isc_687 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_652.isc_685 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_652.isc_683 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_652.isc_681 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_652.isc_679 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_652.isc_678 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_652.isc_676 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_652.isc_675 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_652.isc_674 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_652.isc_673 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_652.isc_672 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_652.isc_671 = TRUE;
			/*X.RDB$FIELD_PRECISION.NULL*/
			isc_652.isc_669 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_652.isc_653);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_652.isc_653, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_652.isc_663);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_652.isc_698 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_652.isc_662);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_652.isc_697 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_652.isc_696 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_652.isc_661, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_652.isc_668 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_652.isc_667 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_652.isc_705 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_652.isc_666 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_652.isc_701 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_652.isc_673 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_652.isc_704 = (USHORT) get_int32(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_652.isc_704)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_652.isc_678 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_652.isc_700 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_652.isc_665, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_652.isc_699 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_652.isc_664, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_652.isc_699 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_652.isc_664, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_652.isc_693 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_652.isc_658, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_652.isc_692 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_652.isc_657, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_652.isc_692 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_652.isc_657, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_652.isc_695 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_652.isc_660, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_652.isc_694 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_652.isc_659, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_652.isc_691 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_652.isc_690 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_int32(tdgbl); // skip
					}
					else
					{
						/*X.RDB$NULL_FLAG*/
						isc_652.isc_689 = (USHORT) get_int32(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_652.isc_688 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_652.isc_687 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_652.isc_656, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_652.isc_687 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_652.isc_656, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_652.isc_683 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_652.isc_684 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_652.isc_679 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_652.isc_680 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_652.isc_681 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_652.isc_682 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_652.isc_685 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_652.isc_686 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_652.isc_676 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_652.isc_677 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_652.isc_674 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_652.isc_654, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_652.isc_675 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_652.isc_655, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_652.isc_672 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_652.isc_703 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_652.isc_671 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_652.isc_702 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
					{
						/*X.RDB$FIELD_PRECISION.NULL*/
						isc_652.isc_669 = FALSE;
						/*X.RDB$FIELD_PRECISION*/
						isc_652.isc_670 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				case att_field_security_class:
				case att_field_owner_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_652.isc_668 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_652.isc_668];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_652.isc_667 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_652.isc_653);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_652.isc_672 && /*X.RDB$CHARACTER_SET_ID*/
    isc_652.isc_703 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_652.isc_676 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_652.isc_668 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_652.isc_668 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_652.isc_668 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_652.isc_668 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_652.isc_677 = /*X.RDB$FIELD_LENGTH*/
   isc_652.isc_667;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_652.isc_703 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_652.isc_702 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 352, &isc_652, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}
	else // runtimeODS < DB_VERSION_DDL10
	{
		// without rdb$field_precision

		/*STORE (REQUEST_HANDLE tdgbl->handles_get_global_field_req_handle1)
			X IN RDB$FIELDS*/
		{
		
                if (!tdgbl->handles_get_global_field_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (short) sizeof(isc_598), (char*) isc_598);
		if (tdgbl->handles_get_global_field_req_handle1)
		   {
		   isc_599.isc_601 = isc_blob_null;
		   isc_599.isc_602 = isc_blob_null;
		   isc_599.isc_603 = isc_blob_null;
		   isc_599.isc_604 = isc_blob_null;
		   isc_599.isc_605 = isc_blob_null;
		   isc_599.isc_606 = isc_blob_null;
		   isc_599.isc_607 = isc_blob_null;
		   isc_599.isc_608 = isc_blob_null;
		   isc_599.isc_611 = isc_blob_null;
		   isc_599.isc_612 = isc_blob_null;

			/*X.RDB$FIELD_SCALE*/
			isc_599.isc_650 = /*X.RDB$SEGMENT_LENGTH*/
   isc_599.isc_649 = 0;
			/*X.RDB$CHARACTER_SET_ID*/
			isc_599.isc_648 = /*X.RDB$COLLATION_ID*/
   isc_599.isc_647 = 0;
			/*X.RDB$FIELD_SUB_TYPE*/
			isc_599.isc_646 = 0;
			/*X.RDB$COMPUTED_BLR.NULL*/
			isc_599.isc_645 = TRUE;
			/*X.RDB$COMPUTED_SOURCE.NULL*/
			isc_599.isc_644 = TRUE;
			/*X.RDB$QUERY_NAME.NULL*/
			isc_599.isc_643 = TRUE;
			/*X.RDB$EDIT_STRING.NULL*/
			isc_599.isc_642 = TRUE;
			/*X.RDB$QUERY_HEADER.NULL*/
			isc_599.isc_641 = TRUE;
			/*X.RDB$MISSING_VALUE.NULL*/
			isc_599.isc_640 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_599.isc_639 = TRUE;
			/*X.RDB$VALIDATION_BLR.NULL*/
			isc_599.isc_638 = TRUE;
			/*X.RDB$VALIDATION_SOURCE.NULL*/
			isc_599.isc_637 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_599.isc_636 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_599.isc_635 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_599.isc_633 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_599.isc_632 = TRUE;
			/*X.RDB$DIMENSIONS.NULL*/
			isc_599.isc_630 = TRUE;
			/*X.RDB$EXTERNAL_LENGTH.NULL*/
			isc_599.isc_628 = TRUE;
			/*X.RDB$EXTERNAL_TYPE.NULL*/
			isc_599.isc_626 = TRUE;
			/*X.RDB$EXTERNAL_SCALE.NULL*/
			isc_599.isc_624 = TRUE;
			/*X.RDB$SEGMENT_LENGTH.NULL*/
			isc_599.isc_623 = TRUE;
			/*X.RDB$CHARACTER_LENGTH.NULL*/
			isc_599.isc_621 = TRUE;
			/*X.RDB$MISSING_SOURCE.NULL*/
			isc_599.isc_620 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_599.isc_619 = TRUE;
			/*X.RDB$FIELD_SUB_TYPE.NULL*/
			isc_599.isc_618 = TRUE;
			/*X.RDB$CHARACTER_SET_ID.NULL*/
			isc_599.isc_617 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_599.isc_616 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_field_name:
					l = GET_TEXT(/*X.RDB$FIELD_NAME*/
						     isc_599.isc_600);
					MISC_terminate (/*X.RDB$FIELD_NAME*/
							isc_599.isc_600, temp, l, sizeof(temp));
					BURP_verbose (121, temp);
					// msg 121  restoring global field %s
					break;

				case att_field_query_name:
					GET_TEXT(/*X.RDB$QUERY_NAME*/
						 isc_599.isc_610);
					/*X.RDB$QUERY_NAME.NULL*/
					isc_599.isc_643 = FALSE;
					break;

				case att_field_edit_string:
					GET_TEXT(/*X.RDB$EDIT_STRING*/
						 isc_599.isc_609);
					/*X.RDB$EDIT_STRING.NULL*/
					isc_599.isc_642 = FALSE;
					break;

				case att_field_query_header:
					/*X.RDB$QUERY_HEADER.NULL*/
					isc_599.isc_641 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$QUERY_HEADER*/
								isc_599.isc_608, false);
					break;

				case att_field_type:
					/*X.RDB$FIELD_TYPE*/
					isc_599.isc_615 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_length:
					/*X.RDB$FIELD_LENGTH*/
					isc_599.isc_614 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_scale:
					/*X.RDB$FIELD_SCALE*/
					isc_599.isc_650 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SCALE.NULL*/
					isc_599.isc_613 = FALSE;
					break;

				case att_field_sub_type:
					/*X.RDB$FIELD_SUB_TYPE*/
					isc_599.isc_646 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FIELD_SUB_TYPE.NULL*/
					isc_599.isc_618 = FALSE;
					break;

				case att_field_segment_length:
					/*X.RDB$SEGMENT_LENGTH*/
					isc_599.isc_649 = (USHORT) get_int32(tdgbl);
					if (/*X.RDB$SEGMENT_LENGTH*/
					    isc_599.isc_649)
						/*X.RDB$SEGMENT_LENGTH.NULL*/
						isc_599.isc_623 = FALSE;
					break;

				case att_field_computed_blr:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_blr_blob (tdgbl, gfield->gfld_computed_blr, true);
						gfield->gfld_flags |= GFLD_computed_blr;
					}
					else
					{
						/*X.RDB$COMPUTED_BLR.NULL*/
						isc_599.isc_645 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$COMPUTED_BLR*/
								     isc_599.isc_612, false);
					}
					break;

				case att_field_computed_source:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_misc_blob (tdgbl, gfield->gfld_computed_source, true);
						gfield->gfld_flags |= GFLD_computed_source;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_599.isc_644 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
								      isc_599.isc_611, false);
					}
					break;

				case att_field_computed_source2:
					// if we are going against a V4.0 database,
					// restore the global fields in 2 phases.

					if (tdgbl->global_trans)
					{
						if (!gfield)
							gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

						get_source_blob (tdgbl, gfield->gfld_computed_source2, true);
						gfield->gfld_flags |= GFLD_computed_source2;
					}
					else
					{
						/*X.RDB$COMPUTED_SOURCE.NULL*/
						isc_599.isc_644 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$COMPUTED_SOURCE*/
									isc_599.isc_611, false);
					}
					break;

				case att_field_validation_blr:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_blr_blob (tdgbl, gfield->gfld_vb, true);
							gfield->gfld_flags |= GFLD_validation_blr;
						}
						else
						{
							/*X.RDB$VALIDATION_BLR.NULL*/
							isc_599.isc_638 = FALSE;
							get_blr_blob (tdgbl, /*X.RDB$VALIDATION_BLR*/
									     isc_599.isc_605, false);
						}
					}
					break;

				case att_field_validation_source:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_misc_blob (tdgbl, gfield->gfld_vs, true);
							gfield->gfld_flags |= GFLD_validation_source;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_599.isc_637 = FALSE;
							get_misc_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
									      isc_599.isc_604, false);
						}
					}
					break;

				case att_field_validation_source2:
					if (tdgbl->gbl_sw_novalidity)
						eat_blob(tdgbl);
					else
					{
						// if we are going against a V4.0 database,
						// restore the global fields in 2 phases.

						if (tdgbl->global_trans)
						{
							if (!gfield)
								gfield = (gfld*) BURP_alloc_zero(sizeof(gfld));

							get_source_blob (tdgbl, gfield->gfld_vs2, true);
							gfield->gfld_flags |= GFLD_validation_source2;
						}
						else
						{
							/*X.RDB$VALIDATION_SOURCE.NULL*/
							isc_599.isc_637 = FALSE;
							get_source_blob (tdgbl, /*X.RDB$VALIDATION_SOURCE*/
										isc_599.isc_604, false);
						}
					}
					break;

				case att_field_missing_value:
					/*X.RDB$MISSING_VALUE.NULL*/
					isc_599.isc_640 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$MISSING_VALUE*/
							     isc_599.isc_607, false);
					break;

				case att_field_default_value:
					/*X.RDB$DEFAULT_VALUE.NULL*/
					isc_599.isc_639 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
							     isc_599.isc_606, false);
					break;

				case att_field_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_599.isc_636 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_599.isc_635 = FALSE;
					break;

				case att_field_null_flag:
					if (tdgbl->gbl_sw_novalidity) {
						get_int32(tdgbl); // skip
					}
					else
					{
						/*X.RDB$NULL_FLAG*/
						isc_599.isc_634 = (USHORT) get_int32(tdgbl);
						/*X.RDB$NULL_FLAG.NULL*/
						isc_599.isc_633 = FALSE;
					}
					break;

				case att_field_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_599.isc_632 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_599.isc_603, false);
					break;

				case att_field_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_599.isc_632 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_599.isc_603, false);
					break;

				case att_field_external_length:
					/*X.RDB$EXTERNAL_LENGTH.NULL*/
					isc_599.isc_628 = FALSE;
					/*X.RDB$EXTERNAL_LENGTH*/
					isc_599.isc_629 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_scale:
					/*X.RDB$EXTERNAL_SCALE.NULL*/
					isc_599.isc_624 = FALSE;
					/*X.RDB$EXTERNAL_SCALE*/
					isc_599.isc_625 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_external_type:
					/*X.RDB$EXTERNAL_TYPE.NULL*/
					isc_599.isc_626 = FALSE;
					/*X.RDB$EXTERNAL_TYPE*/
					isc_599.isc_627 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_dimensions:
					/*X.RDB$DIMENSIONS.NULL*/
					isc_599.isc_630 = FALSE;
					/*X.RDB$DIMENSIONS*/
					isc_599.isc_631 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_character_length:
					/*X.RDB$CHARACTER_LENGTH.NULL*/
					isc_599.isc_621 = FALSE;
					/*X.RDB$CHARACTER_LENGTH*/
					isc_599.isc_622 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_default_source:
					/*X.RDB$DEFAULT_SOURCE.NULL*/
					isc_599.isc_619 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
								isc_599.isc_601, false);
					break;

				case att_field_missing_source:
					/*X.RDB$MISSING_SOURCE.NULL*/
					isc_599.isc_620 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$MISSING_SOURCE*/
								isc_599.isc_602, false);
					break;

				case att_field_character_set:
					/*X.RDB$CHARACTER_SET_ID.NULL*/
					isc_599.isc_617 = FALSE;
					/*X.RDB$CHARACTER_SET_ID*/
					isc_599.isc_648 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_collation_id:
					/*X.RDB$COLLATION_ID.NULL*/
					isc_599.isc_616 = FALSE;
					/*X.RDB$COLLATION_ID*/
					isc_599.isc_647 = (USHORT) get_int32(tdgbl);
					break;

				case att_field_precision:
					if (tdgbl->RESTORE_format >= 6)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				case att_field_security_class:
				case att_field_owner_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 92);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 92);
					// msg 92  domain
					break;
				}
			}

			if (/*X.RDB$FIELD_TYPE*/
			    isc_599.isc_615 <= DTYPE_BLR_MAX)
			{
				l = gds_cvt_blr_dtype[/*X.RDB$FIELD_TYPE*/
						      isc_599.isc_615];
				if (l = type_lengths[l])
					/*X.RDB$FIELD_LENGTH*/
					isc_599.isc_614 = l;
			}

			if (gfield)
				strcpy (gfield->gfld_name, /*X.RDB$FIELD_NAME*/
							   isc_599.isc_600);

			if (tdgbl->gbl_sw_fix_fss_data && tdgbl->gbl_sw_fix_fss_data_id == 0 &&
				!/*X.RDB$CHARACTER_SET_ID.NULL*/
				 isc_599.isc_617 && /*X.RDB$CHARACTER_SET_ID*/
    isc_599.isc_648 == CS_UNICODE_FSS &&
				((!/*X.RDB$CHARACTER_LENGTH.NULL*/
				   isc_599.isc_621 &&
					(/*X.RDB$FIELD_TYPE*/
					 isc_599.isc_615 == blr_text || /*X.RDB$FIELD_TYPE*/
		isc_599.isc_615 == blr_varying)) ||
				 /*X.RDB$FIELD_TYPE*/
				 isc_599.isc_615 == blr_blob))
			{
				if (/*X.RDB$FIELD_TYPE*/
				    isc_599.isc_615 != blr_blob)
					/*X.RDB$CHARACTER_LENGTH*/
					isc_599.isc_622 = /*X.RDB$FIELD_LENGTH*/
   isc_599.isc_614;

				/*X.RDB$CHARACTER_SET_ID*/
				isc_599.isc_648 = CS_NONE;
				/*X.RDB$COLLATION_ID*/
				isc_599.isc_647 = 0;
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_global_field_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 348, &isc_599, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	}

	if (gfield)
	{
		gfield->gfld_next = tdgbl->gbl_global_fields;
		tdgbl->gbl_global_fields = gfield;
	}

	return true;
}

bool get_index(BurpGlobals* tdgbl, const burp_rel* relation)
{
   struct isc_566_struct {
          short isc_567;	/* isc_utility */
   } isc_566;
   struct isc_564_struct {
          short isc_565;	/* isc_utility */
   } isc_564;
   struct isc_562_struct {
          short isc_563;	/* isc_utility */
   } isc_562;
   struct isc_560_struct {
          char  isc_561 [32];	/* RDB$INDEX_NAME */
   } isc_560;
   struct isc_572_struct {
          short isc_573;	/* isc_utility */
   } isc_572;
   struct isc_569_struct {
          char  isc_570 [32];	/* RDB$RELATION_NAME */
          char  isc_571 [32];	/* RDB$INDEX_NAME */
   } isc_569;
   struct isc_575_struct {
          char  isc_576 [32];	/* RDB$INDEX_NAME */
          char  isc_577 [32];	/* RDB$FIELD_NAME */
          short isc_578;	/* RDB$FIELD_POSITION */
   } isc_575;
   struct isc_580_struct {
          char  isc_581 [32];	/* RDB$INDEX_NAME */
          ISC_QUAD isc_582;	/* RDB$EXPRESSION_BLR */
          ISC_QUAD isc_583;	/* RDB$EXPRESSION_SOURCE */
          char  isc_584 [32];	/* RDB$FOREIGN_KEY */
          ISC_QUAD isc_585;	/* RDB$DESCRIPTION */
          char  isc_586 [32];	/* RDB$RELATION_NAME */
          short isc_587;	/* RDB$SEGMENT_COUNT */
          short isc_588;	/* gds__null_flag */
          short isc_589;	/* RDB$SYSTEM_FLAG */
          short isc_590;	/* gds__null_flag */
          short isc_591;	/* gds__null_flag */
          short isc_592;	/* gds__null_flag */
          short isc_593;	/* gds__null_flag */
          short isc_594;	/* gds__null_flag */
          short isc_595;	/* RDB$INDEX_TYPE */
          short isc_596;	/* RDB$INDEX_INACTIVE */
          short isc_597;	/* RDB$UNIQUE_FLAG */
   } isc_580;
/**************************************
 *
 *	g e t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Build an index.  At the end stop
 *	and check that all fields are defined.
 *	If any fields are missing, delete the
 *	index.
 *
 **************************************/
	/*BASED_ON RDB$INDICES.RDB$INDEX_NAME index_name;*/
	char
	   index_name[32];

	att_type	attribute;
	bool		foreign_index = false;
	scan_attr_t		scan_next_attr;

	SSHORT count = 0, segments = 0;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle1)
		X IN RDB$INDICES*/
	{
	
        if (!tdgbl->handles_get_index_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (short) sizeof(isc_579), (char*) isc_579);
	if (tdgbl->handles_get_index_req_handle1)
	   {
	   isc_580.isc_582 = isc_blob_null;
	   isc_580.isc_583 = isc_blob_null;
	   isc_580.isc_585 = isc_blob_null;
		strcpy (/*X.RDB$RELATION_NAME*/
			isc_580.isc_586, relation->rel_name);
		/*X.RDB$UNIQUE_FLAG*/
		isc_580.isc_597 = 0;
		if (!tdgbl->gbl_sw_deactivate_indexes)
			/*X.RDB$INDEX_INACTIVE*/
			isc_580.isc_596 = FALSE;
		else
			/*X.RDB$INDEX_INACTIVE*/
			isc_580.isc_596 = TRUE;
		/*X.RDB$INDEX_TYPE.NULL*/
		isc_580.isc_594 = TRUE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_580.isc_593 = TRUE;
		/*X.RDB$FOREIGN_KEY.NULL*/
		isc_580.isc_592 = TRUE;
		/*X.RDB$EXPRESSION_SOURCE.NULL*/
		isc_580.isc_591 = TRUE;
		/*X.RDB$EXPRESSION_BLR.NULL*/
		isc_580.isc_590 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_580.isc_589 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_580.isc_588 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_index_name:
				GET_TEXT(/*X.RDB$INDEX_NAME*/
					 isc_580.isc_581);
				strcpy (index_name, /*X.RDB$INDEX_NAME*/
						    isc_580.isc_581);
				BURP_verbose (122, /*X.RDB$INDEX_NAME*/
						   isc_580.isc_581);
				break;

			case att_segment_count:
				/*X.RDB$SEGMENT_COUNT*/
				isc_580.isc_587 = segments = (USHORT) get_int32(tdgbl);
				break;

			case att_index_unique_flag:
				/*X.RDB$UNIQUE_FLAG*/
				isc_580.isc_597 = (USHORT) get_int32(tdgbl);
				break;

			case att_index_inactive:
				/*X.RDB$INDEX_INACTIVE*/
				isc_580.isc_596 = (USHORT) get_int32(tdgbl);
				// Defer foreign key index activation
				// Modified by Toni Martir, all index deferred when verbose
				if (tdgbl->gbl_sw_verbose)
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_580.isc_596)
						/*X.RDB$INDEX_INACTIVE*/
						isc_580.isc_596 = DEFERRED_ACTIVE;
				}
				else
				{
					if (!/*X.RDB$INDEX_INACTIVE*/
					     isc_580.isc_596 && foreign_index)
						/*X.RDB$INDEX_INACTIVE*/
						isc_580.isc_596 = DEFERRED_ACTIVE;
				}
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_580.isc_596 = TRUE;
				break;

			case att_index_type:
				/*X.RDB$INDEX_TYPE.NULL*/
				isc_580.isc_594 = FALSE;
				/*X.RDB$INDEX_TYPE*/
				isc_580.isc_595 = (USHORT) get_int32(tdgbl);
				break;

			case att_index_field_name:
				/*STORE (REQUEST_HANDLE tdgbl->handles_get_index_req_handle2)
					Y IN RDB$INDEX_SEGMENTS*/
				{
				
                                if (!tdgbl->handles_get_index_req_handle2)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (short) sizeof(isc_574), (char*) isc_574);
				if (tdgbl->handles_get_index_req_handle2)
				   {
					GET_TEXT(/*Y.RDB$FIELD_NAME*/
						 isc_575.isc_577);
					strcpy (/*Y.RDB$INDEX_NAME*/
						isc_575.isc_576, /*X.RDB$INDEX_NAME*/
  isc_580.isc_581);
					/*Y.RDB$FIELD_POSITION*/
					isc_575.isc_578 = count++;
				/*END_STORE;*/
				   
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 66, &isc_575, (short) 0);
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				break;

			case att_index_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_580.isc_593 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_580.isc_585, false);
				break;

			case att_index_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_580.isc_593 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_580.isc_585, false);
				break;

			case att_index_expression_source:
				/*X.RDB$EXPRESSION_SOURCE.NULL*/
				isc_580.isc_591 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$EXPRESSION_SOURCE*/
							isc_580.isc_583, false);
				break;

			case att_index_expression_blr:
				/*X.RDB$EXPRESSION_BLR.NULL*/
				isc_580.isc_590 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$EXPRESSION_BLR*/
						     isc_580.isc_582, false);
				break;

			case att_index_foreign_key:
				foreign_index = true;
				// Defer foreign key index activation
				if (!/*X.RDB$INDEX_INACTIVE*/
				     isc_580.isc_596)
					/*X.RDB$INDEX_INACTIVE*/
					isc_580.isc_596 = DEFERRED_ACTIVE;
				if (tdgbl->gbl_sw_deactivate_indexes)
					/*X.RDB$INDEX_INACTIVE*/
					isc_580.isc_596 = TRUE;
				/*X.RDB$FOREIGN_KEY.NULL*/
				isc_580.isc_592 = FALSE;
				GET_TEXT(/*X.RDB$FOREIGN_KEY*/
					 isc_580.isc_584);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 93);
				// msg 93 index
				break;
			}
		}

		count = 0;
		/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle3)
			RFR IN RDB$RELATION_FIELDS CROSS I_S IN RDB$INDEX_SEGMENTS
			OVER RDB$FIELD_NAME WITH I_S.RDB$INDEX_NAME = index_name AND
			RFR.RDB$RELATION_NAME = relation->rel_name*/
		{
                if (!tdgbl->handles_get_index_req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) sizeof(isc_568), (char*) isc_568);
		isc_vtov ((const char*) relation->rel_name, (char*) isc_569.isc_570, 32);
		isc_vtov ((const char*) index_name, (char*) isc_569.isc_571, 32);
		if (tdgbl->handles_get_index_req_handle3)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_569, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle3, (short) 1, (short) 2, &isc_572, (short) 0);
		   if (!isc_572.isc_573 || isc_status [1]) break;
			count++;
		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (count != segments)
		{
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_index_req_handle4)
				I_S IN RDB$INDEX_SEGMENTS WITH I_S.RDB$INDEX_NAME = index_name*/
			{
                        if (!tdgbl->handles_get_index_req_handle4)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) sizeof(isc_559), (char*) isc_559);
			isc_vtov ((const char*) index_name, (char*) isc_560.isc_561, 32);
			if (tdgbl->handles_get_index_req_handle4)
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_560, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 1, (short) 2, &isc_562, (short) 0);
			   if (!isc_562.isc_563 || isc_status [1]) break;
				/*ERASE I_S;*/
				{
                                isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 2, (short) 2, &isc_564, (short) 0);
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle4, (short) 3, (short) 2, &isc_566, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			return false;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_index_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 142, &isc_580, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_misc_blob(BurpGlobals* tdgbl, ISC_QUAD& blob_id, bool glb_trans)
{
/**************************************
 *
 *	g e t _ m i s c _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read blob attributes and copy data from input file to nice,
 *	shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	const size_t length = get_int32(tdgbl);

	// Create new blob

	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	UserBlob blob(status_vector);
	if (!blob.create(DB, local_trans, blob_id))
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	if (length)
	{
		get_block(tdgbl, buffer, length);
	}

	if (!blob.putData(length, buffer))
	{
		BURP_error_redirect (status_vector, 38);
		// msg 38 isc_put_segment failed
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

SLONG get_int32(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ i n t 3 2
 *
 **************************************
 *
 * Functional description
 *	Get a 32-bit numeric value from the input stream.
 *
 **************************************/
	SLONG	value[2];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert(sizeof(value) > sizeof(SLONG));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_vax_integer ((SCHAR *) value, length);
}

SINT64 get_int64(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ i n t 6 4
 *
 **************************************
 *
 * Functional description
 *	Get a possibly-64-bit numeric value from the input stream.
 *
 **************************************/
	SLONG	value[4];

	// get_text needs additional space for the terminator,
	// because it treats everything as strings.
	fb_assert (sizeof(value) > sizeof(SINT64));

	const SSHORT length = get_text(tdgbl, (TEXT*) value, sizeof(value));

	return isc_portable_integer ((UCHAR *) value, length);
}

bool get_package(BurpGlobals* tdgbl)
{
   struct isc_545_struct {
          char  isc_546 [32];	/* RDB$PACKAGE_NAME */
          ISC_QUAD isc_547;	/* RDB$DESCRIPTION */
          char  isc_548 [32];	/* RDB$OWNER_NAME */
          char  isc_549 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_550;	/* RDB$PACKAGE_BODY_SOURCE */
          ISC_QUAD isc_551;	/* RDB$PACKAGE_HEADER_SOURCE */
          short isc_552;	/* gds__null_flag */
          short isc_553;	/* gds__null_flag */
          short isc_554;	/* RDB$SYSTEM_FLAG */
          short isc_555;	/* gds__null_flag */
          short isc_556;	/* gds__null_flag */
          short isc_557;	/* gds__null_flag */
          short isc_558;	/* gds__null_flag */
   } isc_545;
/**************************************
 *
 *	g e t _ p a c k a g e
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a package.
 *
 **************************************/
	att_type attribute;
	TEXT temp[GDS_NAME_LEN];
	SSHORT len;
	scan_attr_t scan_next_attr;

	if (tdgbl->RESTORE_format < 10)
		return false;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	burp_pkg* package = (burp_pkg*) BURP_alloc_zero(sizeof(burp_pkg));
	package->pkg_next = tdgbl->packages;
	tdgbl->packages = package;

	/*STORE (TRANSACTION_HANDLE local_trans REQUEST_HANDLE tdgbl->handles_get_package_req_handle1)
		X IN RDB$PACKAGES*/
	{
	
        if (!tdgbl->handles_get_package_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_package_req_handle1, (short) sizeof(isc_544), (char*) isc_544);
	if (tdgbl->handles_get_package_req_handle1)
	   {
	   isc_545.isc_547 = isc_blob_null;
	   isc_545.isc_550 = isc_blob_null;
	   isc_545.isc_551 = isc_blob_null;
	{
		/*X.RDB$PACKAGE_HEADER_SOURCE.NULL*/
		isc_545.isc_558 = TRUE;
		/*X.RDB$PACKAGE_BODY_SOURCE.NULL*/
		isc_545.isc_557 = TRUE;
		/*X.RDB$SECURITY_CLASS.NULL*/
		isc_545.isc_556 = TRUE;
		/*X.RDB$OWNER_NAME.NULL*/
		isc_545.isc_555 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_545.isc_554 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_545.isc_553 = FALSE;
		/*X.RDB$DESCRIPTION.NULL*/
		isc_545.isc_552 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_package_name:
				len = GET_TEXT(/*X.RDB$PACKAGE_NAME*/
					       isc_545.isc_546);
				strcpy(package->pkg_name, /*X.RDB$PACKAGE_NAME*/
							  isc_545.isc_546);
				MISC_terminate(/*X.RDB$PACKAGE_NAME*/
					       isc_545.isc_546, temp, len, sizeof(temp));
				BURP_verbose(337, temp);	// msg 337 restoring package %s
				break;

			case att_package_header_source:
				get_source_blob(tdgbl, /*X.RDB$PACKAGE_HEADER_SOURCE*/
						       isc_545.isc_551, true);
				/*X.RDB$PACKAGE_HEADER_SOURCE.NULL*/
				isc_545.isc_558 = FALSE;
				break;

			case att_package_body_source:
				get_source_blob(tdgbl, /*X.RDB$PACKAGE_BODY_SOURCE*/
						       isc_545.isc_550, true);
				/*X.RDB$PACKAGE_BODY_SOURCE.NULL*/
				isc_545.isc_557 = FALSE;
				break;

			case att_package_security_class:
				GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					 isc_545.isc_549);
				if (strncmp(/*X.RDB$SECURITY_CLASS*/
					    isc_545.isc_549, SQL_SECCLASS_PREFIX, SQL_SECCLASS_PREFIX_LEN) != 0)
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_545.isc_556 = FALSE;
				break;

			case att_package_owner_name:
				GET_TEXT(package->pkg_owner);
				break;

			case att_package_description:
				get_source_blob(tdgbl, /*X.RDB$DESCRIPTION*/
						       isc_545.isc_547, true);
				/*X.RDB$DESCRIPTION.NULL*/
				isc_545.isc_552 = FALSE;
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 338);	// msg 338 package
				break;
			}
		}
	}
	/*END_STORE*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_package_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 134, &isc_545, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error();
	/*END_ERROR*/
	   }
	}

	return true;
}

bool get_procedure(BurpGlobals* tdgbl)
{
   struct isc_496_struct {
          ISC_QUAD isc_497;	/* RDB$PROCEDURE_BLR */
          char  isc_498 [32];	/* RDB$PROCEDURE_NAME */
          char  isc_499 [32];	/* RDB$OWNER_NAME */
          char  isc_500 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_501;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_502;	/* RDB$PROCEDURE_SOURCE */
          short isc_503;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_504;	/* gds__null_flag */
          short isc_505;	/* RDB$PROCEDURE_INPUTS */
          short isc_506;	/* gds__null_flag */
          short isc_507;	/* RDB$SYSTEM_FLAG */
          short isc_508;	/* gds__null_flag */
          short isc_509;	/* gds__null_flag */
          short isc_510;	/* gds__null_flag */
          short isc_511;	/* gds__null_flag */
   } isc_496;
   struct isc_513_struct {
          char  isc_514 [32];	/* RDB$PROCEDURE_NAME */
          char  isc_515 [32];	/* RDB$PACKAGE_NAME */
          char  isc_516 [256];	/* RDB$ENTRYPOINT */
          char  isc_517 [32];	/* RDB$ENGINE_NAME */
          ISC_QUAD isc_518;	/* RDB$PROCEDURE_BLR */
          ISC_QUAD isc_519;	/* RDB$DEBUG_INFO */
          char  isc_520 [32];	/* RDB$OWNER_NAME */
          char  isc_521 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_522;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_523;	/* RDB$PROCEDURE_SOURCE */
          short isc_524;	/* RDB$PROCEDURE_OUTPUTS */
          short isc_525;	/* gds__null_flag */
          short isc_526;	/* RDB$PROCEDURE_INPUTS */
          short isc_527;	/* gds__null_flag */
          short isc_528;	/* RDB$PRIVATE_FLAG */
          short isc_529;	/* gds__null_flag */
          short isc_530;	/* gds__null_flag */
          short isc_531;	/* gds__null_flag */
          short isc_532;	/* gds__null_flag */
          short isc_533;	/* gds__null_flag */
          short isc_534;	/* gds__null_flag */
          short isc_535;	/* RDB$VALID_BLR */
          short isc_536;	/* gds__null_flag */
          short isc_537;	/* RDB$SYSTEM_FLAG */
          short isc_538;	/* gds__null_flag */
          short isc_539;	/* RDB$PROCEDURE_TYPE */
          short isc_540;	/* gds__null_flag */
          short isc_541;	/* gds__null_flag */
          short isc_542;	/* gds__null_flag */
          short isc_543;	/* gds__null_flag */
   } isc_513;
/**************************************
 *
 *	g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *	Reconstruct a stored procedure.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	GDS_NAME	package_name = "";
	GDS_NAME	procedure_name = "";
	TEXT		temp[GDS_NAME_LEN * 2];
	SSHORT		l;
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	burp_prc* procedure = (burp_prc*) BURP_alloc_zero (sizeof(burp_prc));
	procedure->prc_next = tdgbl->procedures;
	tdgbl->procedures = procedure;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_512), (char*) isc_512);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_513.isc_518 = isc_blob_null;
		   isc_513.isc_519 = isc_blob_null;
		   isc_513.isc_522 = isc_blob_null;
		   isc_513.isc_523 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_513.isc_543 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_513.isc_542 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_513.isc_541 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_513.isc_540 = TRUE;
			/*X.RDB$PROCEDURE_TYPE.NULL*/
			isc_513.isc_538 = FALSE;
			/*X.RDB$PROCEDURE_TYPE*/
			isc_513.isc_539 = 0;
			/*X.RDB$SYSTEM_FLAG*/
			isc_513.isc_537 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_513.isc_536 = FALSE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_513.isc_534 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_513.isc_533 = TRUE;
			/*X.RDB$PROCEDURE_BLR.NULL*/
			isc_513.isc_532 = TRUE;
			/*X.RDB$ENGINE_NAME.NULL*/
			isc_513.isc_531 = TRUE;
			/*X.RDB$ENTRYPOINT.NULL*/
			isc_513.isc_530 = TRUE;
			/*X.RDB$PACKAGE_NAME.NULL*/
			isc_513.isc_529 = TRUE;
			/*X.RDB$PRIVATE_FLAG.NULL*/
			isc_513.isc_527 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					{
						SSHORT prefixLen = 0;
						if (package_name[0])
						{
							prefixLen = strlen(package_name);
							memcpy(temp, package_name, prefixLen);
							temp[prefixLen++] = '.';
						}

						l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
							     isc_513.isc_514);
						//procedure->prc_name_length = l;
						strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
									     isc_513.isc_514);

						MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
								isc_513.isc_514, temp + prefixLen, l,
							sizeof(temp) - prefixLen);
						BURP_verbose (195, temp);
						// msg 195 restoring stored procedure %s
					}
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_513.isc_522, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_513.isc_542 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_513.isc_522, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_513.isc_542 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_513.isc_523, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_513.isc_543 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_513.isc_523, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_513.isc_543 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_513.isc_518, true);
					/*X.RDB$PROCEDURE_BLR.NULL*/
					isc_513.isc_532 = FALSE;
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_513.isc_521);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_513.isc_521, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_513.isc_541 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_513.isc_526 = (USHORT) get_int32(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_513.isc_526 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_513.isc_525 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_513.isc_525 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_513.isc_524 = (USHORT) get_int32(tdgbl);
					break;

				case att_procedure_type:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PROCEDURE_TYPE*/
						isc_513.isc_539 = (USHORT) get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_513.isc_534 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_513.isc_535 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_513.isc_533 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_513.isc_519, true);
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_engine_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ENGINE_NAME*/
							 isc_513.isc_517);
						/*X.RDB$ENGINE_NAME.NULL*/
						isc_513.isc_531 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_entrypoint:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ENTRYPOINT*/
							 isc_513.isc_516);
						/*X.RDB$ENTRYPOINT.NULL*/
						isc_513.isc_530 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_package_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$PACKAGE_NAME*/
							 isc_513.isc_515);
						/*X.RDB$PACKAGE_NAME.NULL*/
						isc_513.isc_529 = FALSE;
						strcpy(procedure->prc_package, /*X.RDB$PACKAGE_NAME*/
									       isc_513.isc_515);
						strcpy(package_name, /*X.RDB$PACKAGE_NAME*/
								     isc_513.isc_515);
						fb_utils::exact_name(package_name);
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_private_flag:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$PRIVATE_FLAG*/
						isc_513.isc_528 = (USHORT) get_int32(tdgbl);
						/*X.RDB$PRIVATE_FLAG.NULL*/
						isc_513.isc_527 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_513.isc_514);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 488, &isc_513, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_req_handle1)
			X IN RDB$PROCEDURES*/
		{
		
                if (!tdgbl->handles_get_procedure_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (short) sizeof(isc_495), (char*) isc_495);
		if (tdgbl->handles_get_procedure_req_handle1)
		   {
		   isc_496.isc_497 = isc_blob_null;
		   isc_496.isc_501 = isc_blob_null;
		   isc_496.isc_502 = isc_blob_null;
			/*X.RDB$PROCEDURE_SOURCE.NULL*/
			isc_496.isc_511 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_496.isc_510 = TRUE;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_496.isc_509 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_496.isc_508 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_496.isc_507 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_496.isc_506 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedure_name:
					l = GET_TEXT(/*X.RDB$PROCEDURE_NAME*/
						     isc_496.isc_498);
					//procedure->prc_name_length = l;
					strcpy (procedure->prc_name, /*X.RDB$PROCEDURE_NAME*/
								     isc_496.isc_498);
					MISC_terminate (/*X.RDB$PROCEDURE_NAME*/
							isc_496.isc_498, temp, l, sizeof(temp));
					BURP_verbose (195, temp);
					// msg 195 restoring stored procedure %s
					break;

				case att_procedure_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_496.isc_501, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_496.isc_510 = FALSE;
					break;

				case att_procedure_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_496.isc_501, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_496.isc_510 = FALSE;
					break;

				case att_procedure_source:
					get_misc_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
							      isc_496.isc_502, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_496.isc_511 = FALSE;
					break;

				case att_procedure_source2:
					get_source_blob (tdgbl, /*X.RDB$PROCEDURE_SOURCE*/
								isc_496.isc_502, true);
					/*X.RDB$PROCEDURE_SOURCE.NULL*/
					isc_496.isc_511 = FALSE;
					break;

				case att_procedure_blr:
					get_blr_blob (tdgbl, /*X.RDB$PROCEDURE_BLR*/
							     isc_496.isc_497, true);
					break;

				case att_procedure_security_class:
					GET_TEXT(/*X.RDB$SECURITY_CLASS*/
						 isc_496.isc_500);
					fix_security_class_name(tdgbl, /*X.RDB$SECURITY_CLASS*/
								       isc_496.isc_500, false);
					/*X.RDB$SECURITY_CLASS.NULL*/
					isc_496.isc_509 = FALSE;
					break;

				case att_procedure_owner_name:
					GET_TEXT(procedure->prc_owner);
					break;

				case att_procedure_inputs:
					/*X.RDB$PROCEDURE_INPUTS*/
					isc_496.isc_505 = (USHORT) get_int32(tdgbl);
					if (/*X.RDB$PROCEDURE_INPUTS*/
					    isc_496.isc_505 == 0)
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_496.isc_504 = TRUE;
					else
						/*X.RDB$PROCEDURE_INPUTS.NULL*/
						isc_496.isc_504 = FALSE;
					break;

				case att_procedure_outputs:
					/*X.RDB$PROCEDURE_OUTPUTS*/
					isc_496.isc_503 = (USHORT) get_int32(tdgbl);
					break;

				case att_procedure_type:
				case att_procedure_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_debug_info:
					if (tdgbl->RESTORE_format >= 8)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_engine_name:
				case att_procedure_entrypoint:
				case att_procedure_package_name:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				case att_procedure_private_flag:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 290);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 290);
					// msg 290 procedure
					break;
				}
			}
			strcpy (procedure_name, /*X.RDB$PROCEDURE_NAME*/
						isc_496.isc_498);
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 138, &isc_496, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// at the end of prms for a procedure is the rec_procedure_end marker

	while (get(tdgbl) == rec_procedure_prm)
		get_procedure_prm (tdgbl, package_name, procedure_name);

	return true;
}

bool get_procedure_prm (BurpGlobals* tdgbl, GDS_NAME package_name, GDS_NAME procptr)
{
   struct isc_458_struct {
          char  isc_459 [32];	/* RDB$FIELD_SOURCE */
          char  isc_460 [32];	/* RDB$PARAMETER_NAME */
          char  isc_461 [32];	/* RDB$PROCEDURE_NAME */
          ISC_QUAD isc_462;	/* RDB$DESCRIPTION */
          short isc_463;	/* RDB$PARAMETER_NUMBER */
          short isc_464;	/* RDB$PARAMETER_TYPE */
          short isc_465;	/* gds__null_flag */
          short isc_466;	/* RDB$SYSTEM_FLAG */
          short isc_467;	/* gds__null_flag */
   } isc_458;
   struct isc_469_struct {
          char  isc_470 [32];	/* RDB$FIELD_SOURCE */
          char  isc_471 [32];	/* RDB$PARAMETER_NAME */
          char  isc_472 [32];	/* RDB$RELATION_NAME */
          char  isc_473 [32];	/* RDB$FIELD_NAME */
          ISC_QUAD isc_474;	/* RDB$DEFAULT_SOURCE */
          ISC_QUAD isc_475;	/* RDB$DEFAULT_VALUE */
          ISC_QUAD isc_476;	/* RDB$DESCRIPTION */
          char  isc_477 [32];	/* RDB$PACKAGE_NAME */
          char  isc_478 [32];	/* RDB$PROCEDURE_NAME */
          short isc_479;	/* RDB$PARAMETER_NUMBER */
          short isc_480;	/* RDB$PARAMETER_TYPE */
          short isc_481;	/* gds__null_flag */
          short isc_482;	/* gds__null_flag */
          short isc_483;	/* gds__null_flag */
          short isc_484;	/* RDB$PARAMETER_MECHANISM */
          short isc_485;	/* gds__null_flag */
          short isc_486;	/* RDB$NULL_FLAG */
          short isc_487;	/* gds__null_flag */
          short isc_488;	/* RDB$SYSTEM_FLAG */
          short isc_489;	/* gds__null_flag */
          short isc_490;	/* RDB$COLLATION_ID */
          short isc_491;	/* gds__null_flag */
          short isc_492;	/* gds__null_flag */
          short isc_493;	/* gds__null_flag */
          short isc_494;	/* gds__null_flag */
   } isc_469;
/**************************************
 *
 *	g e t _ p r o c e d u r e _ p r m
 *
 **************************************
 *
 * Functional description
 *	Reconstruct stored procedure parameter.
 *	Use the global_trans so we don't have to commit
 *	until after the indices are activated.  This
 *	will allow us to use a PLAN in a SP.
 *
 **************************************/
	att_type	attribute;
	SSHORT		l;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_468), (char*) isc_468);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_469.isc_474 = isc_blob_null;
		   isc_469.isc_475 = isc_blob_null;
		   isc_469.isc_476 = isc_blob_null;

			strcpy(/*X.RDB$PROCEDURE_NAME*/
			       isc_469.isc_478, procptr);

			if (package_name[0])
			{
				strcpy(/*X.RDB$PACKAGE_NAME*/
				       isc_469.isc_477, package_name);
				/*X.RDB$PACKAGE_NAME.NULL*/
				isc_469.isc_494 = FALSE;
			}
			else
				/*X.RDB$PACKAGE_NAME.NULL*/
				isc_469.isc_494 = TRUE;

			/*X.RDB$DESCRIPTION.NULL*/
			isc_469.isc_493 = TRUE;
			/*X.RDB$DEFAULT_VALUE.NULL*/
			isc_469.isc_492 = TRUE;
			/*X.RDB$DEFAULT_SOURCE.NULL*/
			isc_469.isc_491 = TRUE;
			/*X.RDB$COLLATION_ID.NULL*/
			isc_469.isc_489 = TRUE;

			/*X.RDB$SYSTEM_FLAG*/
			isc_469.isc_488 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_469.isc_487 = FALSE;

			/*X.RDB$NULL_FLAG*/
			isc_469.isc_486 = FALSE;
			/*X.RDB$NULL_FLAG.NULL*/
			isc_469.isc_485 = FALSE;

			/*X.RDB$PARAMETER_MECHANISM*/
			isc_469.isc_484 = prm_mech_normal;
			/*X.RDB$PARAMETER_MECHANISM.NULL*/
			isc_469.isc_483 = FALSE;

			// DB_VERSION_DDL11_2
			/*X.RDB$FIELD_NAME.NULL*/
			isc_469.isc_482 = TRUE;
			/*X.RDB$RELATION_NAME.NULL*/
			isc_469.isc_481 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_469.isc_471);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_469.isc_471, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_469.isc_480= (USHORT) get_int32(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_469.isc_479= (USHORT) get_int32(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_469.isc_470);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_469.isc_476, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_469.isc_493 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_469.isc_476, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_469.isc_493 = FALSE;
					break;

				case att_procedureprm_default_value:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_VALUE.NULL*/
						isc_469.isc_492 = FALSE;
						get_blr_blob (tdgbl, /*X.RDB$DEFAULT_VALUE*/
								     isc_469.isc_475, true);
					}
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_default_source:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEFAULT_SOURCE.NULL*/
						isc_469.isc_491 = FALSE;
						get_source_blob (tdgbl, /*X.RDB$DEFAULT_SOURCE*/
									isc_469.isc_474, true);
					}
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_collation_id:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$COLLATION_ID.NULL*/
						isc_469.isc_489 = FALSE;
						/*X.RDB$COLLATION_ID*/
						isc_469.isc_490 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_null_flag:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$NULL_FLAG*/
						isc_469.isc_486 = (USHORT) get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_mechanism:
					if (tdgbl->RESTORE_format >= 8)
						/*X.RDB$PARAMETER_MECHANISM*/
						isc_469.isc_484 = (USHORT) get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_field_name:
					if (tdgbl->RESTORE_format >= 9)
					{
						/*X.RDB$FIELD_NAME.NULL*/
						isc_469.isc_482 = FALSE;
						GET_TEXT(/*X.RDB$FIELD_NAME*/
							 isc_469.isc_473);
					}
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_relation_name:
					if (tdgbl->RESTORE_format >= 9)
					{
						/*X.RDB$RELATION_NAME.NULL*/
						isc_469.isc_481 = FALSE;
						GET_TEXT(/*X.RDB$RELATION_NAME*/
							 isc_469.isc_472);
					}
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 248, &isc_469, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_procedure_prm_req_handle1)
			X IN RDB$PROCEDURE_PARAMETERS*/
		{
		
                if (!tdgbl->handles_get_procedure_prm_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (short) sizeof(isc_457), (char*) isc_457);
		if (tdgbl->handles_get_procedure_prm_req_handle1)
		   {
		   isc_458.isc_462 = isc_blob_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_458.isc_467 = TRUE;
			strcpy (/*X.RDB$PROCEDURE_NAME*/
				isc_458.isc_461, procptr);
			/*X.RDB$SYSTEM_FLAG*/
			isc_458.isc_466 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_458.isc_465 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_procedureprm_name:
					l = GET_TEXT(/*X.RDB$PARAMETER_NAME*/
						     isc_458.isc_460);
					MISC_terminate (/*X.RDB$PARAMETER_NAME*/
							isc_458.isc_460, temp, l, sizeof(temp));
					BURP_verbose (196, temp);
					// msg 196 restoring parameter %s for stored procedure
					break;

				case att_procedureprm_type:
					/*X.RDB$PARAMETER_TYPE*/
					isc_458.isc_464= (USHORT) get_int32(tdgbl);
					break;

				case att_procedureprm_number:
					/*X.RDB$PARAMETER_NUMBER*/
					isc_458.isc_463= (USHORT) get_int32(tdgbl);
					break;

				case att_procedureprm_field_source:
					GET_TEXT(/*X.RDB$FIELD_SOURCE*/
						 isc_458.isc_459);
					break;

				case att_procedureprm_description:
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_458.isc_462, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_458.isc_467 = FALSE;
					break;

				case att_procedureprm_description2:
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_458.isc_462, true);
					/*X.RDB$DESCRIPTION.NULL*/
					isc_458.isc_467 = FALSE;
					break;

				case att_procedureprm_default_value:
				case att_procedureprm_default_source:
					if (tdgbl->RESTORE_format >= 8)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				case att_procedureprm_collation_id:
				case att_procedureprm_null_flag:
				case att_procedureprm_mechanism:
					if (tdgbl->RESTORE_format >= 8)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				// DB_VERSION_DDL11_2
				case att_procedureprm_field_name:
				case att_procedureprm_relation_name:
					if (tdgbl->RESTORE_format >= 9)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 291);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 291);
					// msg 291 procedure parameter
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_procedure_prm_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 114, &isc_458, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_ref_constraint(BurpGlobals* tdgbl)
{
   struct isc_446_struct {
          char  isc_447 [8];	/* RDB$MATCH_OPTION */
          char  isc_448 [32];	/* RDB$CONST_NAME_UQ */
          char  isc_449 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_450 [12];	/* RDB$DELETE_RULE */
          char  isc_451 [12];	/* RDB$UPDATE_RULE */
          short isc_452;	/* gds__null_flag */
          short isc_453;	/* gds__null_flag */
          short isc_454;	/* gds__null_flag */
          short isc_455;	/* gds__null_flag */
          short isc_456;	/* gds__null_flag */
   } isc_446;
/**************************************
 *
 *	g e t _ r e f _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for referential constraints.
 *
 **************************************/
	att_type        attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_ref_constraint_req_handle1)
		X IN RDB$REF_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_ref_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (short) sizeof(isc_445), (char*) isc_445);
	if (tdgbl->handles_get_ref_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_446.isc_456 = TRUE;
		/*X.RDB$CONST_NAME_UQ.NULL*/
		isc_446.isc_455 = TRUE;
		/*X.RDB$MATCH_OPTION.NULL*/
		isc_446.isc_454 = TRUE;
		/*X.RDB$UPDATE_RULE.NULL*/
		isc_446.isc_453 = TRUE;
		/*X.RDB$DELETE_RULE.NULL*/
		isc_446.isc_452 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_ref_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_446.isc_456 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_446.isc_449);
					break;

				case att_ref_unique_const_name:
					/*X.RDB$CONST_NAME_UQ.NULL*/
					isc_446.isc_455 = FALSE;
					GET_TEXT(/*X.RDB$CONST_NAME_UQ*/
						 isc_446.isc_448);
					break;

				case att_ref_match_option:
					/*X.RDB$MATCH_OPTION.NULL*/
					isc_446.isc_454 = FALSE;
					GET_TEXT(/*X.RDB$MATCH_OPTION*/
						 isc_446.isc_447);
					break;

				case att_ref_update_rule:
					/*X.RDB$UPDATE_RULE.NULL*/
					isc_446.isc_453 = FALSE;
					GET_TEXT(/*X.RDB$UPDATE_RULE*/
						 isc_446.isc_451);
					break;

				case att_ref_delete_rule:
					/*X.RDB$DELETE_RULE.NULL*/
					isc_446.isc_452 = FALSE;
					GET_TEXT(/*X.RDB$DELETE_RULE*/
						 isc_446.isc_450);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 292);
					// msg 292 referential constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_ref_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 106, &isc_446, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation(BurpGlobals* tdgbl)
{
   struct isc_402_struct {
          char  isc_403 [32];	/* RDB$RELATION_NAME */
          char  isc_404 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_405;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_406;	/* RDB$RUNTIME */
          ISC_QUAD isc_407;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_408;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_409;	/* RDB$VIEW_BLR */
          char  isc_410 [32];	/* RDB$SECURITY_CLASS */
          short isc_411;	/* gds__null_flag */
          short isc_412;	/* gds__null_flag */
          short isc_413;	/* gds__null_flag */
          short isc_414;	/* gds__null_flag */
          short isc_415;	/* gds__null_flag */
          short isc_416;	/* gds__null_flag */
          short isc_417;	/* gds__null_flag */
          short isc_418;	/* gds__null_flag */
          short isc_419;	/* RDB$FLAGS */
          short isc_420;	/* gds__null_flag */
          short isc_421;	/* RDB$SYSTEM_FLAG */
   } isc_402;
   struct isc_423_struct {
          char  isc_424 [32];	/* RDB$RELATION_NAME */
          char  isc_425 [256];	/* RDB$EXTERNAL_FILE */
          ISC_QUAD isc_426;	/* RDB$EXTERNAL_DESCRIPTION */
          ISC_QUAD isc_427;	/* RDB$RUNTIME */
          ISC_QUAD isc_428;	/* RDB$DESCRIPTION */
          ISC_QUAD isc_429;	/* RDB$VIEW_SOURCE */
          ISC_QUAD isc_430;	/* RDB$VIEW_BLR */
          char  isc_431 [32];	/* RDB$SECURITY_CLASS */
          short isc_432;	/* gds__null_flag */
          short isc_433;	/* RDB$RELATION_TYPE */
          short isc_434;	/* gds__null_flag */
          short isc_435;	/* gds__null_flag */
          short isc_436;	/* gds__null_flag */
          short isc_437;	/* gds__null_flag */
          short isc_438;	/* gds__null_flag */
          short isc_439;	/* gds__null_flag */
          short isc_440;	/* gds__null_flag */
          short isc_441;	/* gds__null_flag */
          short isc_442;	/* RDB$FLAGS */
          short isc_443;	/* gds__null_flag */
          short isc_444;	/* RDB$SYSTEM_FLAG */
   } isc_423;
/**************************************
 *
 *	g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Write relation meta-data and data.
 *	Use the default transaction for RELATIONS,
 *	and use the global_trans for VIEWS.  This
 *	enables us to have views of SP and views
 *	with plans.  Assume it is a view if it has
 *	RDB$VIEW_BLR, also assume RDB$VIEW_BLR is
 *	the first blob in the backup file.
 *
 *
 **************************************/
	SLONG		rel_flags = 0, sys_flag = 0, type = 0;
	bool		rel_flags_null = true, type_null = true;
	ISC_QUAD	view_blr = isc_blob_null, view_src = isc_blob_null,
				rel_desc = isc_blob_null, ext_desc = isc_blob_null;
	bool		view_blr_null = true, view_src_null = true, rel_desc_null = true,
				ext_desc_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$SECURITY_CLASS sec_class;*/
	char
	   sec_class[32];

	sec_class[0] = '\0';
	bool		sec_class_null = true;

	/*BASED_ON RDB$RELATIONS.RDB$EXTERNAL_FILE ext_file_name;*/
	char
	   ext_file_name[256];

	ext_file_name[0] = '\0';
	bool		ext_file_name_null = true;

	// Pick up relation attributes

	burp_rel* relation = (burp_rel*) BURP_alloc_zero (sizeof(burp_rel));
	relation->rel_next = tdgbl->relations;
	tdgbl->relations = relation;

	/*
	STORE (REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
		X IN RDB$RELATIONS
		X.RDB$SYSTEM_FLAG = 0;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;
		X.RDB$FLAGS.NULL = TRUE;
		X.RDB$SECURITY_CLASS.NULL = TRUE;
		X.RDB$VIEW_BLR.NULL = TRUE;
		X.RDB$VIEW_SOURCE.NULL = TRUE;
		X.RDB$DESCRIPTION.NULL = TRUE;
		X.RDB$RUNTIME.NULL = TRUE;
		X.RDB$EXTERNAL_DESCRIPTION.NULL = TRUE;
	*/

	TEXT rel_name[GDS_NAME_LEN] = "";
	att_type attribute;
	scan_attr_t scan_next_attr;
	skip_init(&scan_next_attr);

	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			{
				const SSHORT l = GET_TEXT(relation->rel_name);
				relation->rel_name_length = l;
				MISC_terminate (relation->rel_name, rel_name, l, sizeof(rel_name));
				BURP_verbose(167, rel_name); // msg 167 restoring table @1
			}
			break;

		case att_relation_security_class:
			sec_class_null = false;
			GET_TEXT(sec_class);
			fix_security_class_name(tdgbl, sec_class, false);
			break;

		case att_relation_view_blr:
			view_blr_null = false;
			get_blr_blob(tdgbl, view_blr, true);
			relation->rel_flags |= REL_view;
			fb_assert(rel_name[0] != 0);
			BURP_verbose(346, rel_name); // msg 346 '    table @1 is a view'
			break;

		case att_relation_view_source:
			view_src_null = false;
			get_misc_blob (tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_view_source2:
			view_src_null = false;
			get_source_blob(tdgbl, view_src, !view_blr_null);
			break;

		case att_relation_description:
			rel_desc_null = false;
			get_misc_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_description2:
			rel_desc_null = false;
			get_source_blob(tdgbl, rel_desc, !view_blr_null);
			break;

		case att_relation_flags:
			rel_flags_null = false;
			rel_flags = get_int32(tdgbl);
			break;

		case att_relation_system_flag:
			sys_flag = get_int32(tdgbl);
			break;

		case att_relation_ext_description:
			ext_desc_null = false;
			get_misc_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_ext_description2:
			ext_desc_null = false;
			get_source_blob(tdgbl, ext_desc, !view_blr_null);
			break;

		case att_relation_owner_name:
			GET_TEXT(relation->rel_owner);
			break;

		case att_relation_ext_file_name:
			ext_file_name_null = false;
			GET_TEXT(ext_file_name);
			break;

		case att_relation_type:
			if (tdgbl->RESTORE_format >= 8)
			{
				type_null = false;
				type = get_int32(tdgbl);
			}
			else
				bad_attribute(scan_next_attr, attribute, 111);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	// If this is a view and there is a global transaction then use it
	isc_tr_handle local_trans;
	if (view_blr_null || !tdgbl->global_trans)
		local_trans = gds_trans;
	else
		local_trans = tdgbl->global_trans;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_422), (char*) isc_422);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_423.isc_426 = isc_blob_null;
		   isc_423.isc_427 = isc_blob_null;
		   isc_423.isc_428 = isc_blob_null;
		   isc_423.isc_429 = isc_blob_null;
		   isc_423.isc_430 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_423.isc_443 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_423.isc_441 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_423.isc_440 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_423.isc_439 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_423.isc_438 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_423.isc_437 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_423.isc_436 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_423.isc_435 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_423.isc_434 = ext_file_name_null;
			/*X.RDB$RELATION_TYPE.NULL*/
			isc_423.isc_432 = type_null;

			/*X.RDB$SYSTEM_FLAG*/
			isc_423.isc_444 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_423.isc_442 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_423.isc_430 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_423.isc_429 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_423.isc_428 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_423.isc_426 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_423.isc_431, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_423.isc_424, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_423.isc_425, ext_file_name);

			/*X.RDB$RELATION_TYPE*/
			isc_423.isc_433 = (USHORT) type;

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 386, &isc_423, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_relation_req_handle1)
			X IN RDB$RELATIONS*/
		{
		
                if (!tdgbl->handles_get_relation_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (short) sizeof(isc_401), (char*) isc_401);
		if (tdgbl->handles_get_relation_req_handle1)
		   {
		   isc_402.isc_405 = isc_blob_null;
		   isc_402.isc_406 = isc_blob_null;
		   isc_402.isc_407 = isc_blob_null;
		   isc_402.isc_408 = isc_blob_null;
		   isc_402.isc_409 = isc_blob_null;

			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_402.isc_420 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_402.isc_418 = rel_flags_null;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_402.isc_417 = sec_class_null;
			/*X.RDB$VIEW_BLR.NULL*/
			isc_402.isc_416 = view_blr_null;
			/*X.RDB$VIEW_SOURCE.NULL*/
			isc_402.isc_415 = view_src_null;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_402.isc_414 = rel_desc_null;
			/*X.RDB$RUNTIME.NULL*/
			isc_402.isc_413 = TRUE;
			/*X.RDB$EXTERNAL_DESCRIPTION.NULL*/
			isc_402.isc_412 = ext_desc_null;
			/*X.RDB$EXTERNAL_FILE.NULL*/
			isc_402.isc_411 = ext_file_name_null;

			/*X.RDB$SYSTEM_FLAG*/
			isc_402.isc_421 = (USHORT) sys_flag;
			/*X.RDB$FLAGS*/
			isc_402.isc_419 = (USHORT) rel_flags;
			/*X.RDB$VIEW_BLR*/
			isc_402.isc_409 = view_blr;
			/*X.RDB$VIEW_SOURCE*/
			isc_402.isc_408 = view_src;
			/*X.RDB$DESCRIPTION*/
			isc_402.isc_407 = rel_desc;
			/*X.RDB$EXTERNAL_DESCRIPTION*/
			isc_402.isc_405 = ext_desc;

			strcpy(/*X.RDB$SECURITY_CLASS*/
			       isc_402.isc_410, sec_class);
			strcpy(/*X.RDB$RELATION_NAME*/
			       isc_402.isc_403, relation->rel_name);
			strcpy(/*X.RDB$EXTERNAL_FILE*/
			       isc_402.isc_404, ext_file_name);

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_relation_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 382, &isc_402, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	// Eat up misc. records
	burp_fld* field = NULL;
	burp_fld** ptr = &relation->rel_fields;

	rec_type record;
	while (get_record(&record, tdgbl) != rec_data)
	{
		switch (record)
		{
		case rec_relation_end:
			if (tdgbl->gbl_sw_incremental)
			{
				BURP_verbose (170, relation->rel_name);
				// msg 170: committing metadata for relation %s
				/*COMMIT*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				// existing ON_ERROR continues past error, beck
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					BURP_print (false, 171, relation->rel_name);
					// msg 171: error committing metadata for relation %s
					BURP_print_status (false, tdgbl->status_vector);
					/*ROLLBACK;*/
					{
					isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_11);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_12);
					SQLCODE = isc_sqlcode(isc_status);
					}
			}
			return true;

		case rec_field:
			*ptr = field = get_field (tdgbl, relation);
			if (!field)
				return false;
			ptr = &field->fld_next;
			break;

		case rec_view:
			get_view(tdgbl, relation);
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	// If we fall thru, there are data records to be gotten
	// we can get here only when restoring ancient gbak'ed files where rec_data
	// was once embedded into rec_relation ... otherwise, meta commit happens
	// when we see the first rec_relation_data

	BURP_verbose (68);
	// msg 68 committing meta data

	/*COMMIT;*/
	{
	isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_13);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_14);
		SQLCODE = isc_sqlcode(isc_status);
		}

	get_data(tdgbl, relation, tdgbl->skipRelation(rel_name));

	return true;
}

bool get_rel_constraint(BurpGlobals* tdgbl)
{
   struct isc_388_struct {
          char  isc_389 [32];	/* RDB$INDEX_NAME */
          char  isc_390 [32];	/* RDB$RELATION_NAME */
          char  isc_391 [32];	/* RDB$CONSTRAINT_NAME */
          char  isc_392 [4];	/* RDB$INITIALLY_DEFERRED */
          char  isc_393 [4];	/* RDB$DEFERRABLE */
          char  isc_394 [12];	/* RDB$CONSTRAINT_TYPE */
          short isc_395;	/* gds__null_flag */
          short isc_396;	/* gds__null_flag */
          short isc_397;	/* gds__null_flag */
          short isc_398;	/* gds__null_flag */
          short isc_399;	/* gds__null_flag */
          short isc_400;	/* gds__null_flag */
   } isc_388;
/**************************************
 *
 *	g e t _ r e l _ c o n s t r a i n t
 *
 **************************************
 *
 * Functional description
 *	Restore data for relation constraints.
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_rel_constraint_req_handle1)
		X IN RDB$RELATION_CONSTRAINTS*/
	{
	
        if (!tdgbl->handles_get_rel_constraint_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (short) sizeof(isc_387), (char*) isc_387);
	if (tdgbl->handles_get_rel_constraint_req_handle1)
	   {
		/*X.RDB$CONSTRAINT_NAME.NULL*/
		isc_388.isc_400 = TRUE;
		/*X.RDB$CONSTRAINT_TYPE.NULL*/
		isc_388.isc_399 = TRUE;
		/*X.RDB$RELATION_NAME.NULL*/
		isc_388.isc_398 = TRUE;
		/*X.RDB$DEFERRABLE.NULL*/
		isc_388.isc_397 = TRUE;
		/*X.RDB$INITIALLY_DEFERRED.NULL*/
		isc_388.isc_396 = TRUE;
		/*X.RDB$INDEX_NAME.NULL*/
		isc_388.isc_395 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
				case att_rel_constraint_name:
					/*X.RDB$CONSTRAINT_NAME.NULL*/
					isc_388.isc_400 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_NAME*/
						 isc_388.isc_391);
					break;

				case att_rel_constraint_type:
					/*X.RDB$CONSTRAINT_TYPE.NULL*/
					isc_388.isc_399 = FALSE;
					GET_TEXT(/*X.RDB$CONSTRAINT_TYPE*/
						 isc_388.isc_394);
					break;

				case att_rel_constraint_rel_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_388.isc_398 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_388.isc_390);
					break;

				case att_rel_constraint_defer:
					/*X.RDB$DEFERRABLE.NULL*/
					isc_388.isc_397 = FALSE;
					GET_TEXT(/*X.RDB$DEFERRABLE*/
						 isc_388.isc_393);
					break;

				case att_rel_constraint_init:
					/*X.RDB$INITIALLY_DEFERRED.NULL*/
					isc_388.isc_396 = FALSE;
					GET_TEXT(/*X.RDB$INITIALLY_DEFERRED*/
						 isc_388.isc_392);
					break;

				case att_rel_constraint_index:
					/*X.RDB$INDEX_NAME.NULL*/
					isc_388.isc_395 = FALSE;
					GET_TEXT(/*X.RDB$INDEX_NAME*/
						 isc_388.isc_389);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 208);
					// msg 208 table constraint
					break;
			}
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_rel_constraint_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 128, &isc_388, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_relation_data(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	g e t _ r e l a t i o n _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Restore data for a relation.  This is called when the data is
 *	standing free from the relation definition.  We first need to
 *	find the relation named.  If we can't find it, give up.
 *
 **************************************/
	/*BASED_ON RDB$RELATIONS.RDB$RELATION_NAME name;*/
	char
	   name[32];

	att_type	attribute;
	scan_attr_t		scan_next_attr;

	burp_rel* relation = NULL;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_relation_name:
			GET_TEXT(name);
			relation = find_relation (tdgbl, name);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 111);
			// msg 111 table
			break;
		}
	}

	if (!relation)
		BURP_error_redirect (NULL, 49);
	// msg 49 no relation name for data

	// Eat up misc. records
	rec_type record;
	get_record(&record, tdgbl);

	SLONG gen_id;
	bool skip_flag = tdgbl->skipRelation(name);

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), true)
	{
		switch (record)
		{
		case rec_relation_end:
			return true;

		case rec_data:
			record = get_data(tdgbl, relation, skip_flag);
			// get_data does a GET_RECORD
			break;

		case rec_gen_id:
			gen_id = get_int32(tdgbl);
			store_blr_gen_id(tdgbl, name, gen_id, 0, NULL, NULL, NULL, fb_sysflag_user, 1);
			get_record(&record, tdgbl);
			break;

		case rec_index:
			get_index (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		case rec_trigger:  // old style trigger
			get_trigger_old (tdgbl, relation);
			get_record(&record, tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 111);
			// msg 111 relation
			get_record(&record, tdgbl);
			break;
		}
	}

	return true;
}

bool get_sql_roles(BurpGlobals* tdgbl)
{
   struct isc_372_struct {
          char  isc_373 [32];	/* RDB$OWNER_NAME */
          char  isc_374 [32];	/* RDB$ROLE_NAME */
          short isc_375;	/* gds__null_flag */
          short isc_376;	/* gds__null_flag */
   } isc_372;
   struct isc_378_struct {
          ISC_QUAD isc_379;	/* RDB$DESCRIPTION */
          char  isc_380 [32];	/* RDB$OWNER_NAME */
          char  isc_381 [32];	/* RDB$ROLE_NAME */
          short isc_382;	/* gds__null_flag */
          short isc_383;	/* RDB$SYSTEM_FLAG */
          short isc_384;	/* gds__null_flag */
          short isc_385;	/* gds__null_flag */
          short isc_386;	/* gds__null_flag */
   } isc_378;
/**************************************
 *
 *	g e t _ s q l _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Restore data for SQL roles
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_377), (char*) isc_377);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {
		   isc_378.isc_379 = isc_blob_null;

			/*X.RDB$ROLE_NAME.NULL*/
			isc_378.isc_386 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_378.isc_385 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_378.isc_384 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_378.isc_383 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_378.isc_382 = FALSE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_378.isc_386 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_378.isc_381);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_378.isc_381, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_378.isc_385 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_378.isc_380);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
					{
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_378.isc_379, false);
						/*X.RDB$DESCRIPTION.NULL*/
						isc_378.isc_384 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 250);
				    break;

				default:
					// msg 250 SQL role
					bad_attribute(scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 82, &isc_378, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL9)
	{
		// This is the first IB version (v5, ods9) where roles appeared.
		// They remained unchanged for IB6 / FB1 and FB1.5 (ods10).
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_sql_roles_req_handle1)
			X IN RDB$ROLES*/
		{
		
                if (!tdgbl->handles_get_sql_roles_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (short) sizeof(isc_371), (char*) isc_371);
		if (tdgbl->handles_get_sql_roles_req_handle1)
		   {

			/*X.RDB$ROLE_NAME.NULL*/
			isc_372.isc_376 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_372.isc_375 = TRUE;
			// Here we didn't have RBD$SYSTEM_FLAG field.

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_role_name:
					/*X.RDB$ROLE_NAME.NULL*/
					isc_372.isc_376 = FALSE;
					l = GET_TEXT(/*X.RDB$ROLE_NAME*/
						     isc_372.isc_374);
					MISC_terminate (/*X.RDB$ROLE_NAME*/
							isc_372.isc_374, temp, l, sizeof(temp));
					// msg 251, restoring SQL role: %s
					BURP_verbose (251, temp);
					break;

				case att_role_owner_name:
					/*X.RDB$OWNER_NAME.NULL*/
					isc_372.isc_375 = FALSE;
					GET_TEXT(/*X.RDB$OWNER_NAME*/
						 isc_372.isc_373);
					break;

				case att_role_description:
					if (tdgbl->RESTORE_format >= 7)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 250);
					break;

				default:
					// msg 250 SQL role
					bad_attribute(scan_next_attr, attribute, 250);
					break;
				}
			}
		/*END_STORE*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_sql_roles_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 68, &isc_372, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		// We say we support IB4, then we should skip roles.
		skip_init(&scan_next_attr);

		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_role_name:
			case att_role_owner_name:
				eat_text(tdgbl);
				break;

			case att_role_description:
				if (tdgbl->RESTORE_format >= 7)
					eat_blob(tdgbl);
				else
					bad_attribute(scan_next_attr, attribute, 250);
				break;

			default:
				// msg 250 SQL role
				bad_attribute(scan_next_attr, attribute, 250);
				break;
			}
		}
	}

	return true;
}

bool get_mapping(BurpGlobals* tdgbl)
{
   struct isc_352_struct {
          ISC_QUAD isc_353;	/* RDB$DESCRIPTION */
          char  isc_354 [32];	/* RDB$MAP_TO */
          char  isc_355 [256];	/* RDB$MAP_FROM */
          char  isc_356 [32];	/* RDB$MAP_FROM_TYPE */
          char  isc_357 [32];	/* RDB$MAP_DB */
          char  isc_358 [32];	/* RDB$MAP_PLUGIN */
          char  isc_359 [32];	/* RDB$MAP_NAME */
          short isc_360;	/* gds__null_flag */
          short isc_361;	/* gds__null_flag */
          short isc_362;	/* gds__null_flag */
          short isc_363;	/* gds__null_flag */
          short isc_364;	/* gds__null_flag */
          short isc_365;	/* gds__null_flag */
          short isc_366;	/* gds__null_flag */
          char  isc_367 [2];	/* RDB$MAP_USING */
          short isc_368;	/* gds__null_flag */
          short isc_369;	/* gds__null_flag */
          short isc_370;	/* RDB$MAP_TO_TYPE */
   } isc_352;
/**************************************
 *
 *	g e t _ m a p p i n g
 *
 **************************************
 *
 * Functional description
 *	Restore mapping to users and roles
 *
 **************************************/
	att_type		attribute;
	scan_attr_t		scan_next_attr;
	TEXT			temp[GDS_NAME_LEN];
	SSHORT			l;
	Firebird::string role;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_get_mapping_req_handle1)
			M IN RDB$MAP*/
		{
		
                if (!tdgbl->handles_get_mapping_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_mapping_req_handle1, (short) sizeof(isc_351), (char*) isc_351);
		if (tdgbl->handles_get_mapping_req_handle1)
		   {
		   isc_352.isc_353 = isc_blob_null;

			/*M.RDB$MAP_TO_TYPE.NULL*/
			isc_352.isc_369 = TRUE;
			/*M.RDB$MAP_NAME.NULL*/
			isc_352.isc_368 = TRUE;
			/*M.RDB$MAP_USING.NULL*/
			isc_352.isc_366 = TRUE;
			/*M.RDB$MAP_PLUGIN.NULL*/
			isc_352.isc_365 = TRUE;
			/*M.RDB$MAP_DB.NULL*/
			isc_352.isc_364 = TRUE;
			/*M.RDB$MAP_FROM_TYPE.NULL*/
			isc_352.isc_363 = TRUE;
			/*M.RDB$MAP_FROM.NULL*/
			isc_352.isc_362 = TRUE;
			/*M.RDB$MAP_TO.NULL*/
			isc_352.isc_361 = TRUE;
			/*M.RDB$DESCRIPTION.NULL*/
			isc_352.isc_360 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_auto_map_role:
					GET_TEXT(temp);
					/*M.RDB$MAP_NAME.NULL*/
					isc_352.isc_368 = FALSE;
					strcpy(/*M.RDB$MAP_NAME*/
					       isc_352.isc_359, "AutoAdminImplementationMapping");
					/*M.RDB$MAP_FROM.NULL*/
					isc_352.isc_362 = FALSE;
					strcpy(/*M.RDB$MAP_FROM*/
					       isc_352.isc_355, FB_DOMAIN_ANY_RID_ADMINS);
					/*M.RDB$MAP_FROM_TYPE.NULL*/
					isc_352.isc_363 = FALSE;
					strcpy(/*M.RDB$MAP_FROM_TYPE*/
					       isc_352.isc_356, FB_PREDEFINED_GROUP);
					/*M.RDB$MAP_USING.NULL*/
					isc_352.isc_366 = FALSE;
					strcpy(/*M.RDB$MAP_USING*/
					       isc_352.isc_367, "P");
					/*M.RDB$MAP_PLUGIN.NULL*/
					isc_352.isc_365 = FALSE;
					strcpy(/*M.RDB$MAP_PLUGIN*/
					       isc_352.isc_358, "Win_Sspi");
					/*M.RDB$MAP_TO_TYPE.NULL*/
					isc_352.isc_369 = FALSE;
					/*M.RDB$MAP_TO_TYPE*/
					isc_352.isc_370 = 1;
					/*M.RDB$MAP_TO.NULL*/
					isc_352.isc_361 = FALSE;
					strcpy(/*M.RDB$MAP_TO*/
					       isc_352.isc_354, ADMIN_ROLE);

					BURP_verbose(301);
					// msg 301, restoring names mapping
					BURP_verbose (298, /*M.RDB$MAP_NAME*/
							   isc_352.isc_359);
					break;

				case att_map_name:
					/*M.RDB$MAP_NAME.NULL*/
					isc_352.isc_368 = FALSE;
					GET_TEXT(/*M.RDB$MAP_NAME*/
						 isc_352.isc_359);
					if (tdgbl->firstMap)
					{
						tdgbl->firstMap = false;
						BURP_verbose(301);
						// msg 301, restoring names mapping
					}
					BURP_verbose (298, /*M.RDB$MAP_NAME*/
							   isc_352.isc_359);
					break;

				case att_map_using:
					/*M.RDB$MAP_USING.NULL*/
					isc_352.isc_366 = FALSE;
					GET_TEXT(/*M.RDB$MAP_USING*/
						 isc_352.isc_367);
					break;

				case att_map_plugin:
					/*M.RDB$MAP_PLUGIN.NULL*/
					isc_352.isc_365 = FALSE;
					GET_TEXT(/*M.RDB$MAP_PLUGIN*/
						 isc_352.isc_358);
					break;

				case att_map_db:
					/*M.RDB$MAP_DB.NULL*/
					isc_352.isc_364 = FALSE;
					GET_TEXT(/*M.RDB$MAP_DB*/
						 isc_352.isc_357);
					break;

				case att_map_from_type:
					/*M.RDB$MAP_FROM_TYPE.NULL*/
					isc_352.isc_363 = FALSE;
					GET_TEXT(/*M.RDB$MAP_FROM_TYPE*/
						 isc_352.isc_356);
					break;

				case att_map_from:
					/*M.RDB$MAP_FROM.NULL*/
					isc_352.isc_362 = FALSE;
					GET_TEXT(/*M.RDB$MAP_FROM*/
						 isc_352.isc_355);
					break;

				case att_map_to_type:
					/*M.RDB$MAP_TO_TYPE.NULL*/
					isc_352.isc_369 = FALSE;
					/*M.RDB$MAP_TO_TYPE*/
					isc_352.isc_370 = (USHORT) get_int32(tdgbl);
					break;

				case att_map_to:
					/*M.RDB$MAP_TO.NULL*/
					isc_352.isc_361 = FALSE;
					GET_TEXT(/*M.RDB$MAP_TO*/
						 isc_352.isc_354);
					break;

				case att_map_description:
					/*M.RDB$DESCRIPTION.NULL*/
					isc_352.isc_360 = FALSE;
					get_source_blob (tdgbl, /*M.RDB$DESCRIPTION*/
								isc_352.isc_353, false);
					break;

				default:
					// msg 299 name mapping
					bad_attribute(scan_next_attr, attribute, 299);
					break;
				}
			}

			if (/*M.RDB$MAP_NAME.NULL*/
			    isc_352.isc_368 || /*M.RDB$MAP_USING.NULL*/
    isc_352.isc_366 ||
				/*M.RDB$MAP_FROM_TYPE.NULL*/
				isc_352.isc_363 || /*M.RDB$MAP_TO_TYPE.NULL*/
    isc_352.isc_369)
			{
				// msg 353 required mapping attributes are missing in backup file
				BURP_error(353, true);
			}

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_mapping_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 446, &isc_352, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL11_1)
	{
		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_auto_map_role:
				l = GET_TEXT(temp);
				role.assign(temp, l);
				break;

			case att_map_to_type:
				get_int32(tdgbl);
				break;

			case att_map_name:
			case att_map_using:
			case att_map_plugin:
			case att_map_db:
			case att_map_from_type:
			case att_map_from:
			case att_map_to:
				GET_TEXT(temp);
				break;

			case att_map_description:
				eat_blob(tdgbl);

			default:
				// msg 299 name mapping
				bad_attribute(scan_next_attr, attribute, 299);
				break;
			}
		}

		if (tdgbl->runtimeODS < DB_VERSION_DDL11_2)
		{
			return true;	// silently skip attributes on old server
		}

		if (tdgbl->firstMap)
		{
			tdgbl->firstMap = false;
			BURP_verbose(301);
			// msg 301, restoring names mapping
		}

		if (role != ADMIN_ROLE)
		{
			BURP_error(300, false);
			return true;
		}

		BURP_verbose(298, ADMIN_ROLE);
		// msg 298, restoring map @1
		Firebird::string sql;
		sql.printf("%s ('%s', %d) %s",
			"UPDATE OR INSERT INTO RDB$ROLES(RDB$ROLE_NAME, RDB$SYSTEM_FLAG) VALUES",
			ADMIN_ROLE, ROLE_FLAG_DBO,
			"MATCHING (RDB$ROLE_NAME)");
		isc_dsql_execute_immediate(tdgbl->status_vector, &tdgbl->db_handle, &tdgbl->tr_handle,
								   sql.length(), sql.c_str(), 1, NULL);
		if (tdgbl->status_vector[1])
		{
			general_on_error ();
		}
	}
	return true;
}

bool is_ascii_name (const TEXT *name, const SSHORT len)
{
/**************************************
 *
 *	i s _ a s c i i _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Check if the input text is valid ASCII uppercased name
 *
 **************************************/
	SSHORT i = 0;

	while (i < len &&
			( (name[i] >= 'A' && name[i] <= 'Z') ||
			(name[i] >= '0' && name[i] <= '9') ||
			  name[i] == '_' || name[i] == '$' ) )
	{
		++i;
	}
	return (i == len);
}

bool get_security_class(BurpGlobals* tdgbl)
{
   struct isc_346_struct {
          ISC_QUAD isc_347;	/* RDB$ACL */
          char  isc_348 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_349;	/* RDB$DESCRIPTION */
          short isc_350;	/* gds__null_flag */
   } isc_346;
/**************************************
 *
 *	g e t _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	Restore a security class record including access control list.
 *
 **************************************/
	att_type	attribute;
	TEXT		temp[GDS_NAME_LEN];
	SSHORT		l = 0;
	scan_attr_t		scan_next_attr;
	bool		is_valid_sec_class = false;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_security_class_req_handle1)
		X IN RDB$SECURITY_CLASSES*/
	{
	
        if (!tdgbl->handles_get_security_class_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (short) sizeof(isc_345), (char*) isc_345);
	if (tdgbl->handles_get_security_class_req_handle1)
	   {
	   isc_346.isc_347 = isc_blob_null;
	   isc_346.isc_349 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_346.isc_350 = TRUE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_class_security_class:
				l = GET_TEXT(/*X.RDB$SECURITY_CLASS*/
					     isc_346.isc_348);

				// Bug fix for bug_no 7299: There was a V3 bug that inserted
				// garbage security class entry when doing GBAK. In order to
				// restore the V3 gbak file with this bad security entry to
				// V4 database. We should check if the security class is a
				// valid ASCII name. If not, skip this entry by setting
				// 'is_valid_sec_class' to false.

				is_valid_sec_class = is_ascii_name(/*X.RDB$SECURITY_CLASS*/
								   isc_346.isc_348, l);
				if (!is_valid_sec_class)
				{
					MISC_terminate (/*X.RDB$SECURITY_CLASS*/
							isc_346.isc_348, temp, l, sizeof(temp));
					BURP_print (false, 234, temp);
					// msg 234   Skipped bad security class entry: %s
					break;
				}

				MISC_terminate (/*X.RDB$SECURITY_CLASS*/
						isc_346.isc_348, temp, l, sizeof(temp));
				BURP_verbose (125, temp);
				// msg 125   restoring security class %s
				break;

			case att_class_acl:
				get_misc_blob (tdgbl, /*X.RDB$ACL*/
						      isc_346.isc_347, false);
				break;

			case att_class_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_346.isc_350 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_346.isc_349, false);
				break;

			case att_class_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_346.isc_350 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_346.isc_349, false);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 131);
				// msg 131 security class
				break;
			}
		}
		// If the security class is not valid ASCII name, don't store it to the
		// database. Simply return from here and the entry is discarded.
		if (!is_valid_sec_class)
		{
			return true;
		}
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_security_class_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 50, &isc_346, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

void get_source_blob(BurpGlobals* tdgbl, ISC_QUAD& blob_id, bool glb_trans)
{
/**************************************
 *
 *	g e t _ s o u r c e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Read source blob and query header attributes and copy data from
 *	input file to nice, shiney, new blob.
 *
 **************************************/
	ISC_STATUS_ARRAY	status_vector;

	SLONG length = get_int32(tdgbl);

	// Create new blob

	UserBlob blob(status_vector);
	isc_tr_handle	local_trans;
	if (glb_trans && tdgbl->global_trans)
		local_trans = tdgbl->global_trans;
	else
		local_trans = gds_trans;

	bool ok;

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		UCHAR bpb[15];
		UCHAR* p = bpb;

		*p++ = isc_bpb_version1;

		*p++ = isc_bpb_source_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_source_interp;
		*p++ = 1;
		*p++ = tdgbl->gbl_sw_fix_fss_metadata_id;

		*p++ = isc_bpb_target_type;
		*p++ = 2;
		put_short(p, isc_blob_text);
		p += 2;
		*p++ = isc_bpb_target_interp;
		*p++ = 1;
		*p++ = CS_UNICODE_FSS;

		ok = blob.create(DB, local_trans, blob_id, p - bpb, bpb);
	}
	else
		ok = blob.create(DB, local_trans, blob_id);

	if (!ok)
	{
		BURP_error_redirect (status_vector, 37);
		// msg 37 isc_create_blob failed
	}

	// Allocate blob buffer if static buffer is too short
	BlobBuffer static_buffer;
	UCHAR* const buffer = static_buffer.getBuffer(length);

	while (length > 0)
	{
		UCHAR* p = buffer;
		while (*p++ = get(tdgbl))
			length--;
		--p;
		--length; // -- or ++ ??? p is decremented, will have to test.
		const USHORT seg_len = p - buffer;

		if (!blob.putSegment(seg_len, buffer))
		{
			BURP_error_redirect (status_vector, 38);
			// msg 38 isc_put_segment failed
		}
	}

	if (!blob.close())
		BURP_error_redirect (status_vector, 23);
		// msg 23 isc_close_blob failed
}

USHORT get_text(BurpGlobals* tdgbl, TEXT* text, ULONG length)
{
/**************************************
 *
 *	g e t _ t e x t
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill.
 *
 **************************************/
	const ULONG l = get(tdgbl);

	if (length <= l)
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated

	if (l)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, l);

	*text = 0;

	return (USHORT) l;
}

USHORT get_text2(BurpGlobals* tdgbl, TEXT* text, ULONG length)
{
/**************************************
 *
 *	g e t _ t e x t 2
 *
 **************************************
 *
 * Functional description
 *	Move a text attribute to a string and fill, using USHORT as length indicator.
 *
 **************************************/
	UCHAR lenstr[sizeof(USHORT)] = "";
	get_block(tdgbl, lenstr, sizeof(lenstr));
	const USHORT len = (USHORT) gds__vax_integer(lenstr, sizeof(lenstr));

	if (length <= len)
	{
		BURP_error_redirect (NULL, 46);
		// msg 46 string truncated
	}

	if (len)
		text = (TEXT*) get_block(tdgbl, (UCHAR*) text, len);

	*text = 0;

	return len;
}

bool get_trigger_old (BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_332_struct {
          char  isc_333 [32];	/* RDB$RELATION_NAME */
          ISC_INT64 isc_334;	/* RDB$TRIGGER_TYPE */
          char  isc_335 [32];	/* RDB$TRIGGER_NAME */
          ISC_QUAD isc_336;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_337;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_338;	/* RDB$DESCRIPTION */
          short isc_339;	/* RDB$TRIGGER_SEQUENCE */
          short isc_340;	/* gds__null_flag */
          short isc_341;	/* RDB$SYSTEM_FLAG */
          short isc_342;	/* gds__null_flag */
          short isc_343;	/* gds__null_flag */
          short isc_344;	/* gds__null_flag */
   } isc_332;
/**************************************
 *
 *	g e t _ t r i g g e r _ o l d
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition for a relation.
 *
 **************************************/
	enum trig_t	type;
	att_type	attribute;
	TEXT		name[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_trigger_old_req_handle1)
		X IN RDB$TRIGGERS*/
	{
	
        if (!tdgbl->handles_get_trigger_old_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (short) sizeof(isc_331), (char*) isc_331);
	if (tdgbl->handles_get_trigger_old_req_handle1)
	   {
	   isc_332.isc_336 = isc_blob_null;
	   isc_332.isc_337 = isc_blob_null;
	   isc_332.isc_338 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_332.isc_344 = TRUE;
		/*X.RDB$TRIGGER_BLR.NULL*/
		isc_332.isc_343 = TRUE;
		/*X.RDB$TRIGGER_SOURCE.NULL*/
		isc_332.isc_342 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_332.isc_341 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_332.isc_340 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_trig_type:
				type = (enum trig_t) get_int32(tdgbl);
				break;

			case att_trig_blr:
				/*X.RDB$TRIGGER_BLR.NULL*/
				isc_332.isc_343 = FALSE;
				get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
						     isc_332.isc_337, false);
				break;

			case att_trig_source:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_332.isc_342 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
						      isc_332.isc_336, false);
				break;

			case att_trig_source2:
				/*X.RDB$TRIGGER_SOURCE.NULL*/
				isc_332.isc_342 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							isc_332.isc_336, false);
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 134);
				// msg 134 trigger
				break;
			}
		}

		// fill in rest of attributes unique to new trigger format

		TEXT* p = /*X.RDB$TRIGGER_NAME*/
			  isc_332.isc_335;
		const TEXT* const end = p + 31;
		const TEXT* q = relation->rel_name;
		while (*q) {
			*p++ = *q++;
		}

		switch (type)
		{
		case trig_pre_store:
			/*X.RDB$TRIGGER_TYPE*/
			isc_332.isc_334 = TRIG_TYPE_PRE_STORE;
			q = "$STORE";
			break;
		case trig_pre_modify:
			/*X.RDB$TRIGGER_TYPE*/
			isc_332.isc_334 = TRIG_TYPE_PRE_MODIFY;
			q = "$MODIFY";
			break;
		case trig_post_erase:
			/*X.RDB$TRIGGER_TYPE*/
			isc_332.isc_334 = TRIG_TYPE_POST_ERASE;
			q = "$ERASE";
			break;
		default:
			bad_attribute(scan_next_attr, attribute, 136);
			// msg 136 trigger type
			return 0;
		}

		while (*q && p < end) {
			*p++ = *q++;
		}
		*p = 0;
		BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
				   isc_332.isc_335);
		// msg 126 restoring trigger %s
		strncpy (/*X.RDB$RELATION_NAME*/
			 isc_332.isc_333, relation->rel_name, GDS_NAME_LEN);
		strcpy (name, /*X.RDB$TRIGGER_NAME*/
			      isc_332.isc_335);
		/*X.RDB$TRIGGER_SEQUENCE*/
		isc_332.isc_339 = TRIGGER_SEQUENCE_DEFAULT;

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_old_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 108, &isc_332, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_15);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_16);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger(BurpGlobals* tdgbl)
{
   struct isc_288_struct {
          char  isc_289 [32];	/* RDB$TRIGGER_NAME */
          ISC_INT64 isc_290;	/* RDB$TRIGGER_TYPE */
          ISC_QUAD isc_291;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_292;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_293;	/* RDB$DESCRIPTION */
          char  isc_294 [32];	/* RDB$RELATION_NAME */
          short isc_295;	/* RDB$TRIGGER_INACTIVE */
          short isc_296;	/* RDB$TRIGGER_SEQUENCE */
          short isc_297;	/* gds__null_flag */
          short isc_298;	/* RDB$FLAGS */
          short isc_299;	/* gds__null_flag */
          short isc_300;	/* RDB$SYSTEM_FLAG */
          short isc_301;	/* gds__null_flag */
          short isc_302;	/* gds__null_flag */
          short isc_303;	/* gds__null_flag */
          short isc_304;	/* gds__null_flag */
   } isc_288;
   struct isc_306_struct {
          char  isc_307 [32];	/* RDB$TRIGGER_NAME */
          ISC_INT64 isc_308;	/* RDB$TRIGGER_TYPE */
          char  isc_309 [256];	/* RDB$ENTRYPOINT */
          char  isc_310 [32];	/* RDB$ENGINE_NAME */
          ISC_QUAD isc_311;	/* RDB$DEBUG_INFO */
          ISC_QUAD isc_312;	/* RDB$TRIGGER_SOURCE */
          ISC_QUAD isc_313;	/* RDB$TRIGGER_BLR */
          ISC_QUAD isc_314;	/* RDB$DESCRIPTION */
          char  isc_315 [32];	/* RDB$RELATION_NAME */
          short isc_316;	/* RDB$TRIGGER_INACTIVE */
          short isc_317;	/* RDB$TRIGGER_SEQUENCE */
          short isc_318;	/* gds__null_flag */
          short isc_319;	/* gds__null_flag */
          short isc_320;	/* gds__null_flag */
          short isc_321;	/* gds__null_flag */
          short isc_322;	/* RDB$VALID_BLR */
          short isc_323;	/* gds__null_flag */
          short isc_324;	/* RDB$FLAGS */
          short isc_325;	/* gds__null_flag */
          short isc_326;	/* RDB$SYSTEM_FLAG */
          short isc_327;	/* gds__null_flag */
          short isc_328;	/* gds__null_flag */
          short isc_329;	/* gds__null_flag */
          short isc_330;	/* gds__null_flag */
   } isc_306;
/**************************************
 *
 *	g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Get a trigger definition in rdb$triggers.
 *
 **************************************/
	att_type	attribute;
	/*BASED_ON RDB$TRIGGERS.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	scan_attr_t		scan_next_attr;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL11_1)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_305), (char*) isc_305);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_306.isc_311 = isc_blob_null;
		   isc_306.isc_312 = isc_blob_null;
		   isc_306.isc_313 = isc_blob_null;
		   isc_306.isc_314 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_306.isc_330 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_306.isc_329 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_306.isc_328 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_306.isc_327 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_306.isc_326 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_306.isc_325 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_306.isc_323 = TRUE;
			/*X.RDB$VALID_BLR.NULL*/
			isc_306.isc_321 = TRUE;
			/*X.RDB$DEBUG_INFO.NULL*/
			isc_306.isc_320 = TRUE;
			/*X.RDB$ENGINE_NAME.NULL*/
			isc_306.isc_319 = TRUE;
			/*X.RDB$ENTRYPOINT.NULL*/
			isc_306.isc_318 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_306.isc_308 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_type2:
					if (tdgbl->RESTORE_format >= 10)
						/*X.RDB$TRIGGER_TYPE*/
						isc_306.isc_308 = get_int64(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_306.isc_324 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_306.isc_323 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_306.isc_328 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_306.isc_313, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_306.isc_327 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_306.isc_312, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_306.isc_327 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_306.isc_312, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_306.isc_307);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_306.isc_307);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_306.isc_307);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_306.isc_330 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_306.isc_315);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_306.isc_317 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_306.isc_329 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_306.isc_314, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_306.isc_329 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_306.isc_314, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_306.isc_326 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_306.isc_325 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_306.isc_316 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$VALID_BLR.NULL*/
						isc_306.isc_321 = FALSE;
						/*X.RDB$VALID_BLR*/
						isc_306.isc_322 = (USHORT) get_int32(tdgbl);
					}
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_debug_info:
					if (tdgbl->RESTORE_format >= 8)
					{
						/*X.RDB$DEBUG_INFO.NULL*/
						isc_306.isc_320 = FALSE;
						get_misc_blob (tdgbl, /*X.RDB$DEBUG_INFO*/
								      isc_306.isc_311, true);
					}
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_engine_name:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ENGINE_NAME*/
							 isc_306.isc_310);
						/*X.RDB$ENGINE_NAME.NULL*/
						isc_306.isc_319 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_entrypoint:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$ENTRYPOINT*/
							 isc_306.isc_309);
						/*X.RDB$ENTRYPOINT.NULL*/
						isc_306.isc_318 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 422, &isc_306, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_trigger_req_handle1)
			X IN RDB$TRIGGERS*/
		{
		
                if (!tdgbl->handles_get_trigger_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (short) sizeof(isc_287), (char*) isc_287);
		if (tdgbl->handles_get_trigger_req_handle1)
		   {
		   isc_288.isc_291 = isc_blob_null;
		   isc_288.isc_292 = isc_blob_null;
		   isc_288.isc_293 = isc_blob_null;

			/*X.RDB$RELATION_NAME.NULL*/
			isc_288.isc_304 = TRUE;
			/*X.RDB$DESCRIPTION.NULL*/
			isc_288.isc_303 = TRUE;
			/*X.RDB$TRIGGER_BLR.NULL*/
			isc_288.isc_302 = TRUE;
			/*X.RDB$TRIGGER_SOURCE.NULL*/
			isc_288.isc_301 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_288.isc_300 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_288.isc_299 = FALSE;
			/*X.RDB$FLAGS.NULL*/
			isc_288.isc_297 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_trig_type:
					/*X.RDB$TRIGGER_TYPE*/
					isc_288.isc_290 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_flags:
					/*X.RDB$FLAGS*/
					isc_288.isc_298 = (USHORT) get_int32(tdgbl);
					/*X.RDB$FLAGS.NULL*/
					isc_288.isc_297 = FALSE;
					break;

				case att_trig_blr:
					/*X.RDB$TRIGGER_BLR.NULL*/
					isc_288.isc_302 = FALSE;
					get_blr_blob (tdgbl, /*X.RDB$TRIGGER_BLR*/
							     isc_288.isc_292, true);
					break;

				case att_trig_source:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_288.isc_301 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
							      isc_288.isc_291, true);
					break;

				case att_trig_source2:
					/*X.RDB$TRIGGER_SOURCE.NULL*/
					isc_288.isc_301 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$TRIGGER_SOURCE*/
								isc_288.isc_291, true);
					break;

				case att_trig_name:
					GET_TEXT(/*X.RDB$TRIGGER_NAME*/
						 isc_288.isc_289);
					strcpy (name, /*X.RDB$TRIGGER_NAME*/
						      isc_288.isc_289);
					BURP_verbose (126, /*X.RDB$TRIGGER_NAME*/
							   isc_288.isc_289);
					// msg 126 restoring trigger %s
					break;

				case att_trig_relation_name:
					/*X.RDB$RELATION_NAME.NULL*/
					isc_288.isc_304 = FALSE;
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_288.isc_294);
					break;

				case att_trig_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					isc_288.isc_296 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_description:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_288.isc_303 = FALSE;
					get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							      isc_288.isc_293, true);
					break;

				case att_trig_description2:
					/*X.RDB$DESCRIPTION.NULL*/
					isc_288.isc_303 = FALSE;
					get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								isc_288.isc_293, true);
					break;

				case att_trig_system_flag:
					/*X.RDB$SYSTEM_FLAG*/
					isc_288.isc_300 = (USHORT) get_int32(tdgbl);
					/*X.RDB$SYSTEM_FLAG.NULL*/
					isc_288.isc_299 = FALSE;
					break;

				case att_trig_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					isc_288.isc_295 = (USHORT) get_int32(tdgbl);
					break;

				case att_trig_valid_blr:
					if (tdgbl->RESTORE_format >= 8)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_debug_info:
					if (tdgbl->RESTORE_format >= 8)
						eat_blob(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_engine_name:
				case att_trig_entrypoint:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				case att_trig_type2:
					if (tdgbl->RESTORE_format >= 10)
						get_int64(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 134);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 134);
					// msg 134 trigger
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 116, &isc_288, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_17);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_18);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_trigger_message(BurpGlobals* tdgbl)
{
   struct isc_278_struct {
          char  isc_279 [1024];	/* RDB$MESSAGE */
          char  isc_280 [32];	/* RDB$TRIGGER_NAME */
          short isc_281;	/* RDB$MESSAGE_NUMBER */
   } isc_278;
   struct isc_285_struct {
          short isc_286;	/* isc_utility */
   } isc_285;
   struct isc_283_struct {
          char  isc_284 [32];	/* RDB$TRIGGER_NAME */
   } isc_283;
/**************************************
 *
 *	g e t _ t r i g g e r _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Get a trigger message text.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$TRIGGER_NAME name;*/
	char
	   name[32];

	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE_NUMBER number*/
	short
	   number
 = -1;
	/*BASED_ON RDB$TRIGGER_MESSAGES.RDB$MESSAGE message;*/
	char
	   message[1024];


	bool sysflag = false;
	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_trigmsg_name:
			GET_TEXT(name);
			sysflag = false;
			/*FOR (REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle1)
				FIRST 1 X IN RDB$TRIGGERS WITH
				X.RDB$SYSTEM_FLAG EQ 1 AND X.RDB$TRIGGER_NAME EQ name*/
			{
                        if (!tdgbl->handles_get_trigger_message_req_handle1)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) sizeof(isc_282), (char*) isc_282);
			isc_vtov ((const char*) name, (char*) isc_283.isc_284, 32);
			if (tdgbl->handles_get_trigger_message_req_handle1)
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_283, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle1, (short) 1, (short) 2, &isc_285, (short) 0);
			   if (!isc_285.isc_286 || isc_status [1]) break;
				sysflag = true;
			/*END_FOR;*/
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			BURP_verbose (127, name);
			// msg 127 restoring trigger message for %s
			break;

		case att_trigmsg_number:
			number = (USHORT) get_int32(tdgbl);
			break;

		case att_trigmsg_text:
			GET_TEXT(message);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 135);
			// msg 135  trigger message
			break;
		}
	}

	if (sysflag)
		return true;

	// Versions prior to FB2.0 don't support a field longer than varchar(78).
	if (tdgbl->runtimeODS < DB_VERSION_DDL11)
		message[78] = 0;

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	/*STORE (TRANSACTION_HANDLE local_trans
			REQUEST_HANDLE tdgbl->handles_get_trigger_message_req_handle2)
		X IN RDB$TRIGGER_MESSAGES*/
	{
	
        if (!tdgbl->handles_get_trigger_message_req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (short) sizeof(isc_277), (char*) isc_277);
	if (tdgbl->handles_get_trigger_message_req_handle2)
	   {
		strcpy (/*X.RDB$TRIGGER_NAME*/
			isc_278.isc_280, name);
		/*X.RDB$MESSAGE_NUMBER*/
		isc_278.isc_281 = number;
		strcpy (/*X.RDB$MESSAGE*/
			isc_278.isc_279, message);
	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_trigger_message_req_handle2, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 1058, &isc_278, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	if (tdgbl->gbl_sw_incremental)
	{
		/*COMMIT*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		// existing ON_ERROR continues past error, beck
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			BURP_print (false, 94, name);
			// msg 94 trigger %s is invalid
			BURP_print_status (false, tdgbl->status_vector);
			/*ROLLBACK;*/
			{
			isc_rollback_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_19);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_20);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	return true;
}

bool get_type(BurpGlobals* tdgbl)
{
   struct isc_269_struct {
          char  isc_270 [32];	/* RDB$FIELD_NAME */
          char  isc_271 [32];	/* RDB$TYPE_NAME */
          ISC_QUAD isc_272;	/* RDB$DESCRIPTION */
          short isc_273;	/* RDB$TYPE */
          short isc_274;	/* gds__null_flag */
          short isc_275;	/* RDB$SYSTEM_FLAG */
          short isc_276;	/* gds__null_flag */
   } isc_269;
/**************************************
 *
 *	g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Get a type definition in rdb$types.
 *
 **************************************/
	att_type	attribute;
	ULONG		len = 0;
	TEXT		temp[GDS_NAME_LEN];
	scan_attr_t		scan_next_attr;

	/*STORE (REQUEST_HANDLE tdgbl->handles_get_type_req_handle1)
		X IN RDB$TYPES*/
	{
	
        if (!tdgbl->handles_get_type_req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (short) sizeof(isc_268), (char*) isc_268);
	if (tdgbl->handles_get_type_req_handle1)
	   {
	   isc_269.isc_272 = isc_blob_null;

		/*X.RDB$DESCRIPTION.NULL*/
		isc_269.isc_276 = TRUE;
		/*X.RDB$SYSTEM_FLAG*/
		isc_269.isc_275 = 0;
		/*X.RDB$SYSTEM_FLAG.NULL*/
		isc_269.isc_274 = FALSE;

		skip_init(&scan_next_attr);
		while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
		{
			switch (attribute)
			{
			case att_type_name:
				len = GET_TEXT(/*X.RDB$TYPE_NAME*/
					       isc_269.isc_271);
				break;

			case att_type_type:
				/*X.RDB$TYPE*/
				isc_269.isc_273 = (USHORT) get_int32(tdgbl);
				break;

			case att_type_field_name:
				GET_TEXT(/*X.RDB$FIELD_NAME*/
					 isc_269.isc_270);
				break;

			case att_type_description:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_269.isc_276 = FALSE;
				get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
						      isc_269.isc_272, false);
				break;

			case att_type_description2:
				/*X.RDB$DESCRIPTION.NULL*/
				isc_269.isc_276 = FALSE;
				get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
							isc_269.isc_272, false);
				break;

			case att_type_system_flag:
				/*X.RDB$SYSTEM_FLAG*/
				isc_269.isc_275 = (USHORT) get_int32(tdgbl);
				/*X.RDB$SYSTEM_FLAG.NULL*/
				isc_269.isc_274 = FALSE;
				break;

			default:
				bad_attribute(scan_next_attr, attribute, 293);
				// msg 293 type (in RDB$TYPES)
				break;
			}
		}

		MISC_terminate (/*X.RDB$TYPE_NAME*/
				isc_269.isc_271, temp, len, sizeof(temp));
		BURP_verbose (128, SafeArg() << temp << /*X.RDB$FIELD_NAME*/
							isc_269.isc_270);
		// msg 128  restoring type %s for field %s

	/*END_STORE;*/
	   
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_type_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 80, &isc_269, (short) 0);
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	return true;
}

bool get_user_privilege(BurpGlobals* tdgbl)
{
   struct isc_255_struct {
          char  isc_256 [32];	/* RDB$RELATION_NAME */
          char  isc_257 [32];	/* RDB$GRANTOR */
          char  isc_258 [32];	/* RDB$USER */
          char  isc_259 [32];	/* RDB$FIELD_NAME */
          short isc_260;	/* gds__null_flag */
          short isc_261;	/* RDB$USER_TYPE */
          short isc_262;	/* gds__null_flag */
          short isc_263;	/* RDB$GRANT_OPTION */
          short isc_264;	/* gds__null_flag */
          short isc_265;	/* RDB$OBJECT_TYPE */
          short isc_266;	/* gds__null_flag */
          char  isc_267 [7];	/* RDB$PRIVILEGE */
   } isc_255;
/**************************************
 *
 *	g e t _ u s e r _ p r i v i l e g e
 *
 **************************************
 *
 * Functional description
 *	Get a user privilege.
 *	Get next interesting user privilege.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;
	USHORT		flags = 0;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER user;*/
	char
	   user[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR grantor;*/
	char
	   grantor[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$PRIVILEGE privilege;*/
	char
	   privilege[7];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION grant_option*/
	short
	   grant_option
 = 0;
	/*BASED_ON RDB$USER_PRIVILEGES.RDB$RELATION_NAME relation_name;*/
	char
	   relation_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$FIELD_NAME field_name;*/
	char
	   field_name[32];

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$USER_TYPE user_type;*/
	short
	   user_type;

	/*BASED_ON RDB$USER_PRIVILEGES.RDB$OBJECT_TYPE object_type;*/
	short
	   object_type;


	user_type = obj_user;
	object_type = obj_relation;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_priv_user:
			// default USER_TYPE to USER
			flags |= USER_PRIV_USER;
			GET_TEXT(user);
			BURP_verbose (123, user);
			// msg 123 restoring privilege for user %s
			break;

		case att_priv_grantor:
			flags |= USER_PRIV_GRANTOR;
			GET_TEXT(grantor);
			break;

		case att_priv_privilege:
			flags |= USER_PRIV_PRIVILEGE;
			GET_TEXT(privilege);
			break;

		case att_priv_grant_option:
			flags |= USER_PRIV_GRANT_OPTION;
			grant_option = (USHORT) get_int32(tdgbl);
			break;

		case att_priv_object_name:
			flags |= USER_PRIV_OBJECT_NAME;
			// default OBJECT_TYPE to RELATION
			GET_TEXT(relation_name);
			break;

		case att_priv_field_name:
			flags |= USER_PRIV_FIELD_NAME;
			GET_TEXT(field_name);
			break;

		case att_priv_user_type:
			flags |= USER_PRIV_USER_TYPE;
			user_type = (USHORT) get_int32(tdgbl);
			break;

		case att_priv_obj_type:
			flags |= USER_PRIV_OBJECT_TYPE;
			object_type = (USHORT) get_int32(tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 105);
			// msg 105 privilege
			break;
		}
	}

	// Check if object exists
	isc_tr_handle	local_trans = 0;
	bool exists = false;
	switch (object_type)
	{
	case obj_package_header:
		{
		for (const burp_pkg* pkg = tdgbl->packages; pkg; pkg = pkg->pkg_next)
			if (strcmp(pkg->pkg_name, relation_name) == 0)
			{
				exists = true;
				local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
				break;
			}
		}
		break;

	case obj_procedure:
		{
		for (const burp_prc* proc = tdgbl->procedures; proc; proc = proc->prc_next)
			if (!proc->prc_package[0] && strcmp(proc->prc_name, relation_name) == 0)
			{
				exists = true;
				local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
				break;
			}
		}
		break;

	case obj_relation:
		{
		for (const burp_rel* rel = tdgbl->relations; rel; rel = rel->rel_next)
			if (strcmp(rel->rel_name, relation_name) == 0)
			{
				exists = true;
				if (rel->rel_flags & REL_view)
					local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;
			break;
			}
		}
		break;

	default:
		exists = true;
		break;
	}

	if (object_type == obj_package_header)
	{
		if (tdgbl->RESTORE_format < 10)
			return false;

		// Discard packages for engine < FB3
		if (tdgbl->runtimeODS < DB_VERSION_DDL12)
			exists = false;
	}

	if (tdgbl->runtimeODS <= DB_VERSION_DDL8)
	{
		// Discard roles for IB4.
		if (user_type == obj_sql_role || object_type == obj_sql_role)
			exists = false;
	}

	if (exists)
	{
		if (!local_trans)
			local_trans = gds_trans;

		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_user_privilege_req_handle1)
			X IN RDB$USER_PRIVILEGES*/
		{
		
                if (!tdgbl->handles_get_user_privilege_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (short) sizeof(isc_254), (char*) isc_254);
		if (tdgbl->handles_get_user_privilege_req_handle1)
		   {

			/*X.RDB$FIELD_NAME.NULL*/
			isc_255.isc_266 = TRUE;
			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_255.isc_264 = TRUE;

			if (flags & USER_PRIV_USER)
				strcpy (/*X.RDB$USER*/
					isc_255.isc_258, user);

			if (flags & USER_PRIV_GRANTOR)
				strcpy (/*X.RDB$GRANTOR*/
					isc_255.isc_257, grantor);

			if (flags & USER_PRIV_PRIVILEGE)
				strcpy (/*X.RDB$PRIVILEGE*/
					isc_255.isc_267, privilege);

			if (flags & USER_PRIV_GRANT_OPTION)
			{
				/*X.RDB$GRANT_OPTION*/
				isc_255.isc_263 = grant_option;
				if (grant_option == 0)
					/*X.RDB$GRANT_OPTION.NULL*/
					isc_255.isc_262 = TRUE;
				else
					/*X.RDB$GRANT_OPTION.NULL*/
					isc_255.isc_262 = FALSE;
			}

			if (flags & USER_PRIV_OBJECT_NAME)
				strcpy (/*X.RDB$RELATION_NAME*/
					isc_255.isc_256, relation_name);

			if (flags & USER_PRIV_FIELD_NAME)
			{
				/*X.RDB$FIELD_NAME.NULL*/
				isc_255.isc_266 = FALSE;
				strcpy (/*X.RDB$FIELD_NAME*/
					isc_255.isc_259, field_name);
			}

			// USER_TYPE & OBJECT_TYPE are fields that did not exist before
			// V4.0. So, we have to reconstruct them and initialize them to
			// reasonable values. If they existed before then user_type and
			// object_type contain the proper values. If they didn't exist
			// then user_type and object_type contain the reasonable default
			// values.

			/*X.RDB$USER_TYPE.NULL*/
			isc_255.isc_260 = FALSE;
			/*X.RDB$USER_TYPE*/
			isc_255.isc_261 = user_type;

			/*X.RDB$OBJECT_TYPE.NULL*/
			isc_255.isc_264 = FALSE;
			/*X.RDB$OBJECT_TYPE*/
			isc_255.isc_265 = object_type;

			// If OBJECT_TYPE didn't exist before and we have a field level
			// user privileges, then use obj_field instead.

			// NOTE: Scanning the V4.0 code base, obj_field has never been
			// used at all. The following code should be uncommented
			// in case we ever introduce obj_field to the picture.

/***********************************************************
			if ( !(flags & USER_PRIV_OBJECT_TYPE) )
			{
				if ( flags & USER_PRIV_FIELD_NAME )
				{
					X.RDB$OBJECT_TYPE = obj_field;
				}
			}
***********************************************************/

		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_user_privilege_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 149, &isc_255, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

bool get_view(BurpGlobals* tdgbl, burp_rel* relation)
{
   struct isc_239_struct {
          char  isc_240 [256];	/* RDB$CONTEXT_NAME */
          char  isc_241 [32];	/* RDB$RELATION_NAME */
          char  isc_242 [32];	/* RDB$VIEW_NAME */
          short isc_243;	/* RDB$VIEW_CONTEXT */
   } isc_239;
   struct isc_245_struct {
          char  isc_246 [256];	/* RDB$CONTEXT_NAME */
          char  isc_247 [32];	/* RDB$RELATION_NAME */
          char  isc_248 [32];	/* RDB$PACKAGE_NAME */
          char  isc_249 [32];	/* RDB$VIEW_NAME */
          short isc_250;	/* RDB$VIEW_CONTEXT */
          short isc_251;	/* gds__null_flag */
          short isc_252;	/* gds__null_flag */
          short isc_253;	/* RDB$CONTEXT_TYPE */
   } isc_245;
/**************************************
 *
 *	g e t _ v i e w
 *
 **************************************
 *
 * Functional description
 *	Store a record in RDB$VIEW_RELATIONS.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// If there is a global transaction then use it

	isc_tr_handle local_trans = tdgbl->global_trans ? tdgbl->global_trans : gds_trans;

	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_view_req_handle1)
			X IN RDB$VIEW_RELATIONS*/
		{
		
                if (!tdgbl->handles_get_view_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (short) sizeof(isc_244), (char*) isc_244);
		if (tdgbl->handles_get_view_req_handle1)
		   {

			strcpy (/*X.RDB$VIEW_NAME*/
				isc_245.isc_249, relation->rel_name);
			/*X.RDB$CONTEXT_TYPE.NULL*/
			isc_245.isc_252 = TRUE;
			/*X.RDB$PACKAGE_NAME.NULL*/
			isc_245.isc_251 = TRUE;

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_view_relation_name:
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_245.isc_247);
					break;

				case att_view_context_name:
					GET_TEXT(/*X.RDB$CONTEXT_NAME*/
						 isc_245.isc_246);
					if (tdgbl->runtimeODS < DB_VERSION_DDL11_2)
					{
						// Cannot use MAX_SQL_IDENTIFIER_LEN because this value shouldn't be upgraded.
						/*X.RDB$CONTEXT_NAME*/
						isc_245.isc_246[31] = 0;
					}
					break;

				case att_view_context_id:
					/*X.RDB$VIEW_CONTEXT*/
					isc_245.isc_250 = (USHORT) get_int32(tdgbl);
					break;

				case att_view_context_type:
					if (tdgbl->RESTORE_format >= 10)
					{
						/*X.RDB$CONTEXT_TYPE*/
						isc_245.isc_253 = (USHORT) get_int32(tdgbl);
						/*X.RDB$CONTEXT_TYPE.NULL*/
						isc_245.isc_252 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 140);
					break;

				case att_view_context_package:
					if (tdgbl->RESTORE_format >= 10)
					{
						GET_TEXT(/*X.RDB$PACKAGE_NAME*/
							 isc_245.isc_248);
						/*X.RDB$PACKAGE_NAME.NULL*/
						isc_245.isc_251 = FALSE;
					}
					else
						bad_attribute(scan_next_attr, attribute, 140);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 140);
					// msg 140 view
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 360, &isc_245, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (TRANSACTION_HANDLE local_trans
				REQUEST_HANDLE tdgbl->handles_get_view_req_handle1)
			X IN RDB$VIEW_RELATIONS*/
		{
		
                if (!tdgbl->handles_get_view_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (short) sizeof(isc_238), (char*) isc_238);
		if (tdgbl->handles_get_view_req_handle1)
		   {

			strcpy (/*X.RDB$VIEW_NAME*/
				isc_239.isc_242, relation->rel_name);

			skip_init(&scan_next_attr);
			while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_end)
			{
				switch (attribute)
				{
				case att_view_relation_name:
					GET_TEXT(/*X.RDB$RELATION_NAME*/
						 isc_239.isc_241);
					break;

				case att_view_context_name:
					GET_TEXT(/*X.RDB$CONTEXT_NAME*/
						 isc_239.isc_240);
					if (tdgbl->runtimeODS < DB_VERSION_DDL11_2)
					{
						// Cannot use MAX_SQL_IDENTIFIER_LEN because this value shouldn't be upgraded.
						/*X.RDB$CONTEXT_NAME*/
						isc_239.isc_240[31] = 0;
					}
					break;

				case att_view_context_id:
					/*X.RDB$VIEW_CONTEXT*/
					isc_239.isc_243 = (USHORT) get_int32(tdgbl);
					break;

				case att_view_context_type:
					if (tdgbl->RESTORE_format >= 10)
						get_int32(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 140);
					break;

				case att_view_context_package:
					if (tdgbl->RESTORE_format >= 10)
						eat_text(tdgbl);
					else
						bad_attribute(scan_next_attr, attribute, 140);
					break;

				default:
					bad_attribute(scan_next_attr, attribute, 140);
					// msg 140 view
					break;
				}
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_get_view_req_handle1, (FB_API_HANDLE*) &local_trans, (short) 0, (short) 322, &isc_239, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	return true;
}

void ignore_array(BurpGlobals* tdgbl, burp_rel* relation)
{
/**************************************
 *
 *	i g n o r e _ a r r a y
 *
 **************************************
 *
 * Functional description
 *	Ignore data from input file, like a
 *	dummy get_array().
 *
 **************************************/
	burp_fld* field = NULL;
	att_type attribute;
	SLONG* range;
	const SLONG* end_ranges;
	USHORT field_number;
	scan_attr_t scan_next_attr;

	// Pick up attributes

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			field_number = (USHORT) get_int32(tdgbl);
			for (field = relation->rel_fields; field; field = field->fld_next)
			{
				if (field->fld_number == field_number)
					break;
			}
			if (!field)
				BURP_error_redirect (NULL, 36);
				// msg 36 Can't find field for blob
			break;

		case att_array_dimensions:
			field->fld_dimensions = (SSHORT) get_int32(tdgbl);
			end_ranges = field->fld_ranges + 2 * field->fld_dimensions;
			for (range = field->fld_ranges; range < end_ranges; range += 2)
			{
				if (get_attribute(&attribute, tdgbl) != att_array_range_low)
					bad_attribute(scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[0] = get_int32(tdgbl);
				if (get_attribute(&attribute, tdgbl) != att_array_range_high)
					bad_attribute(scan_next_attr, attribute, 58);
					// msg 58 array
				else
					range[1] = get_int32(tdgbl);
			}
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 58);
			// msg 58 array
			break;
		}
	}

	SLONG length = get(tdgbl);
	length |= get(tdgbl) << 8;
	length |= get(tdgbl) << 16;
	length |= get(tdgbl) << 24;

	SLONG lcount = 0;
	if (tdgbl->gbl_sw_transportable)
	{
		if (get_attribute(&attribute, tdgbl) != att_xdr_array)
			BURP_error_redirect (NULL, 55);
			// msg 55 Expected XDR record length
		else
		{
			lcount = get(tdgbl);
			lcount |= get(tdgbl) << 8;
			lcount |= get(tdgbl) << 16;
			lcount |= get(tdgbl) << 24;
		}
	}
	else
	{
		lcount = length;
	}

	if (lcount)
		get_skip(tdgbl, lcount);
}

void ignore_blob(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	i g n o r e _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Skip over blob data records.
 *
 **************************************/
	att_type	attribute;
	scan_attr_t		scan_next_attr;

	// Pick up attributes

	SLONG segments = 0;

	skip_init(&scan_next_attr);
	while (skip_scan(&scan_next_attr), get_attribute(&attribute, tdgbl) != att_blob_data)
	{
		switch (attribute)
		{
		case att_blob_field_number:
			get_int32(tdgbl);
			break;

		case att_blob_max_segment:
			get_int32(tdgbl);
			break;

		case att_blob_number_segments:
			segments = get_int32(tdgbl);
			break;

		case att_blob_type:
			get_int32(tdgbl);
			break;

		default:
			bad_attribute(scan_next_attr, attribute, 64);
			// msg 64 blob
			break;
		}
	}

	// Eat up blob segments

	while (--segments >= 0)
	{
		USHORT length = get(tdgbl);
		length |= get(tdgbl) << 8;
		if (length)
			get_skip(tdgbl, length);
	}
}

rec_type ignore_data(BurpGlobals* tdgbl, burp_rel* relation)
{
/**************************************
 *
 *	i g n o r e _ d a t a
 *
 **************************************
 *
 * Functional description
 *	Ignore data records for a relation.
 *
 **************************************/
	ULONG records = 0;
	rec_type record;

	while (true)
	{
		if (get(tdgbl) != att_data_length)
			BURP_error_redirect (NULL, 39);
			// msg 39 expected record length
		USHORT len = (USHORT) get_int32(tdgbl);
		if (tdgbl->gbl_sw_transportable)
		{
			if (get(tdgbl) != att_xdr_length)
				BURP_error_redirect (NULL, 55);
				// msg 55 Expected XDR record length
			else
				len = (USHORT) get_int32(tdgbl);
		}
		if (get(tdgbl) != att_data_data)
			BURP_error_redirect (NULL, 41);
			// msg 41 expected data attribute
		if (len)
		{
			if (tdgbl->gbl_sw_compress)
			{
				UCHAR* buffer = (UCHAR*) BURP_alloc (len);
				decompress (tdgbl, buffer, len);
				BURP_free (buffer);
			}
			else
				get_skip(tdgbl, len);
		}
		++records;

		while (get_record(&record, tdgbl))
		{
			if (record == rec_blob)
				ignore_blob(tdgbl);
			else if (record == rec_array)
				ignore_array (tdgbl, relation);
			else
				break;
		}
		if (record != rec_data)
			break;
	}

	BURP_verbose (106, SafeArg() << records);
	// msg 106 %ld records ignored

	return record;
}

void realign(BurpGlobals* tdgbl, UCHAR* buffer, const burp_rel* relation)
{
/**************************************
 *
 *	r e a l i g n
 *
 **************************************
 *
 * Functional description
 *	Miserable input record is misaligned.
 *	Shuffle fields around.  N.B. this one
 *	only works if the old buffer is longer
 *	than the new.
 *
 **************************************/
	UCHAR* p = NULL;
	const UCHAR* q = NULL;

	for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;

		p = buffer + field->fld_offset;
		q = buffer + field->fld_old_offset;
		USHORT l = field->fld_length;

		// CVC: This code assumes fld_offset < fld_old_offset,
		// why not use memmove() instead?

		// Beware of overlaps here - don't use memcpy
		while (l--) {
			*p++ = *q++;
		}

		if (field->fld_type == blr_varying)
		{
			*p++ = *q++;
			*p++ = *q++;
		}
	}

	// If this is format version 2 or greater, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			p = buffer + FB_ALIGN(p - buffer, sizeof(SSHORT));
			q = buffer + FB_ALIGN(q - buffer, sizeof(SSHORT));
			*p++ = *q++;
			*p++ = *q++;
		}
	}
}

#ifdef sparc
USHORT recompute_length(BurpGlobals* tdgbl, burp_rel* relation)
{
/**************************************
 *
 *	r e c o m p u t e _ l e n g t h
 *
 **************************************
 *
 * Functional description
 *	Recompute length of a record using an old
 *	alignment if there is one.  At the moment,
 *	only SPARC has one.
 *
 **************************************/

	ULONG	offset = 0; // there was garbage, possibly nobody uses sparc define?
	const SSHORT* alignments = old_sparcs;

	for (burp_fld* field = relation->rel_fields; field; field = field->fld_next)
	{
		if (field->fld_flags & FLD_computed)
			continue;
		ULONG length = field->fld_length;
		// ULONG alignment = 4; useless, see assignment below

		// arrays are of various fld_types but are really blobs

		ULONG dtype = field->fld_type;

		if (field->fld_flags & FLD_array)
		{
			dtype = blr_blob;
			length = 8;
		}

		const ULONG alignment = alignments[gds_cvt_blr_dtype[field->fld_type]];
		if (dtype == blr_varying)
			length += sizeof(USHORT);

		if (alignment)
			offset = FB_ALIGN(offset, alignment);
		field->fld_old_offset = offset;
		offset += length;
	}

	// If this is format version 2, build fields for null flags

	if (tdgbl->RESTORE_format >= 2)
	{
		for (const burp_fld* field = relation->rel_fields; field; field = field->fld_next)
		{
			if (field->fld_flags & FLD_computed)
				continue;
			offset = FB_ALIGN(offset, sizeof(SSHORT));
			offset += sizeof(SSHORT);
		}
	}

	return offset;
}
#endif

bool restore(BurpGlobals* tdgbl, const TEXT* file_name, const TEXT* database_name)
{
   struct isc_182_struct {
          short isc_183;	/* isc_utility */
   } isc_182;
   struct isc_179_struct {
          double isc_180;	/* RDB$STATISTICS */
          short isc_181;	/* gds__null_flag */
   } isc_179;
   struct isc_175_struct {
          double isc_176;	/* RDB$STATISTICS */
          short isc_177;	/* isc_utility */
          short isc_178;	/* gds__null_flag */
   } isc_175;
   struct isc_189_struct {
          short isc_190;	/* isc_utility */
   } isc_189;
   struct isc_187_struct {
          short isc_188;	/* isc_utility */
   } isc_187;
   struct isc_185_struct {
          short isc_186;	/* isc_utility */
   } isc_185;
   struct isc_200_struct {
          short isc_201;	/* isc_utility */
   } isc_200;
   struct isc_197_struct {
          char  isc_198 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          short isc_199;	/* gds__null_flag */
   } isc_197;
   struct isc_192_struct {
          char  isc_193 [32];	/* RDB$DEFAULT_COLLATE_NAME */
          char  isc_194 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_195;	/* isc_utility */
          short isc_196;	/* gds__null_flag */
   } isc_192;
   struct isc_205_struct {
          short isc_206;	/* isc_utility */
          short isc_207;	/* RDB$CHARACTER_SET_ID */
   } isc_205;
   struct isc_203_struct {
          char  isc_204 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_203;
   struct isc_211_struct {
          short isc_212;	/* isc_utility */
          short isc_213;	/* RDB$CHARACTER_SET_ID */
   } isc_211;
   struct isc_209_struct {
          char  isc_210 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_209;
   struct isc_220_struct {
          short isc_221;	/* isc_utility */
   } isc_220;
   struct isc_218_struct {
          ISC_LONG isc_219;	/* RDB$LINGER */
   } isc_218;
   struct isc_215_struct {
          ISC_LONG isc_216;	/* RDB$LINGER */
          short isc_217;	/* isc_utility */
   } isc_215;
   struct isc_228_struct {
          short isc_229;	/* isc_utility */
   } isc_228;
   struct isc_226_struct {
          char  isc_227 [32];	/* RDB$CHARACTER_SET_NAME */
   } isc_226;
   struct isc_223_struct {
          char  isc_224 [32];	/* RDB$CHARACTER_SET_NAME */
          short isc_225;	/* isc_utility */
   } isc_223;
   struct isc_236_struct {
          short isc_237;	/* isc_utility */
   } isc_236;
   struct isc_234_struct {
          ISC_QUAD isc_235;	/* RDB$DESCRIPTION */
   } isc_234;
   struct isc_231_struct {
          ISC_QUAD isc_232;	/* RDB$DESCRIPTION */
          short isc_233;	/* isc_utility */
   } isc_231;
/**************************************
 *
 *	r e s t o r e
 *
 **************************************
 *
 * Functional description
 *	Perform the body of restore.
 *
 **************************************/

	// Read burp record first

	MVOL_init_read (file_name, &tdgbl->RESTORE_format, &tdgbl->io_cnt, &tdgbl->io_ptr);

	if (tdgbl->gbl_sw_transportable)
		BURP_verbose (133);
		// msg 133 transportable backup -- data in XDR format
	if (tdgbl->gbl_sw_compress)
		BURP_verbose (61);
		// msg 61 backup file is compressed


	// restore only from those backup files created by current or previous GBAK

	if (tdgbl->RESTORE_format < 1 || tdgbl->RESTORE_format > ATT_BACKUP_FORMAT)
	{
		BURP_error(344, true, SafeArg() << tdgbl->RESTORE_format << 1 << ATT_BACKUP_FORMAT);
		// msg 44 Expected backup version @2..@3.  Found @1
	}

	BURP_verbose(349, SafeArg() << tdgbl->RESTORE_format); // backup version is @1

	create_database(tdgbl, database_name);

	/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_21);
	SQLCODE = isc_sqlcode(isc_status);
	}
	if (gds_status[1])
		/*EXEC SQL SET TRANSACTION;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_22);
		SQLCODE = isc_sqlcode(isc_status);
		}

	// For V4.0, start a read commited transaction.  This will be used
	// to create blobs for global fields and update the record in the
	// RDB$FIELDS table.

	/*EXEC SQL SET TRANSACTION NAME tdgbl->global_trans ISOLATION LEVEL READ COMMITTED;*/
	{
	isc_start_transaction (isc_status, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 1, &DB, (short) 5, isc_tpb_23);
	SQLCODE = isc_sqlcode(isc_status);
	}

	detectRuntimeODS();
	if (tdgbl->runtimeODS < DB_VERSION_OLDEST_SUPPORTED)
	{
		BURP_error(51, true, SafeArg() << tdgbl->runtimeODS);
		// msg 51 database format %ld is too old to restore to
	}

	BURP_verbose (129);
	// msg 129 started transaction

	att_type	attribute;
	isc_req_handle  req_handle2 = 0, req_handle3 = 0, req_handle4 = 0;

	while (get_attribute(&attribute, tdgbl) != att_end)
	{
		switch (attribute)
		{
		case att_database_security_class:
			// Instead of updating the security class in RDB$DATABASE,
			// just store the value in tdgbl. It will be updated at
			// the very end to prevent security class validation
			// failures during change table ownership operation
			GET_TEXT(tdgbl->database_security_class);
			break;

		case att_database_description:
		case att_database_description2:
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_230), (char*) isc_230);
			if (req_handle2)
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 10, &isc_231, (short) 0);
			   if (!isc_231.isc_233 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					if (attribute == att_database_description2)
						get_source_blob (tdgbl, /*X.RDB$DESCRIPTION*/
									isc_231.isc_232, false);
					else
						get_misc_blob (tdgbl, /*X.RDB$DESCRIPTION*/
								      isc_231.isc_232, false);
				/*END_MODIFY;*/
				isc_234.isc_235 = isc_231.isc_232;
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 8, &isc_234, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_236, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		case att_database_dfl_charset:
			/*FOR (REQUEST_HANDLE req_handle3)
				X IN RDB$DATABASE*/
			{
                        if (!req_handle3)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_222), (char*) isc_222);
			if (req_handle3)
                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 0, (short) 34, &isc_223, (short) 0);
			   if (!isc_223.isc_225 || isc_status [1]) break;
				/*MODIFY X USING*/
				{
					GET_TEXT(/*X.RDB$CHARACTER_SET_NAME*/
						 isc_223.isc_224);
				/*END_MODIFY;*/
				isc_ftof (isc_223.isc_224, 32, isc_226.isc_227, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 32, &isc_226, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 2, (short) 2, &isc_228, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
			break;

		case att_database_linger:
			if (tdgbl->RESTORE_format >= 10)
			{
				if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
				{
					/*FOR (REQUEST_HANDLE req_handle4)
						X IN RDB$DATABASE*/
					{
                                        if (!req_handle4)
                                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_214), (char*) isc_214);
					if (req_handle4)
                                           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0);
					if (!isc_status [1]) {
					while (1)
					   {
                                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 0, (short) 6, &isc_215, (short) 0);
					   if (!isc_215.isc_217 || isc_status [1]) break;
						/*MODIFY X USING*/
						{
							/*X.RDB$LINGER*/
							isc_215.isc_216 = get_int32(tdgbl);
						/*END_MODIFY;*/
						isc_218.isc_219 = isc_215.isc_216;
                                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 4, &isc_218, (short) 0);;
						/*ON_ERROR*/
						if (isc_status [1])
						   {
							general_on_error();
						/*END_ERROR;*/
						   }
						}
					/*END_FOR;*/
                                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 2, &isc_220, (short) 0);
					   }
					   };
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error();
					/*END_ERROR;*/
					   }
					}
				}
				else
					get_int32(tdgbl);
			}
			else
			{
				// Functions that use scan_next_attr initialize it to NO_SKIP using skip_init().
				// Here we don't use that logic, hence the first param to bad_attribute is hardcoded.
				bad_attribute(NO_SKIP, attribute, 352);
			}
			break;

		default:
			{
			SSHORT l = get(tdgbl);
			if (l)
				get_skip(tdgbl, l);
			break;
			}
		}
	}

	MISC_release_request_silent(req_handle2);
	MISC_release_request_silent(req_handle3);
	MISC_release_request_silent(req_handle4);

	if (tdgbl->gbl_sw_fix_fss_data)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_data;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_208), (char*) isc_208);
		isc_vtov ((const char*) name.c_str(), (char*) isc_209.isc_210, 32);
		if (req_handle3)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_209, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_211, (short) 0);
		   if (!isc_211.isc_212 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_data_id = /*X.RDB$CHARACTER_SET_ID*/
							isc_211.isc_213;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_data);
	}

	if (tdgbl->gbl_sw_fix_fss_metadata)
	{
		bool found = false;
		Firebird::string name = tdgbl->gbl_sw_fix_fss_metadata;
		name.upper();

		req_handle3 = 0;

		/*FOR (REQUEST_HANDLE req_handle3)
			X IN RDB$CHARACTER_SETS
			WITH X.RDB$CHARACTER_SET_NAME EQ name.c_str()*/
		{
                if (!req_handle3)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle3, (short) sizeof(isc_202), (char*) isc_202);
		isc_vtov ((const char*) name.c_str(), (char*) isc_203.isc_204, 32);
		if (req_handle3)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle3, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_203, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle3, (short) 1, (short) 4, &isc_205, (short) 0);
		   if (!isc_205.isc_206 || isc_status [1]) break;

			tdgbl->gbl_sw_fix_fss_metadata_id = /*X.RDB$CHARACTER_SET_ID*/
							    isc_205.isc_207;
			found = true;

		/*END_FOR;*/
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle3);

		if (!found)
			BURP_error(305, true, SafeArg() << tdgbl->gbl_sw_fix_fss_metadata);
	}

	// If this should be a multi-file database, add the files

	if (tdgbl->gbl_sw_files && tdgbl->gbl_sw_files->fil_next)
		add_files(tdgbl, database_name);

	// Get global fields and relations

	bool flag_norel = true;	// To fix bug 10098
	bool flag = false;
	rec_type record;

	while (get_record(&record, tdgbl) != rec_end)
	{
		switch (record)
		{
		case rec_charset:
			if (!get_character_set(tdgbl))
				return false;
			flag = true;
			break;

		case rec_collation:
			if (!get_collation(tdgbl))
				return false;
			flag = true;
			break;

		case rec_chk_constraint:
			if (!get_chk_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_global_field:
			if (!get_global_field(tdgbl))
				return false;
			flag = true;
			break;

		case rec_field_dimensions:
			if (!get_field_dimensions(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation:
			if (!get_relation(tdgbl))
				return false;
			flag = true;
			flag_norel = false;
			break;

		case rec_ref_constraint:
			if (!get_ref_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_rel_constraint:
			if (!get_rel_constraint(tdgbl))
				return false;
			flag = true;
			break;

		case rec_function:
			if (!get_function(tdgbl))
				return false;
			flag = true;
			break;

		case rec_package:
			if (!get_package(tdgbl))
				return false;
			flag = true;
			break;

		case rec_procedure:
			if (!get_procedure(tdgbl))
				return false;
			flag = true;
			break;

		case rec_exception:
			if (!get_exception(tdgbl))
				return false;
			flag = true;
			break;

		case rec_system_type:  // rdb$types
			if (!get_type(tdgbl))
				return false;
			flag = true;
			break;

		case rec_filter:  // rdb$filters
			if (!get_filter(tdgbl))
				return false;
			flag = true;
			break;

		case rec_generator:
			if (!get_generator(tdgbl))
				return false;
			flag = true;
			break;

		case rec_relation_data:
			if (flag)
			{
				BURP_verbose (68);
				// msg 68 committing meta data
				/*COMMIT;*/
				{
				isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					general_on_error ();
				/*END_ERROR;*/
				   }
				}
				/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
				{
				isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_24);
				SQLCODE = isc_sqlcode(isc_status);
				}
				if (gds_status[1])
					/*EXEC SQL SET TRANSACTION;*/
					{
					isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_25);
					SQLCODE = isc_sqlcode(isc_status);
					}
				flag = false;
			}
			if (!get_relation_data(tdgbl))
				return false;
			break;

		case rec_trigger:  // new trigger type
			if (!get_trigger(tdgbl))
				return false;
			flag = true;
			break;

		case rec_trigger_message:
			if (!get_trigger_message(tdgbl))
				return false;
			flag = true;
			break;

		case rec_user_privilege:
			if (!get_user_privilege(tdgbl))
				return false;
			flag = true;
			break;

		case rec_security_class:
			if (!get_security_class(tdgbl))
				return false;
			flag = true;
			break;

		case rec_files:
			if (!get_files(tdgbl))
				return false;
			flag = true;
			break;

		case rec_sql_roles:
			if (!get_sql_roles(tdgbl))
				return false;
			flag = true;
			break;

		case rec_mapping:
			if (!get_mapping(tdgbl))
				return false;
			flag = true;
			break;

		default:
			BURP_error(43, true, SafeArg() << record);
			// msg 43 don't recognize record type %ld
			break;
		}
	}

	if (tdgbl->defaultCollations.getCount() > 0)
	{
		isc_req_handle req_handle5 = 0;

		/*FOR (REQUEST_HANDLE req_handle5)
			CS IN RDB$CHARACTER_SETS*/
		{
                if (!req_handle5)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_191), (char*) isc_191);
		if (req_handle5)
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 0, (short) 68, &isc_192, (short) 0);
		   if (!isc_192.isc_195 || isc_status [1]) break;

			for (size_t i = 0; i < tdgbl->defaultCollations.getCount(); ++i)
			{
				if (tdgbl->defaultCollations[i].first == /*CS.RDB$CHARACTER_SET_NAME*/
									 isc_192.isc_194)
				{
					/*MODIFY CS*/
					{;
						/*CS.RDB$DEFAULT_COLLATE_NAME.NULL*/
						isc_192.isc_196 = FALSE;
						strcpy(/*CS.RDB$DEFAULT_COLLATE_NAME*/
						       isc_192.isc_193,
							tdgbl->defaultCollations[i].second.c_str());
					/*END_MODIFY;*/
					isc_ftof (isc_192.isc_193, 32, isc_197.isc_198, 32);
					isc_197.isc_199 = isc_192.isc_196;
                                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 34, &isc_197, (short) 0);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						general_on_error ();
					/*END_ERROR;*/
					   }
					}
				}
			}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_200, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle5);
	}

	// This piece of code is to fix bug 10098: restore of database with
	// only domains and no relations aborts with the message ERROR: deadlock
	// This is because insertion of domains into RDB$FIELDS is happening in
	// the default transaction, whereas updation of RDB$FIELDS to add
	// constraints to the domains is done in tdgbl->global_trans. In case of
	// no relations, no COMMIT of default transaction occurs till this point
	// because of which rows in RDB$FIELDS for domains are still locked by
	// default transaction. The below code COMMITs the default transaction
	// in that particular situation

	if (flag_norel)
	{
		/*COMMIT;*/
		{
		isc_commit_transaction (isc_status, (FB_API_HANDLE*) &gds_trans);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*EXEC SQL SET TRANSACTION NO_AUTO_UNDO;*/
		{
		isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 5, isc_tpb_26);
		SQLCODE = isc_sqlcode(isc_status);
		}
		if (gds_status[1])
			/*EXEC SQL SET TRANSACTION;*/
			{
			isc_start_transaction (isc_status, (FB_API_HANDLE*) &gds_trans, (short) 1, &DB, (short) 4, isc_tpb_27);
			SQLCODE = isc_sqlcode(isc_status);
			}
	}

	// put validation clauses for global fields

	update_global_field(tdgbl);

	// Purge shadow metadata if necessary

	if (tdgbl->gbl_sw_kill)
	{
		isc_req_handle req_handle5 = 0;

		/*FOR (REQUEST_HANDLE req_handle5)
			FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER NOT MISSING
			AND FIL.RDB$SHADOW_NUMBER NE 0*/
		{
                if (!req_handle5)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle5, (short) sizeof(isc_184), (char*) isc_184);
		if (req_handle5)
                   isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle5, (FB_API_HANDLE*) &gds_trans, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 0, (short) 2, &isc_185, (short) 0);
		   if (!isc_185.isc_186 || isc_status [1]) break;
		/*ERASE FIL;*/
		{
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 1, (short) 2, &isc_187, (short) 0);
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle5, (short) 2, (short) 2, &isc_189, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		MISC_release_request_silent(req_handle5);
	}

	// update statistics for system indices
	isc_req_handle req_handle6 = 0;

	/*FOR (REQUEST_HANDLE req_handle6)
		IND IN RDB$INDICES WITH IND.RDB$SYSTEM_FLAG EQ 1*/
	{
        if (!req_handle6)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle6, (short) sizeof(isc_174), (char*) isc_174);
	if (req_handle6)
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle6, (FB_API_HANDLE*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 0, (short) 12, &isc_175, (short) 0);
	   if (!isc_175.isc_177 || isc_status [1]) break;
		/*MODIFY IND*/
		{
			/*IND.RDB$STATISTICS.NULL*/
			isc_175.isc_178 = FALSE;
			/*IND.RDB$STATISTICS*/
			isc_175.isc_176 = -1;
		/*END_MODIFY*/
		isc_179.isc_180 = isc_175.isc_176;
		isc_179.isc_181 = isc_175.isc_178;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 1, (short) 10, &isc_179, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 2, (short) 2, &isc_182, (short) 0);
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle6);

	return true;
}

void restore_security_class(BurpGlobals* tdgbl, const TEXT* owner_nm, const TEXT* sec_class_nm)
{
   struct isc_172_struct {
          short isc_173;	/* isc_utility */
   } isc_172;
   struct isc_170_struct {
          ISC_QUAD isc_171;	/* RDB$ACL */
   } isc_170;
   struct isc_167_struct {
          ISC_QUAD isc_168;	/* RDB$ACL */
          short isc_169;	/* isc_utility */
   } isc_167;
   struct isc_165_struct {
          char  isc_166 [32];	/* RDB$SECURITY_CLASS */
   } isc_165;
/**************************************
 *
 *	r e s t o r e _ s e c u r i t y _ c l a s s
 *
 **************************************
 *
 * Functional description
 *	restore the ownership of the relation in the ACL list
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	//isc_tr_handle local_trans = gds_trans;

	/*FOR (REQUEST_HANDLE req_handle2)
		X IN RDB$SECURITY_CLASSES WITH X.RDB$SECURITY_CLASS EQ sec_class_nm*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_164), (char*) isc_164);
	isc_vtov ((const char*) sec_class_nm, (char*) isc_165.isc_166, 32);
	if (req_handle2)
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_165, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 10, &isc_167, (short) 0);
	   if (!isc_167.isc_169 || isc_status [1]) break;

		ISC_QUAD new_blob_id;
		new_blob_id.gds_quad_high = 0;
		new_blob_id.gds_quad_low  = 0;
		get_acl(tdgbl, owner_nm, &/*X.RDB$ACL*/
					  isc_167.isc_168, &new_blob_id);

		/*MODIFY X*/
		{;
			memcpy(&/*X.RDB$ACL*/
				isc_167.isc_168, &new_blob_id, sizeof(ISC_QUAD));
		/*END_MODIFY;*/
		isc_170.isc_171 = isc_167.isc_168;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 8, &isc_170, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_172, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error ();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}


USHORT get_view_base_relation_count(BurpGlobals* tdgbl,
									const TEXT* current_view_name,
									USHORT depth,
									bool* error)
{
   struct isc_159_struct {
          char  isc_160 [32];	/* RDB$RELATION_NAME */
          ISC_QUAD isc_161;	/* RDB$VIEW_BLR */
          short isc_162;	/* isc_utility */
          short isc_163;	/* gds__null_flag */
   } isc_159;
   struct isc_157_struct {
          char  isc_158 [32];	/* RDB$VIEW_NAME */
   } isc_157;
/**************************************
 *
 *	g e t _ v i e w _ b a s e _ r e l a t i o n _ c o u n t
 *
 **************************************
 *
 * Functional description
 *	Return the number of base relations
 *  (tables) from a view. When a view is
 *  referenced in the view this function
 *  is called recursively.
 *
 **************************************/

	depth++;
	if (depth > MAX_UPDATE_DBKEY_RECURSION_DEPTH)
	{
		*error = true;
		return 0;
	}

	isc_req_handle  req_handle1 = 0;

	USHORT result = 0;

	/*FOR (REQUEST_HANDLE req_handle1)
		V IN RDB$VIEW_RELATIONS
		CROSS R IN RDB$RELATIONS
		WITH
		  V.RDB$VIEW_NAME EQ current_view_name AND
		  R.RDB$RELATION_NAME EQ V.RDB$RELATION_NAME*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_156), (char*) isc_156);
	isc_vtov ((const char*) current_view_name, (char*) isc_157.isc_158, 32);
	if (req_handle1)
           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_157, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 44, &isc_159, (short) 0);
	   if (!isc_159.isc_162 || isc_status [1]) break;

		if (/*R.RDB$VIEW_BLR.NULL*/
		    isc_159.isc_163)
		{
			// This relation is a table, so increment count
			result++;
		}
		else
		{
			// Call recursive for VIEWS that are referenced in VIEWS
			result += get_view_base_relation_count(tdgbl, /*V.RDB$RELATION_NAME*/
								      isc_159.isc_160, depth, error);
			if (*error)
				break;
		}
	/*END_FOR;*/
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle1);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);

	return result;
}


void store_blr_gen_id(BurpGlobals* tdgbl, const TEXT* gen_name, SINT64 value, SINT64 initial_value,
	const ISC_QUAD* gen_desc, const char* secclass, const char* ownername, fb_sysflag sysFlag,
	SLONG increment)
{
   struct isc_132_struct {
          char  isc_133 [32];	/* RDB$GENERATOR_NAME */
          short isc_134;	/* gds__null_flag */
          short isc_135;	/* RDB$SYSTEM_FLAG */
   } isc_132;
   struct isc_137_struct {
          ISC_QUAD isc_138;	/* RDB$DESCRIPTION */
          char  isc_139 [32];	/* RDB$GENERATOR_NAME */
          short isc_140;	/* gds__null_flag */
          short isc_141;	/* RDB$SYSTEM_FLAG */
          short isc_142;	/* gds__null_flag */
   } isc_137;
   struct isc_144_struct {
          ISC_INT64 isc_145;	/* RDB$INITIAL_VALUE */
          char  isc_146 [32];	/* RDB$OWNER_NAME */
          char  isc_147 [32];	/* RDB$SECURITY_CLASS */
          ISC_QUAD isc_148;	/* RDB$DESCRIPTION */
          char  isc_149 [32];	/* RDB$GENERATOR_NAME */
          ISC_LONG isc_150;	/* RDB$GENERATOR_INCREMENT */
          short isc_151;	/* gds__null_flag */
          short isc_152;	/* gds__null_flag */
          short isc_153;	/* gds__null_flag */
          short isc_154;	/* RDB$SYSTEM_FLAG */
          short isc_155;	/* gds__null_flag */
   } isc_144;
/**************************************
 *
 *	s t o r e _ b l r _ g e n _ i d
 *
 **************************************
 *
 * Functional description
 *	Store the blr_gen_id for the relation.
 *
 **************************************/
	if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_143), (char*) isc_143);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
		   isc_144.isc_148 = isc_blob_null;

			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_144.isc_149, gen_name);
			/*X.RDB$DESCRIPTION.NULL*/
			isc_144.isc_155 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_144.isc_154 = (SSHORT) sysFlag;
			/*X.RDB$SECURITY_CLASS.NULL*/
			isc_144.isc_153 = TRUE;
			/*X.RDB$OWNER_NAME.NULL*/
			isc_144.isc_152 = TRUE;
			if (gen_desc)
			{
				/*X.RDB$DESCRIPTION*/
				isc_144.isc_148 = *gen_desc;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_144.isc_155 = FALSE;
			}
			if (secclass)
			{
				strcpy(/*X.RDB$SECURITY_CLASS*/
				       isc_144.isc_147, secclass);
				/*X.RDB$SECURITY_CLASS.NULL*/
				isc_144.isc_153 = FALSE;
			}
			if (ownername)
			{
				strcpy(/*X.RDB$OWNER_NAME*/
				       isc_144.isc_146, ownername);
				/*X.RDB$OWNER_NAME.NULL*/
				isc_144.isc_152 = FALSE;
			}
			/*X.RDB$INITIAL_VALUE.NULL*/
			isc_144.isc_151 = FALSE;
			/*X.RDB$INITIAL_VALUE*/
			isc_144.isc_145 = initial_value;
			/*X.RDB$GENERATOR_INCREMENT*/
			isc_144.isc_150 = increment;
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 126, &isc_144, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}

		if (!secclass)
			collect_missing_privs(tdgbl, obj_generator, gen_name);
	}
	else if (tdgbl->runtimeODS >= DB_VERSION_DDL11)
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_136), (char*) isc_136);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {
		   isc_137.isc_138 = isc_blob_null;

			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_137.isc_139, gen_name);
			/*X.RDB$DESCRIPTION.NULL*/
			isc_137.isc_142 = TRUE;
			/*X.RDB$SYSTEM_FLAG*/
			isc_137.isc_141 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_137.isc_140 = FALSE;
			if (gen_desc)
			{
				/*X.RDB$DESCRIPTION*/
				isc_137.isc_138 = *gen_desc;
				/*X.RDB$DESCRIPTION.NULL*/
				isc_137.isc_142 = FALSE;
			}
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 46, &isc_137, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}
	else
	{
		/*STORE (REQUEST_HANDLE tdgbl->handles_store_blr_gen_id_req_handle1)
			X IN RDB$GENERATORS*/
		{
		
                if (!tdgbl->handles_store_blr_gen_id_req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (short) sizeof(isc_131), (char*) isc_131);
		if (tdgbl->handles_store_blr_gen_id_req_handle1)
		   {

			strcpy (/*X.RDB$GENERATOR_NAME*/
				isc_132.isc_133, gen_name);
			/*X.RDB$SYSTEM_FLAG*/
			isc_132.isc_135 = 0;
			/*X.RDB$SYSTEM_FLAG.NULL*/
			isc_132.isc_134 = FALSE;
		/*END_STORE;*/
		   
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &tdgbl->handles_store_blr_gen_id_req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 36, &isc_132, (short) 0);
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
	}

	if (!value)
	{
		BURP_verbose (185, SafeArg() << gen_name << 0);
		// msg 185 restoring generator %s value: %ld
		return;
	}


	FB_API_HANDLE gen_id_reqh = 0;
	UCHAR blr_buffer[100];  // enough to fit blr
	UCHAR* blr = blr_buffer;

	// build the blr with the right relation name

	if (tdgbl->runtimeODS >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_version5);
	}
	else
	{
		add_byte(blr, blr_version4);
	}
	add_byte(blr, blr_begin);
	if (tdgbl->runtimeODS >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
	}
	else
	{
		add_byte(blr, blr_dcl_variable);
		add_word(blr, 0);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
	}
	add_byte(blr, blr_begin);
	add_byte(blr, blr_assignment);
	add_byte(blr, blr_gen_id);
	add_string(blr, gen_name);
	if (tdgbl->runtimeODS >= DB_VERSION_DDL10)
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_int64);
		add_byte(blr, 0);
		add_int64(blr, value);
	}
	else
	{
		add_byte(blr, blr_literal);
		add_byte(blr, blr_long);
		add_byte(blr, 0);
		add_long(blr, (SLONG)value);
	}
	add_byte(blr, blr_variable);
	add_word(blr, 0);
	add_byte(blr, blr_end);
	add_byte(blr, blr_end);
	add_byte(blr, blr_eoc);

	const USHORT blr_length = blr - blr_buffer;
	fb_assert(blr_length <= sizeof(blr_buffer));

	ISC_STATUS_ARRAY status_vector;
	if (isc_compile_request (status_vector, &DB, &gen_id_reqh,
							 blr_length, (const SCHAR*) blr_buffer))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42); // msg 42 Failed in store_blr_gen_id
	}

	if (isc_start_request (status_vector, &gen_id_reqh,
						   &gds_trans, // use the same one generated by gpre
						   0))
	{
		fb_print_blr(blr_buffer, blr_length, NULL, NULL, 0);
		BURP_error_redirect (status_vector, 42); // msg 42 Failed in store_blr_gen_id
	}

	BURP_verbose (185, SafeArg() << gen_name << value);
	// msg 185 restoring generator %s value: %ld

	isc_release_request (status_vector, &gen_id_reqh);
}


void update_global_field(BurpGlobals* tdgbl)
{
   struct isc_129_struct {
          short isc_130;	/* isc_utility */
   } isc_129;
   struct isc_120_struct {
          ISC_QUAD isc_121;	/* RDB$VALIDATION_BLR */
          ISC_QUAD isc_122;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_123;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_124;	/* RDB$COMPUTED_SOURCE */
          short isc_125;	/* gds__null_flag */
          short isc_126;	/* gds__null_flag */
          short isc_127;	/* gds__null_flag */
          short isc_128;	/* gds__null_flag */
   } isc_120;
   struct isc_110_struct {
          ISC_QUAD isc_111;	/* RDB$COMPUTED_SOURCE */
          ISC_QUAD isc_112;	/* RDB$COMPUTED_BLR */
          ISC_QUAD isc_113;	/* RDB$VALIDATION_SOURCE */
          ISC_QUAD isc_114;	/* RDB$VALIDATION_BLR */
          short isc_115;	/* isc_utility */
          short isc_116;	/* gds__null_flag */
          short isc_117;	/* gds__null_flag */
          short isc_118;	/* gds__null_flag */
          short isc_119;	/* gds__null_flag */
   } isc_110;
   struct isc_108_struct {
          char  isc_109 [32];	/* RDB$FIELD_NAME */
   } isc_108;
/**************************************
 *
 *	u p d a t e _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Update the global field definition to add constraints.
 *	The blobs have been created already.
 *
 **************************************/
	isc_req_handle  req_handle1 = 0;

	for (gfld* gfield = tdgbl->gbl_global_fields; gfield; )
	{
		/*FOR (TRANSACTION_HANDLE tdgbl->global_trans REQUEST_HANDLE req_handle1)
			X IN RDB$FIELDS WITH X.RDB$FIELD_NAME EQ gfield->gfld_name*/
		{
                if (!req_handle1)
                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_107), (char*) isc_107);
		isc_vtov ((const char*) gfield->gfld_name, (char*) isc_108.isc_109, 32);
		if (req_handle1)
                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &tdgbl->global_trans, (short) 0, (short) 32, &isc_108, (short) 0);
		if (!isc_status [1]) {
		while (1)
		   {
                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 1, (short) 42, &isc_110, (short) 0);
		   if (!isc_110.isc_115 || isc_status [1]) break;
			/*MODIFY X*/
			{

				if (gfield->gfld_flags & GFLD_validation_blr)
				{
					/*X.RDB$VALIDATION_BLR.NULL*/
					isc_110.isc_119 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_BLR*/
						isc_110.isc_114, &gfield->gfld_vb, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_110.isc_118 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_110.isc_113, &gfield->gfld_vs, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_validation_source2)
				{
					/*X.RDB$VALIDATION_SOURCE.NULL*/
					isc_110.isc_118 = FALSE;
					memcpy(&/*X.RDB$VALIDATION_SOURCE*/
						isc_110.isc_113, &gfield->gfld_vs2, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_blr)
				{
					/*X.RDB$COMPUTED_BLR.NULL*/
					isc_110.isc_117 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_BLR*/
						isc_110.isc_112, &gfield->gfld_computed_blr, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_110.isc_116 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_110.isc_111, &gfield->gfld_computed_source, sizeof(ISC_QUAD));
				}

				if (gfield->gfld_flags & GFLD_computed_source2)
				{
					/*X.RDB$COMPUTED_SOURCE.NULL*/
					isc_110.isc_116 = FALSE;
					memcpy(&/*X.RDB$COMPUTED_SOURCE*/
						isc_110.isc_111, &gfield->gfld_computed_source2, sizeof(ISC_QUAD));
				}

			/*END_MODIFY;*/
			isc_120.isc_121 = isc_110.isc_114;
			isc_120.isc_122 = isc_110.isc_113;
			isc_120.isc_123 = isc_110.isc_112;
			isc_120.isc_124 = isc_110.isc_111;
			isc_120.isc_125 = isc_110.isc_119;
			isc_120.isc_126 = isc_110.isc_118;
			isc_120.isc_127 = isc_110.isc_117;
			isc_120.isc_128 = isc_110.isc_116;
                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 2, (short) 40, &isc_120, (short) 0);;
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				general_on_error ();
			/*END_ERROR;*/
			   }
			}

		/*END_FOR;*/
                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 3, (short) 2, &isc_129, (short) 0);
		   }
		   };
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			general_on_error ();
		/*END_ERROR;*/
		   }
		}
		gfld* n_gfield = gfield->gfld_next;
		BURP_free (gfield);
		gfield = n_gfield;
	}
	MISC_release_request_silent(req_handle1);

	tdgbl->gbl_global_fields = NULL;
}


void update_ownership(BurpGlobals* tdgbl)
{
   struct isc_69_struct {
          short isc_70;	/* isc_utility */
   } isc_69;
   struct isc_67_struct {
          char  isc_68 [32];	/* RDB$OWNER_NAME */
   } isc_67;
   struct isc_62_struct {
          char  isc_63 [32];	/* RDB$DEFAULT_CLASS */
          char  isc_64 [32];	/* RDB$SECURITY_CLASS */
          char  isc_65 [32];	/* RDB$OWNER_NAME */
          short isc_66;	/* isc_utility */
   } isc_62;
   struct isc_60_struct {
          char  isc_61 [32];	/* RDB$RELATION_NAME */
   } isc_60;
   struct isc_80_struct {
          short isc_81;	/* isc_utility */
   } isc_80;
   struct isc_78_struct {
          char  isc_79 [32];	/* RDB$OWNER_NAME */
   } isc_78;
   struct isc_74_struct {
          char  isc_75 [32];	/* RDB$SECURITY_CLASS */
          char  isc_76 [32];	/* RDB$OWNER_NAME */
          short isc_77;	/* isc_utility */
   } isc_74;
   struct isc_72_struct {
          char  isc_73 [32];	/* RDB$PROCEDURE_NAME */
   } isc_72;
   struct isc_93_struct {
          short isc_94;	/* isc_utility */
   } isc_93;
   struct isc_91_struct {
          char  isc_92 [32];	/* RDB$OWNER_NAME */
   } isc_91;
   struct isc_86_struct {
          char  isc_87 [32];	/* RDB$SECURITY_CLASS */
          char  isc_88 [32];	/* RDB$OWNER_NAME */
          short isc_89;	/* isc_utility */
          short isc_90;	/* gds__null_flag */
   } isc_86;
   struct isc_83_struct {
          char  isc_84 [32];	/* RDB$PACKAGE_NAME */
          char  isc_85 [32];	/* RDB$PROCEDURE_NAME */
   } isc_83;
   struct isc_105_struct {
          short isc_106;	/* isc_utility */
   } isc_105;
   struct isc_103_struct {
          char  isc_104 [32];	/* RDB$OWNER_NAME */
   } isc_103;
   struct isc_98_struct {
          char  isc_99 [32];	/* RDB$SECURITY_CLASS */
          char  isc_100 [32];	/* RDB$OWNER_NAME */
          short isc_101;	/* isc_utility */
          short isc_102;	/* gds__null_flag */
   } isc_98;
   struct isc_96_struct {
          char  isc_97 [32];	/* RDB$PACKAGE_NAME */
   } isc_96;
	isc_req_handle req_handle2 = 0, req_handle4 = 0, req_handle6 = 0;
	BURP_verbose(358);

	// Change ownership of any packages
	for (burp_pkg* package = tdgbl->packages; package; package = package->pkg_next)
	{
		fb_assert(tdgbl->runtimeODS >= DB_VERSION_DDL12);

		if (package->pkg_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle6)
				X IN RDB$PACKAGES
				WITH X.RDB$PACKAGE_NAME EQ package->pkg_name*/
			{
                        if (!req_handle6)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle6, (short) sizeof(isc_95), (char*) isc_95);
			isc_vtov ((const char*) package->pkg_name, (char*) isc_96.isc_97, 32);
			if (req_handle6)
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle6, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_96, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 1, (short) 68, &isc_98, (short) 0);
			   if (!isc_98.isc_101 || isc_status [1]) break;
			{
				/*MODIFY X*/
				{
					strcpy(/*X.RDB$OWNER_NAME*/
					       isc_98.isc_100, package->pkg_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_98.isc_100, 32, isc_103.isc_104, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 2, (short) 32, &isc_103, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle6);
					general_on_error();
				/*END_ERROR;*/
				   }
				}

				if (!/*X.RDB$SECURITY_CLASS.NULL*/
				     isc_98.isc_102)
					restore_security_class(tdgbl, package->pkg_owner, /*X.RDB$SECURITY_CLASS*/
											  isc_98.isc_99);
			}
			/*END_FOR*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle6, (short) 3, (short) 2, &isc_105, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle6);
				general_on_error ();
			/*END_ERROR*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle6);

	// Change ownership of any procedures necessary
	for (burp_prc* procedure = tdgbl->procedures; procedure; procedure = procedure->prc_next)
	{
		if (procedure->prc_owner[0])
		{
			if (tdgbl->runtimeODS >= DB_VERSION_DDL12)
			{
				/*FOR (REQUEST_HANDLE req_handle4)
					X IN RDB$PROCEDURES
					WITH X.RDB$PROCEDURE_NAME EQ procedure->prc_name AND
						 X.RDB$PACKAGE_NAME EQUIV NULLIF(procedure->prc_package, '')*/
				{
                                if (!req_handle4)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_82), (char*) isc_82);
				isc_vtov ((const char*) procedure->prc_package, (char*) isc_83.isc_84, 32);
				isc_vtov ((const char*) procedure->prc_name, (char*) isc_83.isc_85, 32);
				if (req_handle4)
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 64, &isc_83, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 68, &isc_86, (short) 0);
				   if (!isc_86.isc_89 || isc_status [1]) break;
				{
					/*MODIFY X*/
					{
						strcpy (/*X.RDB$OWNER_NAME*/
							isc_86.isc_88, procedure->prc_owner);
					/*END_MODIFY;*/
					isc_ftof (isc_86.isc_88, 32, isc_91.isc_92, 32);
                                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 32, &isc_91, (short) 0);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						MISC_release_request_silent(req_handle4);
						general_on_error ();
					/*END_ERROR*/
					   }
					}

					if (!/*X.RDB$SECURITY_CLASS.NULL*/
					     isc_86.isc_90)
						restore_security_class(tdgbl, procedure->prc_owner, /*X.RDB$SECURITY_CLASS*/
												    isc_86.isc_87);
				}
				/*END_FOR;*/
                                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 3, (short) 2, &isc_93, (short) 0);
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle4);
					general_on_error ();
				/*END_ERROR*/
				   }
				}
			}
			else
			{
				/*FOR (REQUEST_HANDLE req_handle4)
					X IN RDB$PROCEDURES WITH X.RDB$PROCEDURE_NAME EQ procedure->prc_name*/
				{
                                if (!req_handle4)
                                   isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle4, (short) sizeof(isc_71), (char*) isc_71);
				isc_vtov ((const char*) procedure->prc_name, (char*) isc_72.isc_73, 32);
				if (req_handle4)
                                   isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle4, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_72, (short) 0);
				if (!isc_status [1]) {
				while (1)
				   {
                                   isc_receive (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 1, (short) 66, &isc_74, (short) 0);
				   if (!isc_74.isc_77 || isc_status [1]) break;
				{
					/*MODIFY X*/
					{
						strcpy (/*X.RDB$OWNER_NAME*/
							isc_74.isc_76, procedure->prc_owner);
					/*END_MODIFY;*/
					isc_ftof (isc_74.isc_76, 32, isc_78.isc_79, 32);
                                        isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 2, (short) 32, &isc_78, (short) 0);;
					/*ON_ERROR*/
					if (isc_status [1])
					   {
						MISC_release_request_silent(req_handle4);
						general_on_error ();
					/*END_ERROR;*/
					   }
					}

					restore_security_class(tdgbl, procedure->prc_owner, /*X.RDB$SECURITY_CLASS*/
											    isc_74.isc_75);
				}
				/*END_FOR*/
                                   isc_send (isc_status, (FB_API_HANDLE*) &req_handle4, (short) 3, (short) 2, &isc_80, (short) 0);
				   }
				   };
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle4);
					general_on_error ();
				/*END_ERROR*/
				   }
				}
			}
		}
	}

	MISC_release_request_silent(req_handle4);

	// Change ownership of any relations necessary

	for (burp_rel* relation = tdgbl->relations; relation; relation = relation->rel_next)
	{
		if (relation->rel_owner[0])
		{
			/*FOR (REQUEST_HANDLE req_handle2)
				X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ relation->rel_name*/
			{
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_59), (char*) isc_59);
			isc_vtov ((const char*) relation->rel_name, (char*) isc_60.isc_61, 32);
			if (req_handle2)
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 32, &isc_60, (short) 0);
			if (!isc_status [1]) {
			while (1)
			   {
                           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 98, &isc_62, (short) 0);
			   if (!isc_62.isc_66 || isc_status [1]) break;
				/*MODIFY X*/
				{
					strcpy (/*X.RDB$OWNER_NAME*/
						isc_62.isc_65, relation->rel_owner);
				/*END_MODIFY;*/
				isc_ftof (isc_62.isc_65, 32, isc_67.isc_68, 32);
                                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 32, &isc_67, (short) 0);;
				/*ON_ERROR*/
				if (isc_status [1])
				   {
					MISC_release_request_silent(req_handle2);
					general_on_error ();
				/*END_ERROR;*/
				   }
				}

				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$SECURITY_CLASS*/
										   isc_62.isc_64);
				restore_security_class(tdgbl, relation->rel_owner, /*X.RDB$DEFAULT_CLASS*/
										   isc_62.isc_63);

			/*END_FOR;*/
                           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 3, (short) 2, &isc_69, (short) 0);
			   }
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle2);
				general_on_error ();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle2);
}


void update_view_dbkey_lengths(BurpGlobals* tdgbl)
{
   struct isc_57_struct {
          short isc_58;	/* isc_utility */
   } isc_57;
   struct isc_55_struct {
          short isc_56;	/* RDB$DBKEY_LENGTH */
   } isc_55;
   struct isc_51_struct {
          char  isc_52 [32];	/* RDB$RELATION_NAME */
          short isc_53;	/* isc_utility */
          short isc_54;	/* RDB$DBKEY_LENGTH */
   } isc_51;
/**************************************
 *
 *	u p d a t e _ v i e w _ d b k e y _ l e n g t h s
 *
 **************************************
 *
 * Functional description
 *	During the restore process VIEWs could
 *  be created that holds other VIEWs and
 *  which weren't restored yet.
 *  Then the RDB$DBKEY_LENGTH for VIEWs is
 *  calculated wrong. Therefore we need to
 *  recalculate the DBKEY_LENGTH else we
 *  get our famous "arithmetic exception,
 *  numeric overflow, or string truncation" error.
 *
 **************************************/
	isc_req_handle  req_handle2 = 0;

	BURP_verbose(357);

	/*FOR (REQUEST_HANDLE req_handle2)
		R IN RDB$RELATIONS
		WITH
		  R.RDB$VIEW_BLR NOT MISSING AND
		  (R.RDB$SYSTEM_FLAG NE 1 OR R.RDB$SYSTEM_FLAG MISSING)*/
	{
        if (!req_handle2)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_50), (char*) isc_50);
	if (req_handle2)
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 0, (short) 36, &isc_51, (short) 0);
	   if (!isc_51.isc_53 || isc_status [1]) break;

		bool error = false;
		const USHORT result = get_view_base_relation_count(tdgbl, /*R.RDB$RELATION_NAME*/
									  isc_51.isc_52, 0, &error);
		fb_utils::exact_name(/*R.RDB$RELATION_NAME*/
				     isc_51.isc_52);
		if (error)
			BURP_error(339, false, SafeArg() << MAX_UPDATE_DBKEY_RECURSION_DEPTH << /*R.RDB$RELATION_NAME*/
												isc_51.isc_52);

		ULONG res2 = ULONG(result) * 8; // is a constant for DBKEY coded somewhere?
		if (res2 > USHORT(MAX_SSHORT))
			BURP_error(340, false, SafeArg() << MAX_SSHORT << /*R.RDB$RELATION_NAME*/
									  isc_51.isc_52);

		/*MODIFY R*/
		{
			/*R.RDB$DBKEY_LENGTH*/
			isc_51.isc_54 = SSHORT(res2);
		/*END_MODIFY;*/
		isc_55.isc_56 = isc_51.isc_54;
                isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 1, (short) 2, &isc_55, (short) 0);;
		/*ON_ERROR*/
		if (isc_status [1])
		   {
			MISC_release_request_silent(req_handle2);
			general_on_error();
		/*END_ERROR;*/
		   }
		}

	/*END_FOR;*/
           isc_send (isc_status, (FB_API_HANDLE*) &req_handle2, (short) 2, (short) 2, &isc_57, (short) 0);
	   }
	   };

	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle2);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle2);
}


void fix_missing_privileges(BurpGlobals* tdgbl)
{
   struct isc_29_struct {
          char  isc_30 [32];	/* RDB$RELATION_NAME */
          char  isc_31 [32];	/* RDB$USER */
          char  isc_32 [32];	/* RDB$GRANTOR */
          char  isc_33 [32];	/* RDB$FIELD_NAME */
          short isc_34;	/* gds__null_flag */
          short isc_35;	/* RDB$GRANT_OPTION */
          short isc_36;	/* gds__null_flag */
          short isc_37;	/* RDB$OBJECT_TYPE */
          short isc_38;	/* gds__null_flag */
          short isc_39;	/* RDB$USER_TYPE */
          short isc_40;	/* gds__null_flag */
          short isc_41;	/* gds__null_flag */
          short isc_42;	/* gds__null_flag */
          short isc_43;	/* gds__null_flag */
          short isc_44;	/* gds__null_flag */
          char  isc_45 [7];	/* RDB$PRIVILEGE */
   } isc_29;
   struct isc_47_struct {
          char  isc_48 [32];	/* RDB$OWNER_NAME */
          short isc_49;	/* isc_utility */
   } isc_47;
	BURP_verbose(359);

	GDS_NAME owner_name;
	isc_req_handle req_handle1 = 0, req_handle2 = 0;

	/*FOR (REQUEST_HANDLE req_handle1)
		REL IN RDB$RELATIONS
		WITH REL.RDB$RELATION_ID = 1*/
	{
        if (!req_handle1)
           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle1, (short) sizeof(isc_46), (char*) isc_46);
	if (req_handle1)
           isc_start_request (isc_status, (FB_API_HANDLE*) &req_handle1, (FB_API_HANDLE*) &gds_trans, (short) 0);
	if (!isc_status [1]) {
	while (1)
	   {
           isc_receive (isc_status, (FB_API_HANDLE*) &req_handle1, (short) 0, (short) 34, &isc_47, (short) 0);
	   if (!isc_47.isc_49 || isc_status [1]) break;

		strcpy(owner_name, /*REL.RDB$OWNER_NAME*/
				   isc_47.isc_48);

	/*END_FOR;*/
	   }
	   };
	/*ON_ERROR*/
	if (isc_status [1])
	   {
		MISC_release_request_silent(req_handle1);
		general_on_error();
	/*END_ERROR;*/
	   }
	}

	MISC_release_request_silent(req_handle1);

	for (burp_meta_obj* object = tdgbl->miss_privs; object; object = object->obj_next)
	{
		const char* const privilege = (object->obj_type == obj_udf) ? "X" : "G";

		for (int i = 1; i >= 0; i--)
		{
			/*STORE (REQUEST_HANDLE req_handle2)
				X IN RDB$USER_PRIVILEGES*/
			{
			
                        if (!req_handle2)
                           isc_compile_request (isc_status, (FB_API_HANDLE*) &DB, (FB_API_HANDLE*) &req_handle2, (short) sizeof(isc_28), (char*) isc_28);
			if (req_handle2)
			   {

				/*X.RDB$FIELD_NAME.NULL*/
				isc_29.isc_44 = TRUE;
				/*X.RDB$GRANTOR.NULL*/
				isc_29.isc_43 = TRUE;

				/*X.RDB$PRIVILEGE.NULL*/
				isc_29.isc_42 = FALSE;
				strcpy(/*X.RDB$PRIVILEGE*/
				       isc_29.isc_45, privilege);

				/*X.RDB$USER.NULL*/
				isc_29.isc_41 = FALSE;
				strcpy(/*X.RDB$USER*/
				       isc_29.isc_31, (i == 0) ? "PUBLIC" : owner_name);

				/*X.RDB$RELATION_NAME.NULL*/
				isc_29.isc_40 = FALSE;
				strcpy(/*X.RDB$RELATION_NAME*/
				       isc_29.isc_30, object->obj_name);

				/*X.RDB$USER_TYPE.NULL*/
				isc_29.isc_38 = FALSE;
				/*X.RDB$USER_TYPE*/
				isc_29.isc_39 = obj_user;

				/*X.RDB$OBJECT_TYPE.NULL*/
				isc_29.isc_36 = FALSE;
				/*X.RDB$OBJECT_TYPE*/
				isc_29.isc_37 = object->obj_type;

				/*X.RDB$GRANT_OPTION.NULL*/
				isc_29.isc_34 = FALSE;
				/*X.RDB$GRANT_OPTION*/
				isc_29.isc_35 = i;

			/*END_STORE;*/
			   
                           isc_start_and_send (isc_status, (FB_API_HANDLE*) &req_handle2, (FB_API_HANDLE*) &gds_trans, (short) 0, (short) 157, &isc_29, (short) 0);
			   };
			/*ON_ERROR*/
			if (isc_status [1])
			   {
				MISC_release_request_silent(req_handle2);
				general_on_error();
			/*END_ERROR;*/
			   }
			}
		}
	}

	MISC_release_request_silent(req_handle2);
}

struct FixGenerator
{
	const char* name;
	const char* table;
	const char* field;
	const char* prefix;
	int ods;
};

void fix_generator(BurpGlobals* tdgbl, const FixGenerator* g)
{
/**************************************
 *
 *	f i x _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Set value of system generator based on
 *	current state of related table.
 *
 **************************************/

	int start = strlen(g->prefix) + 1;

	Firebird::string sql;
	sql.printf("EXECUTE BLOCK AS "
			   "DECLARE VARIABLE maxInTable INT; "
			   "DECLARE VARIABLE currentGen INT; "
			   "BEGIN "
			   " SELECT FIRST(1) CAST(SUBSTRING(%s FROM %d FOR 32) AS INT) FROM %s "
			   " WHERE SUBSTRING(%s FROM %d FOR 32) SIMILAR TO '[0-9]+ *' "
			   "   AND %s STARTING WITH '%s' ORDER BY 1 DESC INTO :maxInTable; "
			   " "
			   " currentGen = gen_id(%s, 0); "
			   " IF (currentGen < maxInTable) THEN "
			   "  EXECUTE STATEMENT 'SET GENERATOR %s TO ' || maxInTable; "
			   "END",
			   /* SELECT 1 */ g->field, start, g->table, g->field, start, g->field, g->prefix,
			   /* SELECT 2 */ g->name,
			   /* SET GEN  */ g->name);

	if (isc_execute_immediate(isc_status, &DB, &gds_trans, 0, sql.c_str()) != 0)
		general_on_error();
}

static const FixGenerator genToFix[] =
{
	{ "RDB$CONSTRAINT_NAME",	"RDB$RELATION_CONSTRAINTS",	"RDB$CONSTRAINT_NAME",	"INTEG_" 		, DB_VERSION_DDL8 },
	{ "RDB$FIELD_NAME",			"RDB$FIELDS",				"RDB$FIELD_NAME",		"RDB$"			, DB_VERSION_DDL8 },
	{ "RDB$INDEX_NAME",			"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$"			, DB_VERSION_DDL8 },
	{ "RDB$INDEX_NAME",			"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$PRIMARY"	, DB_VERSION_DDL8 },
	{ "RDB$INDEX_NAME",			"RDB$INDICES", 				"RDB$INDEX_NAME",		"RDB$FOREIGN"	, DB_VERSION_DDL8 },
	{ "RDB$TRIGGER_NAME",		"RDB$TRIGGERS",				"RDB$TRIGGER_NAME",		"CHECK_"		, DB_VERSION_DDL8 },
	///"RDB$BACKUP_HISTORY"	// unused ???
	{ "RDB$SECURITY_CLASS",		"RDB$SECURITY_CLASSES",		"RDB$SECURITY_CLASS",	"SQL$" 			, DB_VERSION_DDL8 },
	{ "SQL$DEFAULT",			"RDB$SECURITY_CLASSES",		"RDB$SECURITY_CLASS",	"SQL$DEFAULT" 	, DB_VERSION_DDL8 },
	{ "RDB$GENERATOR_NAME",		"RDB$GENERATORS",			"RDB$GENERATOR_NAME",	"RDB$" 			, DB_VERSION_DDL12 },
	{ NULL, NULL, NULL, NULL }
};

void fix_system_generators(BurpGlobals* tdgbl)
{
/**************************************
 *
 *	f i x _ s y s t e m _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Set value of system generators based on
 *	current state of related tables.
 *
 **************************************/

	BURP_verbose(350);
	// msg 350 fixing system generators

	for (const FixGenerator* g = genToFix; g->name; ++g)
	{
		if (tdgbl->runtimeODS >= g->ods)
			fix_generator(tdgbl, g);
	}
}

} // namespace
