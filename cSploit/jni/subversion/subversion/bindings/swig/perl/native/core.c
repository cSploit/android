/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIG_CASTRANK_MODE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Add in functionality missing in older versions of Perl. Much of this is based on Devel-PPPort on cpan. */

/* Add PERL_REVISION, PERL_VERSION, PERL_SUBVERSION if missing */
#ifndef PERL_REVISION
#  if !defined(__PATCHLEVEL_H_INCLUDED__) && !(defined(PATCHLEVEL) && defined(SUBVERSION))
#    define PERL_PATCHLEVEL_H_IMPLICIT
#    include <patchlevel.h>
#  endif
#  if !(defined(PERL_VERSION) || (defined(SUBVERSION) && defined(PATCHLEVEL)))
#    include <could_not_find_Perl_patchlevel.h>
#  endif
#  ifndef PERL_REVISION
#    define PERL_REVISION       (5)
#    define PERL_VERSION        PATCHLEVEL
#    define PERL_SUBVERSION     SUBVERSION
#  endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

#ifndef SvIOK_UV
# define SvIOK_UV(sv)       (SvIOK(sv) && (SvUVX(sv) == SvIVX(sv)))
#endif

#ifndef SvUOK
# define SvUOK(sv)           SvIOK_UV(sv)
#endif

#if ((PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5)))
#  define PL_sv_undef               sv_undef
#  define PL_na	                    na
#  define PL_errgv                  errgv
#  define PL_sv_no                  sv_no
#  define PL_sv_yes                 sv_yes
#  define PL_markstack_ptr          markstack_ptr
#endif

#ifndef IVSIZE
#  ifdef LONGSIZE
#    define IVSIZE LONGSIZE
#  else
#    define IVSIZE 4 /* A bold guess, but the best we can make. */
#  endif
#endif

#ifndef INT2PTR
#  if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#    define PTRV                  UV
#    define INT2PTR(any,d)        (any)(d)
#  else
#    if PTRSIZE == LONGSIZE
#      define PTRV                unsigned long
#    else
#      define PTRV                unsigned
#    endif
#    define INT2PTR(any,d)        (any)(PTRV)(d)
#  endif

#  define NUM2PTR(any,d)  (any)(PTRV)(d)
#  define PTR2IV(p)       INT2PTR(IV,p)
#  define PTR2UV(p)       INT2PTR(UV,p)
#  define PTR2NV(p)       NUM2PTR(NV,p)

#  if PTRSIZE == LONGSIZE
#    define PTR2ul(p)     (unsigned long)(p)
#  else
#    define PTR2ul(p)     INT2PTR(unsigned long,p)
#  endif
#endif /* !INT2PTR */

#ifndef SvPV_nolen
# define SvPV_nolen(x) SvPV(x,PL_na)
#endif

#ifndef get_sv
#  define get_sv perl_get_sv
#endif

#ifndef ERRSV
#  define ERRSV get_sv("@",FALSE)
#endif

#ifndef pTHX_
#define pTHX_
#endif   

#include <string.h>
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGINTERN const char*
SWIG_Perl_ErrorType(int code) {
  const char* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = "MemoryError";
    break;
  case SWIG_IOError:
    type = "IOError";
    break;
  case SWIG_RuntimeError:
    type = "RuntimeError";
    break;
  case SWIG_IndexError:
    type = "IndexError";
    break;
  case SWIG_TypeError:
    type = "TypeError";
    break;
  case SWIG_DivisionByZero:
    type = "ZeroDivisionError";
    break;
  case SWIG_OverflowError:
    type = "OverflowError";
    break;
  case SWIG_SyntaxError:
    type = "SyntaxError";
    break;
  case SWIG_ValueError:
    type = "ValueError";
    break;
  case SWIG_SystemError:
    type = "SystemError";
    break;
  case SWIG_AttributeError:
    type = "AttributeError";
    break;
  default:
    type = "RuntimeError";
  }
  return type;
}




/* -----------------------------------------------------------------------------
 * perlrun.swg
 *
 * This file contains the runtime support for Perl modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef PERL_OBJECT
#define SWIG_PERL_OBJECT_DECL CPerlObj *SWIGUNUSEDPARM(pPerl),
#define SWIG_PERL_OBJECT_CALL pPerl,
#else
#define SWIG_PERL_OBJECT_DECL
#define SWIG_PERL_OBJECT_CALL
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pp, type, flags)           SWIG_Perl_ConvertPtr(SWIG_PERL_OBJECT_CALL obj, pp, type, flags)
#define SWIG_ConvertPtrAndOwn(obj, pp, type, flags,own) SWIG_Perl_ConvertPtrAndOwn(SWIG_PERL_OBJECT_CALL obj, pp, type, flags, own)
#define SWIG_NewPointerObj(p, type, flags)              SWIG_Perl_NewPointerObj(SWIG_PERL_OBJECT_CALL p, type, flags)

/* for raw packed data */
#define SWIG_ConvertPacked(obj, p, s, type)             SWIG_Perl_ConvertPacked(SWIG_PERL_OBJECT_CALL obj, p, s, type)
#define SWIG_NewPackedObj(p, s, type)	                SWIG_Perl_NewPackedObj(SWIG_PERL_OBJECT_CALL p, s, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Perl_GetModule()
#define SWIG_SetModule(clientdata, pointer)             SWIG_Perl_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Perl_ErrorType(code)               
#define SWIG_Error(code, msg)            		sv_setpvf(GvSV(PL_errgv),"%s %s\n", SWIG_ErrorType(code), msg)
#define SWIG_fail                        		goto fail						    

/* Perl-specific SWIG API */

#define SWIG_MakePtr(sv, ptr, type, flags)              SWIG_Perl_MakePtr(SWIG_PERL_OBJECT_CALL sv, ptr, type, flags)
#define SWIG_MakePackedObj(sv, p, s, type)	        SWIG_Perl_MakePackedObj(SWIG_PERL_OBJECT_CALL sv, p, s, type)
#define SWIG_SetError(str)                              SWIG_Error(SWIG_RuntimeError, str)


#define SWIG_PERL_DECL_ARGS_1(arg1)                     (SWIG_PERL_OBJECT_DECL arg1)
#define SWIG_PERL_CALL_ARGS_1(arg1)                     (SWIG_PERL_OBJECT_CALL arg1)
#define SWIG_PERL_DECL_ARGS_2(arg1, arg2)               (SWIG_PERL_OBJECT_DECL arg1, arg2)
#define SWIG_PERL_CALL_ARGS_2(arg1, arg2)               (SWIG_PERL_OBJECT_CALL arg1, arg2)

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_OWNER   SWIG_POINTER_OWN
#define SWIG_SHADOW  SWIG_OWNER << 1

#define SWIG_MAYBE_PERL_OBJECT SWIG_PERL_OBJECT_DECL

/* SWIG Perl macros */

/* Macro to declare an XS function */
#ifndef XSPROTO
#   define XSPROTO(name) void name(pTHX_ CV* cv)
#endif

/* Macro to call an XS function */
#ifdef PERL_OBJECT 
#  define SWIG_CALLXS(_name) _name(cv,pPerl) 
#else 
#  ifndef MULTIPLICITY 
#    define SWIG_CALLXS(_name) _name(cv) 
#  else 
#    define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
#  endif 
#endif 

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC

#else /* PERL_OBJECT */

#define MAGIC_PPERL
#define SWIGCLASS_STATIC static SWIGUNUSED

#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFunc)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#else /* MULTIPLICITY */

#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif /* MULTIPLICITY */
#endif /* PERL_OBJECT */

/* Workaround for bug in perl 5.6.x croak and earlier */
#if (PERL_VERSION < 8)
#  ifdef PERL_OBJECT
#    define SWIG_croak_null() SWIG_Perl_croak_null(pPerl)
static void SWIG_Perl_croak_null(CPerlObj *pPerl)
#  else
static void SWIG_croak_null()
#  endif
{
  SV *err=ERRSV;
#  if (PERL_VERSION < 6)
  croak("%_", err);
#  else
  if (SvOK(err) && !SvROK(err)) croak("%_", err);
  croak(Nullch);
#  endif
}
#else
#  define SWIG_croak_null() croak(Nullch)
#endif


/* 
   Define how strict is the cast between strings and integers/doubles
   when overloading between these types occurs.
   
   The default is making it as strict as possible by using SWIG_AddCast
   when needed.
   
   You can use -DSWIG_PERL_NO_STRICT_STR2NUM at compilation time to
   disable the SWIG_AddCast, making the casting between string and
   numbers less strict.

   In the end, we try to solve the overloading between strings and
   numerical types in the more natural way, but if you can avoid it,
   well, avoid it using %rename, for example.
*/
#ifndef SWIG_PERL_NO_STRICT_STR2NUM
# ifndef SWIG_PERL_STRICT_STR2NUM
#  define SWIG_PERL_STRICT_STR2NUM
# endif
#endif
#ifdef SWIG_PERL_STRICT_STR2NUM
/* string takes precedence */
#define SWIG_Str2NumCast(x) SWIG_AddCast(x)  
#else
/* number takes precedence */
#define SWIG_Str2NumCast(x) x
#endif



#include <stdlib.h>

SWIGRUNTIME const char *
SWIG_Perl_TypeProxyName(const swig_type_info *type) {
  if (!type) return NULL;
  if (type->clientdata != NULL) {
    return (const char*) type->clientdata;
  } 
  else {
    return type->name;
  }
}

/* Identical to SWIG_TypeCheck, except for strcmp comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeProxyCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if ( (!iter->type->clientdata && (strcmp(iter->type->name, c) == 0)) ||
            (iter->type->clientdata && (strcmp((char*)iter->type->clientdata, c) == 0)) ) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* Function for getting a pointer value */

SWIGRUNTIME int
SWIG_Perl_ConvertPtrAndOwn(SWIG_MAYBE_PERL_OBJECT SV *sv, void **ptr, swig_type_info *_t, int flags, int *own) {
  swig_cast_info *tc;
  void *voidptr = (void *)0;
  SV *tsv = 0;

  if (own)
    *own = 0;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    IV tmp = 0;
    tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
        mg = mg_find(tsv,'P');
        if (mg) {
          sv = mg->mg_obj;
          if (sv_isobject(sv)) {
	    tsv = (SV*)SvRV(sv);
            tmp = SvIV(tsv);
          }
        }
      } else {
        return SWIG_ERROR;
      }
    } else {
      tmp = SvIV(tsv);
    }
    voidptr = INT2PTR(void *,tmp);
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return SWIG_OK;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    if (!SvROK(sv)) {
      /* In Perl 5.12 and later, SVt_RV == SVt_IV, so sv could be a valid integer value.  */
      if (SvIOK(sv)) {
        return SWIG_ERROR;
      } else {
        /* NULL pointer (reference to undef). */
        *(ptr) = (void *) 0;
        return SWIG_OK;
      }
    } else {
      return SWIG_ERROR;
    }
  } else {                            /* Don't know what it is */
    return SWIG_ERROR;
  }
  if (_t) {
    /* Now see if the types match */
    char *_c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeProxyCheck(_c,_t);
    if (!tc) {
      return SWIG_ERROR;
    }
    {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,voidptr,&newmemory);
      if (newmemory == SWIG_CAST_NEW_MEMORY) {
        assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
        if (own)
          *own = *own | SWIG_CAST_NEW_MEMORY;
      }
    }
  } else {
    *ptr = voidptr;
  }

  /* 
   *  DISOWN implementation: we need a perl guru to check this one.
   */
  if (tsv && (flags & SWIG_POINTER_DISOWN)) {
    /* 
     *  almost copy paste code from below SWIG_POINTER_OWN setting
     */
    SV *obj = sv;
    HV *stash = SvSTASH(SvRV(obj));
    GV *gv = *(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
    if (isGV(gv)) {
      HV *hv = GvHVn(gv);
      /*
       * To set ownership (see below), a newSViv(1) entry is added. 
       * Hence, to remove ownership, we delete the entry.
       */
      if (hv_exists_ent(hv, obj, 0)) {
	hv_delete_ent(hv, obj, 0, 0);
      }
    }
  }
  return SWIG_OK;
}

SWIGRUNTIME int
SWIG_Perl_ConvertPtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void **ptr, swig_type_info *_t, int flags) {
  return SWIG_Perl_ConvertPtrAndOwn(sv, ptr, _t, flags, 0);
}

SWIGRUNTIME void
SWIG_Perl_MakePtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, swig_type_info *t, int flags) {
  if (ptr && (flags & (SWIG_SHADOW | SWIG_POINTER_OWN))) {
    SV *self;
    SV *obj=newSV(0);
    HV *hash=newHV();
    HV *stash;
    sv_setref_pv(obj, (char *) SWIG_Perl_TypeProxyName(t), ptr);
    stash=SvSTASH(SvRV(obj));
    if (flags & SWIG_POINTER_OWN) {
      HV *hv;
      GV *gv = *(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
      if (!isGV(gv))
        gv_init(gv, stash, "OWNER", 5, FALSE);
      hv=GvHVn(gv);
      hv_store_ent(hv, obj, newSViv(1), 0);
    }
    sv_magic((SV *)hash, (SV *)obj, 'P', Nullch, 0);
    SvREFCNT_dec(obj);
    self=newRV_noinc((SV *)hash);
    sv_setsv(sv, self);
    SvREFCNT_dec((SV *)self);
    sv_bless(sv, stash);
  }
  else {
    sv_setref_pv(sv, (char *) SWIG_Perl_TypeProxyName(t), ptr);
  }
}

SWIGRUNTIMEINLINE SV *
SWIG_Perl_NewPointerObj(SWIG_MAYBE_PERL_OBJECT void *ptr, swig_type_info *t, int flags) {
  SV *result = sv_newmortal();
  SWIG_MakePtr(result, ptr, t, flags);
  return result;
}

SWIGRUNTIME void
SWIG_Perl_MakePackedObj(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(SWIG_Perl_TypeProxyName(type))) > 1000) return;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,SWIG_Perl_TypeProxyName(type));
  sv_setpv(sv, result);
}

SWIGRUNTIME SV *
SWIG_Perl_NewPackedObj(SWIG_MAYBE_PERL_OBJECT void *ptr, int sz, swig_type_info *type) {
  SV *result = sv_newmortal();
  SWIG_Perl_MakePackedObj(result, ptr, sz, type);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Perl_ConvertPacked(SWIG_MAYBE_PERL_OBJECT SV *obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c = 0;

  if ((!obj) || (!SvOK(obj))) return SWIG_ERROR;
  c = SvPV_nolen(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') return SWIG_ERROR;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) return SWIG_ERROR;
  }
  return SWIG_OK;
}


/* Macros for low-level exception handling */
#define SWIG_croak(x)    { SWIG_Error(SWIG_RuntimeError, x); SWIG_fail; }


typedef XSPROTO(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;


/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY
     SWIGRUNTIME void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) 
  #else
     SWIGRUNTIME void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*, SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) 
  #endif
#else
#  define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
SWIGRUNTIME void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) 
#endif
{
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFunc) get;
  mg->mg_virtual->svt_set = (SwigMagicFunc) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}


SWIGRUNTIME swig_module_info *
SWIG_Perl_GetModule(void) {
  static void *type_pointer = (void *)0;
  SV *pointer;

  /* first check if pointer already created */
  if (!type_pointer) {
    pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, FALSE | GV_ADDMULTI);
    if (pointer && SvOK(pointer)) {
      type_pointer = INT2PTR(swig_type_info **, SvIV(pointer));
    }
  }

  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Perl_SetModule(swig_module_info *module) {
  SV *pointer;

  /* create a new pointer */
  pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TRUE | GV_ADDMULTI);
  sv_setiv(pointer, PTR2IV(module));
}

#ifdef __cplusplus
}
#endif

/* Workaround perl5 global namespace pollution. Note that undefining library
 * functions like fopen will not solve the problem on all platforms as fopen
 * might be a macro on Windows but not necessarily on other operating systems. */
#ifdef do_open
  #undef do_open
#endif
#ifdef do_close
  #undef do_close
#endif
#ifdef do_exec
  #undef do_exec
#endif
#ifdef scalar
  #undef scalar
#endif
#ifdef list
  #undef list
#endif
#ifdef apply
  #undef apply
#endif
#ifdef convert
  #undef convert
#endif
#ifdef Error
  #undef Error
#endif
#ifdef form
  #undef form
#endif
#ifdef vform
  #undef vform
#endif
#ifdef LABEL
  #undef LABEL
#endif
#ifdef METHOD
  #undef METHOD
#endif
#ifdef Move
  #undef Move
#endif
#ifdef yylex
  #undef yylex
#endif
#ifdef yyparse
  #undef yyparse
#endif
#ifdef yyerror
  #undef yyerror
#endif
#ifdef invert
  #undef invert
#endif
#ifdef ref
  #undef ref
#endif
#ifdef read
  #undef read
#endif
#ifdef write
  #undef write
#endif
#ifdef eof
  #undef eof
#endif
#ifdef bool
  #undef bool
#endif
#ifdef close
  #undef close
#endif
#ifdef rewind
  #undef rewind
#endif
#ifdef free
  #undef free
#endif
#ifdef malloc
  #undef malloc
#endif
#ifdef calloc
  #undef calloc
#endif
#ifdef Stat
  #undef Stat
#endif
#ifdef check
  #undef check
#endif
#ifdef seekdir
  #undef seekdir
#endif
#ifdef open
  #undef open
#endif
#ifdef readdir
  #undef readdir
#endif
#ifdef bind
  #undef bind
#endif
#ifdef access
  #undef access
#endif
#ifdef stat
  #undef stat
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_FILE swig_types[0]
#define SWIGTYPE_p_apr_allocator_t swig_types[1]
#define SWIGTYPE_p_apr_array_header_t swig_types[2]
#define SWIGTYPE_p_apr_dir_t swig_types[3]
#define SWIGTYPE_p_apr_file_t swig_types[4]
#define SWIGTYPE_p_apr_finfo_t swig_types[5]
#define SWIGTYPE_p_apr_getopt_option_t swig_types[6]
#define SWIGTYPE_p_apr_getopt_t swig_types[7]
#define SWIGTYPE_p_apr_hash_index_t swig_types[8]
#define SWIGTYPE_p_apr_hash_t swig_types[9]
#define SWIGTYPE_p_apr_int32_t swig_types[10]
#define SWIGTYPE_p_apr_int64_t swig_types[11]
#define SWIGTYPE_p_apr_off_t swig_types[12]
#define SWIGTYPE_p_apr_pool_t swig_types[13]
#define SWIGTYPE_p_apr_proc_t swig_types[14]
#define SWIGTYPE_p_apr_size_t swig_types[15]
#define SWIGTYPE_p_apr_uint32_t swig_types[16]
#define SWIGTYPE_p_char swig_types[17]
#define SWIGTYPE_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t swig_types[18]
#define SWIGTYPE_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t swig_types[19]
#define SWIGTYPE_p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void swig_types[20]
#define SWIGTYPE_p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t swig_types[21]
#define SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t swig_types[22]
#define SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t swig_types[23]
#define SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t swig_types[24]
#define SWIGTYPE_p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t swig_types[25]
#define SWIGTYPE_p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t swig_types[26]
#define SWIGTYPE_p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t swig_types[27]
#define SWIGTYPE_p_f_p_q_const__char_p_q_const__char_p_void__int swig_types[28]
#define SWIGTYPE_p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int swig_types[29]
#define SWIGTYPE_p_f_p_q_const__char_p_void__int swig_types[30]
#define SWIGTYPE_p_f_p_q_const__char_p_void_p_apr_pool_t__int swig_types[31]
#define SWIGTYPE_p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t swig_types[32]
#define SWIGTYPE_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t swig_types[33]
#define SWIGTYPE_p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t swig_types[34]
#define SWIGTYPE_p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t swig_types[35]
#define SWIGTYPE_p_f_p_void__p_svn_error_t swig_types[36]
#define SWIGTYPE_p_f_p_void__void swig_types[37]
#define SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t swig_types[38]
#define SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t swig_types[39]
#define SWIGTYPE_p_f_p_void_apr_size_t__p_svn_error_t swig_types[40]
#define SWIGTYPE_p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t swig_types[41]
#define SWIGTYPE_p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t swig_types[42]
#define SWIGTYPE_p_f_p_void_p_char_p_apr_size_t__p_svn_error_t swig_types[43]
#define SWIGTYPE_p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t swig_types[44]
#define SWIGTYPE_p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t swig_types[45]
#define SWIGTYPE_p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t swig_types[46]
#define SWIGTYPE_p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t swig_types[47]
#define SWIGTYPE_p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t swig_types[48]
#define SWIGTYPE_p_f_p_void_p_void__void swig_types[49]
#define SWIGTYPE_p_f_p_void_p_void_p_void_p_int__p_svn_error_t swig_types[50]
#define SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t swig_types[51]
#define SWIGTYPE_p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t swig_types[52]
#define SWIGTYPE_p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t swig_types[53]
#define SWIGTYPE_p_f_void__p_svn_version_t swig_types[54]
#define SWIGTYPE_p_int swig_types[55]
#define SWIGTYPE_p_long swig_types[56]
#define SWIGTYPE_p_p_apr_array_header_t swig_types[57]
#define SWIGTYPE_p_p_apr_file_t swig_types[58]
#define SWIGTYPE_p_p_apr_hash_t swig_types[59]
#define SWIGTYPE_p_p_char swig_types[60]
#define SWIGTYPE_p_p_svn_auth_baton_t swig_types[61]
#define SWIGTYPE_p_p_svn_auth_cred_simple_t swig_types[62]
#define SWIGTYPE_p_p_svn_auth_cred_ssl_client_cert_pw_t swig_types[63]
#define SWIGTYPE_p_p_svn_auth_cred_ssl_client_cert_t swig_types[64]
#define SWIGTYPE_p_p_svn_auth_cred_ssl_server_trust_t swig_types[65]
#define SWIGTYPE_p_p_svn_auth_cred_username_t swig_types[66]
#define SWIGTYPE_p_p_svn_auth_iterstate_t swig_types[67]
#define SWIGTYPE_p_p_svn_auth_provider_object_t swig_types[68]
#define SWIGTYPE_p_p_svn_checksum_t swig_types[69]
#define SWIGTYPE_p_p_svn_config_t swig_types[70]
#define SWIGTYPE_p_p_svn_diff_t swig_types[71]
#define SWIGTYPE_p_p_svn_io_dirent2_t swig_types[72]
#define SWIGTYPE_p_p_svn_patch_file_t swig_types[73]
#define SWIGTYPE_p_p_svn_patch_t swig_types[74]
#define SWIGTYPE_p_p_svn_stream_mark_t swig_types[75]
#define SWIGTYPE_p_p_svn_stream_t swig_types[76]
#define SWIGTYPE_p_p_svn_string_t swig_types[77]
#define SWIGTYPE_p_p_svn_stringbuf_t swig_types[78]
#define SWIGTYPE_p_p_void swig_types[79]
#define SWIGTYPE_p_svn_auth_baton_t swig_types[80]
#define SWIGTYPE_p_svn_auth_cred_simple_t swig_types[81]
#define SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t swig_types[82]
#define SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t swig_types[83]
#define SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t swig_types[84]
#define SWIGTYPE_p_svn_auth_cred_username_t swig_types[85]
#define SWIGTYPE_p_svn_auth_iterstate_t swig_types[86]
#define SWIGTYPE_p_svn_auth_provider_object_t swig_types[87]
#define SWIGTYPE_p_svn_auth_provider_t swig_types[88]
#define SWIGTYPE_p_svn_auth_ssl_server_cert_info_t swig_types[89]
#define SWIGTYPE_p_svn_checksum_kind_t swig_types[90]
#define SWIGTYPE_p_svn_commit_info_t swig_types[91]
#define SWIGTYPE_p_svn_config_t swig_types[92]
#define SWIGTYPE_p_svn_depth_t swig_types[93]
#define SWIGTYPE_p_svn_diff_conflict_display_style_t swig_types[94]
#define SWIGTYPE_p_svn_diff_datasource_e swig_types[95]
#define SWIGTYPE_p_svn_diff_file_ignore_space_t swig_types[96]
#define SWIGTYPE_p_svn_diff_file_options_t swig_types[97]
#define SWIGTYPE_p_svn_diff_fns2_t swig_types[98]
#define SWIGTYPE_p_svn_diff_fns_t swig_types[99]
#define SWIGTYPE_p_svn_diff_hunk_t swig_types[100]
#define SWIGTYPE_p_svn_diff_operation_kind_e swig_types[101]
#define SWIGTYPE_p_svn_diff_output_fns_t swig_types[102]
#define SWIGTYPE_p_svn_diff_t swig_types[103]
#define SWIGTYPE_p_svn_dirent_t swig_types[104]
#define SWIGTYPE_p_svn_errno_t swig_types[105]
#define SWIGTYPE_p_svn_error_t swig_types[106]
#define SWIGTYPE_p_svn_io_dirent2_t swig_types[107]
#define SWIGTYPE_p_svn_io_dirent_t swig_types[108]
#define SWIGTYPE_p_svn_io_file_del_t swig_types[109]
#define SWIGTYPE_p_svn_location_segment_t swig_types[110]
#define SWIGTYPE_p_svn_lock_t swig_types[111]
#define SWIGTYPE_p_svn_log_changed_path2_t swig_types[112]
#define SWIGTYPE_p_svn_log_changed_path_t swig_types[113]
#define SWIGTYPE_p_svn_log_entry_t swig_types[114]
#define SWIGTYPE_p_svn_merge_range_t swig_types[115]
#define SWIGTYPE_p_svn_mergeinfo_inheritance_t swig_types[116]
#define SWIGTYPE_p_svn_node_kind_t swig_types[117]
#define SWIGTYPE_p_svn_opt_revision_range_t swig_types[118]
#define SWIGTYPE_p_svn_opt_revision_t swig_types[119]
#define SWIGTYPE_p_svn_opt_revision_value_t swig_types[120]
#define SWIGTYPE_p_svn_opt_subcommand_desc2_t swig_types[121]
#define SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides swig_types[122]
#define SWIGTYPE_p_svn_opt_subcommand_desc_t swig_types[123]
#define SWIGTYPE_p_svn_patch_file_t swig_types[124]
#define SWIGTYPE_p_svn_patch_t swig_types[125]
#define SWIGTYPE_p_svn_prop_kind swig_types[126]
#define SWIGTYPE_p_svn_prop_patch_t swig_types[127]
#define SWIGTYPE_p_svn_prop_t swig_types[128]
#define SWIGTYPE_p_svn_stream_mark_t swig_types[129]
#define SWIGTYPE_p_svn_stream_t swig_types[130]
#define SWIGTYPE_p_svn_string_t swig_types[131]
#define SWIGTYPE_p_svn_stringbuf_t swig_types[132]
#define SWIGTYPE_p_svn_tristate_t swig_types[133]
#define SWIGTYPE_p_svn_version_checklist_t swig_types[134]
#define SWIGTYPE_p_svn_version_t swig_types[135]
#define SWIGTYPE_p_unsigned_char swig_types[136]
#define SWIGTYPE_p_unsigned_long swig_types[137]
#define SWIGTYPE_p_void swig_types[138]
static swig_type_info *swig_types[140];
static swig_module_info swig_module = {swig_types, 139, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_SVN___Core

#define SWIG_name   "SVN::_Core::boot_SVN___Core"
#define SWIG_prefix "SVN::_Core::"

#define SWIGVERSION 0x020004 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT void SWIG_init (CV* cv);
#else
SWIGEXPORT void SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT void SWIG_init (CV *cv, CPerlObj *);
#endif


#include "svn_time.h"
#include "svn_pools.h"


#include "swigutil_pl.h"


#include <apr.h>
#include <apr_general.h>

#include <apr_md5.h>
#include "svn_diff.h"
#include "svn_private_config.h"


SWIGINTERNINLINE SV *
SWIG_From_long  SWIG_PERL_DECL_ARGS_1(long value)
{    
  SV *obj = sv_newmortal();
  sv_setiv(obj, (IV) value);
  return obj;
}


SWIGINTERNINLINE SV *
SWIG_From_int  SWIG_PERL_DECL_ARGS_1(int value)
{    
  return SWIG_From_long  SWIG_PERL_CALL_ARGS_1(value);
}


SWIGINTERN int
SWIG_AsVal_double SWIG_PERL_DECL_ARGS_2(SV *obj, double *val)
{
  if (SvNIOK(obj)) {
    if (val) *val = SvNV(obj);
    return SWIG_OK;
  } else if (SvIOK(obj)) {
    if (val) *val = (double) SvIV(obj);
    return SWIG_AddCast(SWIG_OK);
  } else {
    const char *nptr = SvPV_nolen(obj);
    if (nptr) {
      char *endptr;
      double v;
      errno = 0;
      v = strtod(nptr, &endptr);
      if (errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_Str2NumCast(SWIG_OK);
	}
      }
    }
  }
  return SWIG_TypeError;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long SWIG_PERL_DECL_ARGS_2(SV *obj, long* val)
{
  if (SvIOK(obj)) {
    if (val) *val = SvIV(obj);
    return SWIG_OK;
  } else {
    int dispatch = 0;
    const char *nptr = SvPV_nolen(obj);
    if (nptr) {
      char *endptr;
      long v;
      errno = 0;
      v = strtol(nptr, &endptr,0);
      if (errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_Str2NumCast(SWIG_OK);
	}
      }
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double SWIG_PERL_CALL_ARGS_2(obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
  return SWIG_TypeError;
}


#define SVN_SWIGEXPORT(t) SWIGEXPORT t



static apr_pool_t *current_pool = 0;

SVN_SWIGEXPORT(apr_pool_t *)
svn_swig_pl_get_current_pool (void)
{
  return current_pool;
}

SVN_SWIGEXPORT(void)
svn_swig_pl_set_current_pool (apr_pool_t *pool)
{
  current_pool = pool;
}



#include "svn_error_codes.h"




#include "svn_time.h"


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif



SWIGINTERN int
SWIG_AsVal_long_SS_long SWIG_PERL_DECL_ARGS_2(SV *obj, long long *val)
{
  if (SvIOK(obj)) {
    if (val) *val = SvIV(obj);
    return SWIG_OK;
  } else {
    int dispatch = 0;
    const char *nptr = SvPV_nolen(obj);
    if (nptr) {
      char *endptr;
      long long v;
      errno = 0;
      v = strtoll(nptr, &endptr,0);
      if (errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_Str2NumCast(SWIG_OK);
	}
      }
    }
    if (!dispatch) {
      const double mant_max = 1LL << DBL_MANT_DIG;
      const double mant_min = -mant_max;
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double SWIG_PERL_CALL_ARGS_2(obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
	if (val) *val = (long long)(d);
	return res;
      }
    }
  }
  return SWIG_TypeError; 
}


SWIGINTERNINLINE SV *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  SV *obj = sv_newmortal();
  if (carray) {
    sv_setpvn(obj, carray, size);
  } else {
    sv_setsv(obj, &PL_sv_undef);
  }
  return obj;
}


SWIGINTERNINLINE SV * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(SV *obj, char** cptr, size_t* psize, int *alloc)
{
  if (SvMAGICAL(obj)) {
     SV *tmp = sv_newmortal();
     SvSetSV(tmp, obj);
     obj = tmp;
  }
  if (SvPOK(obj)) {
    STRLEN len = 0;
    char *cstr = SvPV(obj, len); 
    size_t size = len + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = (char *)memcpy((char *)malloc((size)*sizeof(char)), cstr, sizeof(char)*(size));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      char* vptr = 0; 
      if (SWIG_ConvertPtr(obj, (void**)&vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = vptr;
	if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}







#include "svn_types.h"


SWIGINTERN int
SWIG_AsVal_int SWIG_PERL_DECL_ARGS_2(SV * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsCharArray(SV * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	free((char*)cptr);
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) free((char*)cptr);
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char SWIG_PERL_DECL_ARGS_2(SV * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = (char)(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE SV *
SWIG_From_char  SWIG_PERL_DECL_ARGS_1(char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


static svn_error_t * svn_log_invoke_entry_receiver(
  svn_log_entry_receiver_t _obj, void *baton, svn_log_entry_t *log_entry, apr_pool_t *pool) {
  return _obj(baton, log_entry, pool);
}

static svn_error_t * svn_log_invoke_message_receiver(
  svn_log_message_receiver_t _obj, void *baton, apr_hash_t *changed_paths, svn_revnum_t revision, const char *author, const char *date, const char *message, apr_pool_t *pool) {
  return _obj(baton, changed_paths, revision, author, date, message, pool);
}

static svn_error_t * svn_commit_invoke_callback2(
  svn_commit_callback2_t _obj, const svn_commit_info_t *commit_info, void *baton, apr_pool_t *pool) {
  return _obj(commit_info, baton, pool);
}

static svn_error_t * svn_commit_invoke_callback(
  svn_commit_callback_t _obj, svn_revnum_t new_revision, const char *date, const char *author, void *baton) {
  return _obj(new_revision, date, author, baton);
}

static svn_error_t * svn_cancel_invoke_func(
  svn_cancel_func_t _obj, void *cancel_baton) {
  return _obj(cancel_baton);
}

static svn_error_t * svn_location_invoke_segment_receiver(
  svn_location_segment_receiver_t _obj, svn_location_segment_t *segment, void *baton, apr_pool_t *pool) {
  return _obj(segment, baton, pool);
}



#include "svn_pools.h"




#include "svn_version.h"


static const svn_version_t * svn_version_checklist_invoke_version_query(
  svn_version_checklist_t * _obj) {
  return (_obj->version_query)();
}

static const svn_version_t * svn_version_invoke_func(
  svn_version_func_t _obj) {
  return _obj();
}



#include "svn_props.h"




#include "svn_opt.h"

typedef struct {
  int optch; const char *desc; 
} svn_opt_subcommand_desc2_t_desc_overrides;





#include "svn_auth.h"


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long SWIG_PERL_DECL_ARGS_2(SV *obj, unsigned long *val) 
{
  if (SvUOK(obj)) {
    if (val) *val = SvUV(obj);
    return SWIG_OK;
  } else  if (SvIOK(obj)) {
    long v = SvIV(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else {
    int dispatch = 0;
    const char *nptr = SvPV_nolen(obj);
    if (nptr) {
      char *endptr;
      unsigned long v;
      errno = 0;
      v = strtoul(nptr, &endptr,0);
      if (errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_Str2NumCast(SWIG_OK);
	}
      }
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double SWIG_PERL_CALL_ARGS_2(obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE SV *
SWIG_From_unsigned_SS_long  SWIG_PERL_DECL_ARGS_1(unsigned long value)
{    
  SV *obj = sv_newmortal();
  sv_setuv(obj, (UV) value);
  return obj;
}


static svn_error_t * svn_auth_provider_invoke_first_credentials(
  svn_auth_provider_t * _obj, void **credentials, void **iter_baton, void *provider_baton, apr_hash_t *parameters, const char *realmstring, apr_pool_t *pool) {
  return (_obj->first_credentials)(credentials, iter_baton, provider_baton, parameters, realmstring, pool);
}

static svn_error_t * svn_auth_provider_invoke_next_credentials(
  svn_auth_provider_t * _obj, void **credentials, void *iter_baton, void *provider_baton, apr_hash_t *parameters, const char *realmstring, apr_pool_t *pool) {
  return (_obj->next_credentials)(credentials, iter_baton, provider_baton, parameters, realmstring, pool);
}

static svn_error_t * svn_auth_provider_invoke_save_credentials(
  svn_auth_provider_t * _obj, svn_boolean_t *saved, void *credentials, void *provider_baton, apr_hash_t *parameters, const char *realmstring, apr_pool_t *pool) {
  return (_obj->save_credentials)(saved, credentials, provider_baton, parameters, realmstring, pool);
}

static void svn_auth_invoke_simple_provider_func(
  svn_auth_simple_provider_func_t _obj, svn_auth_provider_object_t **provider, apr_pool_t *pool) {
  _obj(provider, pool);
}

static void svn_auth_invoke_ssl_client_cert_pw_provider_func(
  svn_auth_ssl_client_cert_pw_provider_func_t _obj, svn_auth_provider_object_t **provider, apr_pool_t *pool) {
  _obj(provider, pool);
}

static svn_error_t * svn_auth_invoke_simple_prompt_func(
  svn_auth_simple_prompt_func_t _obj, svn_auth_cred_simple_t **cred, void *baton, const char *realm, const char *username, svn_boolean_t may_save, apr_pool_t *pool) {
  return _obj(cred, baton, realm, username, may_save, pool);
}

static svn_error_t * svn_auth_invoke_username_prompt_func(
  svn_auth_username_prompt_func_t _obj, svn_auth_cred_username_t **cred, void *baton, const char *realm, svn_boolean_t may_save, apr_pool_t *pool) {
  return _obj(cred, baton, realm, may_save, pool);
}

static svn_error_t * svn_auth_invoke_ssl_server_trust_prompt_func(
  svn_auth_ssl_server_trust_prompt_func_t _obj, svn_auth_cred_ssl_server_trust_t **cred, void *baton, const char *realm, apr_uint32_t failures, const svn_auth_ssl_server_cert_info_t *cert_info, svn_boolean_t may_save, apr_pool_t *pool) {
  return _obj(cred, baton, realm, failures, cert_info, may_save, pool);
}

static svn_error_t * svn_auth_invoke_ssl_client_cert_prompt_func(
  svn_auth_ssl_client_cert_prompt_func_t _obj, svn_auth_cred_ssl_client_cert_t **cred, void *baton, const char *realm, svn_boolean_t may_save, apr_pool_t *pool) {
  return _obj(cred, baton, realm, may_save, pool);
}

static svn_error_t * svn_auth_invoke_ssl_client_cert_pw_prompt_func(
  svn_auth_ssl_client_cert_pw_prompt_func_t _obj, svn_auth_cred_ssl_client_cert_pw_t **cred, void *baton, const char *realm, svn_boolean_t may_save, apr_pool_t *pool) {
  return _obj(cred, baton, realm, may_save, pool);
}

static svn_error_t * svn_auth_invoke_plaintext_prompt_func(
  svn_auth_plaintext_prompt_func_t _obj, svn_boolean_t *may_save_plaintext, const char *realmstring, void *baton, apr_pool_t *pool) {
  return _obj(may_save_plaintext, realmstring, baton, pool);
}

static svn_error_t * svn_auth_invoke_plaintext_passphrase_prompt_func(
  svn_auth_plaintext_passphrase_prompt_func_t _obj, svn_boolean_t *may_save_plaintext, const char *realmstring, void *baton, apr_pool_t *pool) {
  return _obj(may_save_plaintext, realmstring, baton, pool);
}



#include "svn_config.h"


static svn_boolean_t svn_config_invoke_section_enumerator(
  svn_config_section_enumerator_t _obj, const char *name, void *baton) {
  return _obj(name, baton);
}

static svn_boolean_t svn_config_invoke_section_enumerator2(
  svn_config_section_enumerator2_t _obj, const char *name, void *baton, apr_pool_t *pool) {
  return _obj(name, baton, pool);
}

static svn_boolean_t svn_config_invoke_enumerator(
  svn_config_enumerator_t _obj, const char *name, const char *value, void *baton) {
  return _obj(name, value, baton);
}

static svn_boolean_t svn_config_invoke_enumerator2(
  svn_config_enumerator2_t _obj, const char *name, const char *value, void *baton, apr_pool_t *pool) {
  return _obj(name, value, baton, pool);
}



#include "svn_utf.h"




#include "svn_nls.h"




#include "svn_path.h"




#include "svn_dirent_uri.h"




#include "svn_mergeinfo.h"




#include "svn_io.h"


static svn_error_t * svn_read_invoke_fn(
  svn_read_fn_t _obj, void *baton, char *buffer, apr_size_t *len) {
  return _obj(baton, buffer, len);
}

static svn_error_t * svn_stream_invoke_skip_fn(
  svn_stream_skip_fn_t _obj, void *baton, apr_size_t len) {
  return _obj(baton, len);
}

static svn_error_t * svn_write_invoke_fn(
  svn_write_fn_t _obj, void *baton, const char *data, apr_size_t *len) {
  return _obj(baton, data, len);
}

static svn_error_t * svn_close_invoke_fn(
  svn_close_fn_t _obj, void *baton) {
  return _obj(baton);
}

static svn_error_t * svn_stream_invoke_mark_fn(
  svn_stream_mark_fn_t _obj, void *baton, svn_stream_mark_t **mark, apr_pool_t *pool) {
  return _obj(baton, mark, pool);
}

static svn_error_t * svn_stream_invoke_seek_fn(
  svn_stream_seek_fn_t _obj, void *baton, const svn_stream_mark_t *mark) {
  return _obj(baton, mark);
}

static svn_error_t * svn_io_invoke_walk_func(
  svn_io_walk_func_t _obj, void *baton, const char *path, const apr_finfo_t *finfo, apr_pool_t *pool) {
  return _obj(baton, path, finfo, pool);
}



#include "svn_md5.h"




#include "svn_diff.h"


static svn_error_t * svn_diff_fns2_invoke_datasources_open(
  svn_diff_fns2_t * _obj, void *diff_baton, apr_off_t *prefix_lines, apr_off_t *suffix_lines, const svn_diff_datasource_e *datasources, apr_size_t datasources_len) {
  return (_obj->datasources_open)(diff_baton, prefix_lines, suffix_lines, datasources, datasources_len);
}

static svn_error_t * svn_diff_fns2_invoke_datasource_close(
  svn_diff_fns2_t * _obj, void *diff_baton, svn_diff_datasource_e datasource) {
  return (_obj->datasource_close)(diff_baton, datasource);
}

static svn_error_t * svn_diff_fns2_invoke_datasource_get_next_token(
  svn_diff_fns2_t * _obj, apr_uint32_t *hash, void **token, void *diff_baton, svn_diff_datasource_e datasource) {
  return (_obj->datasource_get_next_token)(hash, token, diff_baton, datasource);
}

static svn_error_t * svn_diff_fns2_invoke_token_compare(
  svn_diff_fns2_t * _obj, void *diff_baton, void *ltoken, void *rtoken, int *compare) {
  return (_obj->token_compare)(diff_baton, ltoken, rtoken, compare);
}

static void svn_diff_fns2_invoke_token_discard(
  svn_diff_fns2_t * _obj, void *diff_baton, void *token) {
  (_obj->token_discard)(diff_baton, token);
}

static void svn_diff_fns2_invoke_token_discard_all(
  svn_diff_fns2_t * _obj, void *diff_baton) {
  (_obj->token_discard_all)(diff_baton);
}

static svn_error_t * svn_diff_fns_invoke_datasource_open(
  svn_diff_fns_t * _obj, void *diff_baton, svn_diff_datasource_e datasource) {
  return (_obj->datasource_open)(diff_baton, datasource);
}

static svn_error_t * svn_diff_fns_invoke_datasource_close(
  svn_diff_fns_t * _obj, void *diff_baton, svn_diff_datasource_e datasource) {
  return (_obj->datasource_close)(diff_baton, datasource);
}

static svn_error_t * svn_diff_fns_invoke_datasource_get_next_token(
  svn_diff_fns_t * _obj, apr_uint32_t *hash, void **token, void *diff_baton, svn_diff_datasource_e datasource) {
  return (_obj->datasource_get_next_token)(hash, token, diff_baton, datasource);
}

static svn_error_t * svn_diff_fns_invoke_token_compare(
  svn_diff_fns_t * _obj, void *diff_baton, void *ltoken, void *rtoken, int *compare) {
  return (_obj->token_compare)(diff_baton, ltoken, rtoken, compare);
}

static void svn_diff_fns_invoke_token_discard(
  svn_diff_fns_t * _obj, void *diff_baton, void *token) {
  (_obj->token_discard)(diff_baton, token);
}

static void svn_diff_fns_invoke_token_discard_all(
  svn_diff_fns_t * _obj, void *diff_baton) {
  (_obj->token_discard_all)(diff_baton);
}

static svn_error_t * svn_diff_output_fns_invoke_output_common(
  svn_diff_output_fns_t * _obj, void *output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) {
  return (_obj->output_common)(output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length);
}

static svn_error_t * svn_diff_output_fns_invoke_output_diff_modified(
  svn_diff_output_fns_t * _obj, void *output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) {
  return (_obj->output_diff_modified)(output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length);
}

static svn_error_t * svn_diff_output_fns_invoke_output_diff_latest(
  svn_diff_output_fns_t * _obj, void *output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) {
  return (_obj->output_diff_latest)(output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length);
}

static svn_error_t * svn_diff_output_fns_invoke_output_diff_common(
  svn_diff_output_fns_t * _obj, void *output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) {
  return (_obj->output_diff_common)(output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length);
}

static svn_error_t * svn_diff_output_fns_invoke_output_conflict(
  svn_diff_output_fns_t * _obj, void *output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length, svn_diff_t *resolved_diff) {
  return (_obj->output_conflict)(output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length, resolved_diff);
}



#include "svn_error.h"


static svn_error_t * svn_error_invoke_malfunction_handler(
  svn_error_malfunction_handler_t _obj, svn_boolean_t can_return, const char *file, int line, const char *expr) {
  return _obj(can_return, file, line, expr);
}



#include "svn_private_config.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_SVN___Core_var::
class _wrap_SVN___Core_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *SWIGUNUSEDPARM(sv), MAGIC *SWIGUNUSEDPARM(mg)) {
    MAGIC_PPERL
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_current_pool_set(pTHX_ SV* sv, MAGIC * SWIGUNUSEDPARM(mg)) {
  MAGIC_PPERL
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(sv, &argp, SWIGTYPE_p_apr_pool_t,  0 );  
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""current_pool""' of type '""apr_pool_t *""'");
    }
    current_pool = (apr_pool_t *)(argp);
  }
fail:
  return 1;
}


SWIGCLASS_STATIC int _wrap_current_pool_get(pTHX_ SV *sv, MAGIC *SWIGUNUSEDPARM(mg)) {
  MAGIC_PPERL
  sv_setiv(SvRV(sv),PTR2IV(current_pool));
  return 1;
}




#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_apr_initialize) {
  {
    int argvi = 0;
    apr_status_t result;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: apr_initialize();");
    }
    {
      result = (apr_status_t)apr_initialize();
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_apr_terminate) {
  {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: apr_terminate();");
    }
    {
      apr_terminate();
      
      
      
    }
    ST(argvi) = sv_newmortal();
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_apr_time_ansi_put) {
  {
    apr_time_t *arg1 = (apr_time_t *) 0 ;
    time_t arg2 ;
    apr_int64_t temp1 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    apr_status_t result;
    dXSARGS;
    
    arg1 = &temp1;
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: apr_time_ansi_put(input);");
    }
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(0), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "apr_time_ansi_put" "', argument " "2"" of type '" "time_t""'");
    } 
    arg2 = (time_t)(val2);
    {
      result = (apr_status_t)apr_time_ansi_put(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t)*(arg1));
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(temp, 0)); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_apr_pool_destroy) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: apr_pool_destroy(p);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_pool_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "apr_pool_destroy" "', argument " "1"" of type '" "apr_pool_t *""'"); 
    }
    arg1 = (apr_pool_t *)(argp1);
    {
      apr_pool_destroy(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_apr_pool_clear) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: apr_pool_clear(p);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_pool_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "apr_pool_clear" "', argument " "1"" of type '" "apr_pool_t *""'"); 
    }
    arg1 = (apr_pool_t *)(argp1);
    {
      apr_pool_clear(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_apr_file_open_stdout) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    int argvi = 0;
    apr_status_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: apr_file_open_stdout(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (apr_status_t)apr_file_open_stdout(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_apr_file_open_stderr) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    int argvi = 0;
    apr_status_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: apr_file_open_stderr(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (apr_status_t)apr_file_open_stderr(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_time_to_cstring) {
  {
    apr_time_t arg1 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    long long val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_time_to_cstring(when,pool);");
    }
    ecode1 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_time_to_cstring" "', argument " "1"" of type '" "apr_time_t""'");
    } 
    arg1 = (apr_time_t)(val1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_time_to_cstring(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_time_from_cstring) {
  {
    apr_time_t *arg1 = (apr_time_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_int64_t temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_time_from_cstring(data,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_time_from_cstring" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_time_from_cstring(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t)*(arg1));
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(temp, 0)); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_time_to_human_cstring) {
  {
    apr_time_t arg1 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    long long val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_time_to_human_cstring(when,pool);");
    }
    ecode1 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_time_to_human_cstring" "', argument " "1"" of type '" "apr_time_t""'");
    } 
    arg1 = (apr_time_t)(val1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_time_to_human_cstring(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_parse_date) {
  {
    svn_boolean_t *arg1 = (svn_boolean_t *) 0 ;
    apr_time_t *arg2 = (apr_time_t *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_time_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp1 ;
    int res1 = SWIG_TMPOBJ ;
    apr_int64_t temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_parse_date(text,now,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_parse_date" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_parse_date" "', argument " "4"" of type '" "apr_time_t""'");
    } 
    arg4 = (apr_time_t)(val4);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_parse_date(arg1,arg2,(char const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t)*(arg2));
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(temp, 0)); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_sleep_for_timestamps) {
  {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: svn_sleep_for_timestamps();");
    }
    {
      svn_sleep_for_timestamps();
      
      
      
    }
    ST(argvi) = sv_newmortal();
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_apr_err_set) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    apr_status_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_t_apr_err_set(self,apr_err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_apr_err_set" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_error_t_apr_err_set" "', argument " "2"" of type '" "apr_status_t""'");
    } 
    arg2 = (apr_status_t)(val2);
    if (arg1) (arg1)->apr_err = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_apr_err_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_status_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_apr_err_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_apr_err_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (apr_status_t) ((arg1)->apr_err);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_message_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_message_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_message_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (char *) ((arg1)->message);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_child_set) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    struct svn_error_t *arg2 = (struct svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_t_child_set(self,child);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_child_set" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_t_child_set" "', argument " "2"" of type '" "struct svn_error_t *""'"); 
    }
    arg2 = (struct svn_error_t *)(argp2);
    if (arg1) (arg1)->child = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_child_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    struct svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_child_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_child_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (struct svn_error_t *) ((arg1)->child);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_error_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_pool_set) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_error_t_pool_set(self,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_pool_set" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    if (items > 1) {
      
    }
    if (arg1) (arg1)->pool = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_pool_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_pool_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_pool_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_pool_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (apr_pool_t *) ((arg1)->pool);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_pool_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_file_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_file_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_file_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (char *) ((arg1)->file);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_line_set) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    long arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_t_line_set(self,line);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_line_set" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_error_t_line_set" "', argument " "2"" of type '" "long""'");
    } 
    arg2 = (long)(val2);
    if (arg1) (arg1)->line = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_t_line_get) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    long result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_t_line_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_t_line_get" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    result = (long) ((arg1)->line);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_error_t) {
  {
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_error_t();");
    }
    {
      result = (svn_error_t *)calloc(1, sizeof(svn_error_t));
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_error_t) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_error_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_error_t" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn__apr_hash_index_key) {
  {
    apr_hash_index_t *arg1 = (apr_hash_index_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn__apr_hash_index_key(hi);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_index_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn__apr_hash_index_key" "', argument " "1"" of type '" "apr_hash_index_t const *""'"); 
    }
    arg1 = (apr_hash_index_t *)(argp1);
    {
      result = (void *)svn__apr_hash_index_key((apr_hash_index_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn__apr_hash_index_klen) {
  {
    apr_hash_index_t *arg1 = (apr_hash_index_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_ssize_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn__apr_hash_index_klen(hi);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_index_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn__apr_hash_index_klen" "', argument " "1"" of type '" "apr_hash_index_t const *""'"); 
    }
    arg1 = (apr_hash_index_t *)(argp1);
    {
      result = svn__apr_hash_index_klen((apr_hash_index_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn__apr_hash_index_val) {
  {
    apr_hash_index_t *arg1 = (apr_hash_index_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn__apr_hash_index_val(hi);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_index_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn__apr_hash_index_val" "', argument " "1"" of type '" "apr_hash_index_t const *""'"); 
    }
    arg1 = (apr_hash_index_t *)(argp1);
    {
      result = (void *)svn__apr_hash_index_val((apr_hash_index_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_node_kind_to_word) {
  {
    svn_node_kind_t arg1 ;
    int val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_node_kind_to_word(kind);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_node_kind_to_word" "', argument " "1"" of type '" "svn_node_kind_t""'");
    } 
    arg1 = (svn_node_kind_t)(val1);
    {
      result = (char *)svn_node_kind_to_word(arg1);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_node_kind_from_word) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_node_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_node_kind_from_word(word);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_node_kind_from_word" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_node_kind_t)svn_node_kind_from_word((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_tristate__to_word) {
  {
    svn_tristate_t arg1 ;
    int val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_tristate__to_word(tristate);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_tristate__to_word" "', argument " "1"" of type '" "svn_tristate_t""'");
    } 
    arg1 = (svn_tristate_t)(val1);
    {
      result = (char *)svn_tristate__to_word(arg1);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_tristate__from_word) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_tristate_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_tristate__from_word(word);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_tristate__from_word" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_tristate_t)svn_tristate__from_word((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_revnum_parse) {
  {
    svn_revnum_t *arg1 = (svn_revnum_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char **arg3 = (char **) 0 ;
    svn_revnum_t temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    char *temp3 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg1 = &temp1;
    arg3 = &temp3;
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_revnum_parse(str);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_revnum_parse" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_error_t *)svn_revnum_parse(arg1,(char const *)arg2,(char const **)arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_long, new_flags); argvi++  ;
    }
    {
      if (*arg3 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg3, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_depth_to_word) {
  {
    svn_depth_t arg1 ;
    int val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_depth_to_word(depth);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_depth_to_word" "', argument " "1"" of type '" "svn_depth_t""'");
    } 
    arg1 = (svn_depth_t)(val1);
    {
      result = (char *)svn_depth_to_word(arg1);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_depth_from_word) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_depth_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_depth_from_word(word);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_depth_from_word" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_depth_t)svn_depth_from_word((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_kind_set) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    svn_node_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_t_kind_set(self,kind);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_kind_set" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_t_kind_set" "', argument " "2"" of type '" "svn_node_kind_t""'");
    } 
    arg2 = (svn_node_kind_t)(val2);
    if (arg1) (arg1)->kind = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_kind_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_node_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_kind_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_kind_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result = (svn_node_kind_t) ((arg1)->kind);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_size_set) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    svn_filesize_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_t_size_set(self,size);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_size_set" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_t_size_set" "', argument " "2"" of type '" "svn_filesize_t""'");
    } 
    arg2 = (svn_filesize_t)(val2);
    if (arg1) (arg1)->size = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_size_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_filesize_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_size_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_size_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result =  ((arg1)->size);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_has_props_set) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_t_has_props_set(self,has_props);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_has_props_set" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_t_has_props_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->has_props = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_has_props_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_has_props_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_has_props_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->has_props);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_created_rev_set) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_t_created_rev_set(self,created_rev);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_created_rev_set" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_t_created_rev_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->created_rev = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_created_rev_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_created_rev_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_created_rev_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->created_rev);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_time_set) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    apr_time_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_t_time_set(self,time);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_time_set" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_t_time_set" "', argument " "2"" of type '" "apr_time_t""'");
    } 
    arg2 = (apr_time_t)(val2);
    if (arg1) (arg1)->time = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_time_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_time_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_time_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_time_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result =  ((arg1)->time);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_t_last_author_get) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_t_last_author_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_t_last_author_get" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    result = (char *) ((arg1)->last_author);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_dirent_t) {
  {
    int argvi = 0;
    svn_dirent_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_dirent_t();");
    }
    {
      result = (svn_dirent_t *)calloc(1, sizeof(svn_dirent_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_dirent_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_dirent_t) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_dirent_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_dirent_t" "', argument " "1"" of type '" "svn_dirent_t *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_dup) {
  {
    svn_dirent_t *arg1 = (svn_dirent_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_dirent_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_dup(dirent,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_dup" "', argument " "1"" of type '" "svn_dirent_t const *""'"); 
    }
    arg1 = (svn_dirent_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_dirent_t *)svn_dirent_dup((struct svn_dirent_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_dirent_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_revision_set) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_t_revision_set(self,revision);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_revision_set" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_commit_info_t_revision_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->revision = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_revision_get) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_commit_info_t_revision_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_revision_get" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->revision);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_date_set) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_t_date_set(self,date);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_date_set" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_commit_info_t_date_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->date) free((char *)arg1->date);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->date = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_date_get) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_commit_info_t_date_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_date_get" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    result = (char *) ((arg1)->date);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_author_set) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_t_author_set(self,author);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_author_set" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_commit_info_t_author_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->author) free((char *)arg1->author);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->author = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_author_get) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_commit_info_t_author_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_author_get" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    result = (char *) ((arg1)->author);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_post_commit_err_set) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_t_post_commit_err_set(self,post_commit_err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_post_commit_err_set" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_commit_info_t_post_commit_err_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->post_commit_err) free((char *)arg1->post_commit_err);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->post_commit_err = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_post_commit_err_get) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_commit_info_t_post_commit_err_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_post_commit_err_get" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    result = (char *) ((arg1)->post_commit_err);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_repos_root_set) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_t_repos_root_set(self,repos_root);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_repos_root_set" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_commit_info_t_repos_root_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->repos_root) free((char *)arg1->repos_root);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->repos_root = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_t_repos_root_get) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_commit_info_t_repos_root_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_t_repos_root_get" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    result = (char *) ((arg1)->repos_root);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_commit_info_t) {
  {
    int argvi = 0;
    svn_commit_info_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_commit_info_t();");
    }
    {
      result = (svn_commit_info_t *)calloc(1, sizeof(svn_commit_info_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_commit_info_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_commit_info_t) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_commit_info_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_commit_info_t" "', argument " "1"" of type '" "svn_commit_info_t *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_create_commit_info) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_commit_info_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_create_commit_info(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_commit_info_t *)svn_create_commit_info(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_commit_info_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_info_dup) {
  {
    svn_commit_info_t *arg1 = (svn_commit_info_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_commit_info_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_commit_info_dup(src_commit_info,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_commit_info_dup" "', argument " "1"" of type '" "svn_commit_info_t const *""'"); 
    }
    arg1 = (svn_commit_info_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_commit_info_t *)svn_commit_info_dup((struct svn_commit_info_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_commit_info_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_action_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    char arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_action_set(self,action);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_action_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    ecode2 = SWIG_AsVal_char SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path2_t_action_set" "', argument " "2"" of type '" "char""'");
    } 
    arg2 = (char)(val2);
    if (arg1) (arg1)->action = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_action_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_action_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_action_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (char) ((arg1)->action);
    ST(argvi) = SWIG_From_char  SWIG_PERL_CALL_ARGS_1((char)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_copyfrom_path_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_copyfrom_path_set(self,copyfrom_path);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_copyfrom_path_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_changed_path2_t_copyfrom_path_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->copyfrom_path) free((char *)arg1->copyfrom_path);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->copyfrom_path = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_copyfrom_path_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_copyfrom_path_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_copyfrom_path_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (char *) ((arg1)->copyfrom_path);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_copyfrom_rev_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_copyfrom_rev_set(self,copyfrom_rev);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_copyfrom_rev_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path2_t_copyfrom_rev_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->copyfrom_rev = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_copyfrom_rev_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_copyfrom_rev_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_copyfrom_rev_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->copyfrom_rev);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_node_kind_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    svn_node_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_node_kind_set(self,node_kind);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_node_kind_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path2_t_node_kind_set" "', argument " "2"" of type '" "svn_node_kind_t""'");
    } 
    arg2 = (svn_node_kind_t)(val2);
    if (arg1) (arg1)->node_kind = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_node_kind_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_node_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_node_kind_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_node_kind_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (svn_node_kind_t) ((arg1)->node_kind);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_text_modified_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    svn_tristate_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_text_modified_set(self,text_modified);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_text_modified_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path2_t_text_modified_set" "', argument " "2"" of type '" "svn_tristate_t""'");
    } 
    arg2 = (svn_tristate_t)(val2);
    if (arg1) (arg1)->text_modified = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_text_modified_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_tristate_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_text_modified_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_text_modified_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (svn_tristate_t) ((arg1)->text_modified);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_props_modified_set) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    svn_tristate_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_props_modified_set(self,props_modified);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_props_modified_set" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path2_t_props_modified_set" "', argument " "2"" of type '" "svn_tristate_t""'");
    } 
    arg2 = (svn_tristate_t)(val2);
    if (arg1) (arg1)->props_modified = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_t_props_modified_get) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_tristate_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_t_props_modified_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_t_props_modified_get" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    result = (svn_tristate_t) ((arg1)->props_modified);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_log_changed_path2_t) {
  {
    int argvi = 0;
    svn_log_changed_path2_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_log_changed_path2_t();");
    }
    {
      result = (svn_log_changed_path2_t *)calloc(1, sizeof(svn_log_changed_path2_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_changed_path2_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_log_changed_path2_t) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_log_changed_path2_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_log_changed_path2_t" "', argument " "1"" of type '" "svn_log_changed_path2_t *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_log_changed_path2_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path2_create(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_log_changed_path2_t *)svn_log_changed_path2_create(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_changed_path2_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path2_dup) {
  {
    svn_log_changed_path2_t *arg1 = (svn_log_changed_path2_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_log_changed_path2_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path2_dup(changed_path,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path2_dup" "', argument " "1"" of type '" "svn_log_changed_path2_t const *""'"); 
    }
    arg1 = (svn_log_changed_path2_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_log_changed_path2_t *)svn_log_changed_path2_dup((struct svn_log_changed_path2_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_changed_path2_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_t_action_set) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    char arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path_t_action_set(self,action);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_t_action_set" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    ecode2 = SWIG_AsVal_char SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path_t_action_set" "', argument " "2"" of type '" "char""'");
    } 
    arg2 = (char)(val2);
    if (arg1) (arg1)->action = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_t_action_get) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path_t_action_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_t_action_get" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    result = (char) ((arg1)->action);
    ST(argvi) = SWIG_From_char  SWIG_PERL_CALL_ARGS_1((char)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_t_copyfrom_path_get) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path_t_copyfrom_path_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_t_copyfrom_path_get" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    result = (char *) ((arg1)->copyfrom_path);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_t_copyfrom_rev_set) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path_t_copyfrom_rev_set(self,copyfrom_rev);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_t_copyfrom_rev_set" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_changed_path_t_copyfrom_rev_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->copyfrom_rev = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_t_copyfrom_rev_get) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_changed_path_t_copyfrom_rev_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_t_copyfrom_rev_get" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->copyfrom_rev);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_log_changed_path_t) {
  {
    int argvi = 0;
    svn_log_changed_path_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_log_changed_path_t();");
    }
    {
      result = (svn_log_changed_path_t *)calloc(1, sizeof(svn_log_changed_path_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_changed_path_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_log_changed_path_t) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_log_changed_path_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_log_changed_path_t" "', argument " "1"" of type '" "svn_log_changed_path_t *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_changed_path_dup) {
  {
    svn_log_changed_path_t *arg1 = (svn_log_changed_path_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_log_changed_path_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_log_changed_path_dup(changed_path,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_changed_path_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_changed_path_dup" "', argument " "1"" of type '" "svn_log_changed_path_t const *""'"); 
    }
    arg1 = (svn_log_changed_path_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_log_changed_path_t *)svn_log_changed_path_dup((struct svn_log_changed_path_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_changed_path_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_changed_paths_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    apr_hash_t *arg2 = (apr_hash_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_changed_paths_set(self,changed_paths);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_changed_paths_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_hash_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_entry_t_changed_paths_set" "', argument " "2"" of type '" "apr_hash_t *""'"); 
    }
    arg2 = (apr_hash_t *)(argp2);
    if (arg1) (arg1)->changed_paths = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_changed_paths_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_changed_paths_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_changed_paths_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (apr_hash_t *) ((arg1)->changed_paths);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_revision_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_revision_set(self,revision);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_revision_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_entry_t_revision_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->revision = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_revision_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_revision_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_revision_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->revision);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_revprops_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    apr_hash_t *arg2 = (apr_hash_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_revprops_set(self,revprops);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_revprops_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_hash_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_entry_t_revprops_set" "', argument " "2"" of type '" "apr_hash_t *""'"); 
    }
    arg2 = (apr_hash_t *)(argp2);
    if (arg1) (arg1)->revprops = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_revprops_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_revprops_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_revprops_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (apr_hash_t *) ((arg1)->revprops);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_has_children_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_has_children_set(self,has_children);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_has_children_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_entry_t_has_children_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->has_children = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_has_children_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_has_children_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_has_children_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->has_children);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_changed_paths2_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    apr_hash_t *arg2 = (apr_hash_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_changed_paths2_set(self,changed_paths2);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_changed_paths2_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_hash_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_entry_t_changed_paths2_set" "', argument " "2"" of type '" "apr_hash_t *""'"); 
    }
    arg2 = (apr_hash_t *)(argp2);
    if (arg1) (arg1)->changed_paths2 = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_changed_paths2_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_changed_paths2_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_changed_paths2_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (apr_hash_t *) ((arg1)->changed_paths2);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_non_inheritable_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_non_inheritable_set(self,non_inheritable);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_non_inheritable_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_entry_t_non_inheritable_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->non_inheritable = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_non_inheritable_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_non_inheritable_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_non_inheritable_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->non_inheritable);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_subtractive_merge_set) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_t_subtractive_merge_set(self,subtractive_merge);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_subtractive_merge_set" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_log_entry_t_subtractive_merge_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->subtractive_merge = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_t_subtractive_merge_get) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_t_subtractive_merge_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_t_subtractive_merge_get" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->subtractive_merge);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_log_entry_t) {
  {
    int argvi = 0;
    svn_log_entry_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_log_entry_t();");
    }
    {
      result = (svn_log_entry_t *)calloc(1, sizeof(svn_log_entry_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_entry_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_log_entry_t) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_log_entry_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_log_entry_t" "', argument " "1"" of type '" "svn_log_entry_t *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_log_entry_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_log_entry_create(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_log_entry_t *)svn_log_entry_create(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_entry_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_entry_dup) {
  {
    svn_log_entry_t *arg1 = (svn_log_entry_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_log_entry_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_log_entry_dup(log_entry,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_log_entry_dup" "', argument " "1"" of type '" "svn_log_entry_t const *""'"); 
    }
    arg1 = (svn_log_entry_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_log_entry_t *)svn_log_entry_dup((struct svn_log_entry_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_log_entry_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mime_type_validate) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_mime_type_validate(mime_type,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_mime_type_validate" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_mime_type_validate((char const *)arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mime_type_is_binary) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_mime_type_is_binary(mime_type);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_mime_type_is_binary" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_mime_type_is_binary((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_path_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_path_set(self,path);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_path_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_lock_t_path_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->path) free((char *)arg1->path);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->path = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_path_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_path_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_path_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result = (char *) ((arg1)->path);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_token_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_token_set(self,token);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_token_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_lock_t_token_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->token) free((char *)arg1->token);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->token = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_token_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_token_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_token_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result = (char *) ((arg1)->token);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_owner_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_owner_set(self,owner);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_owner_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_lock_t_owner_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->owner) free((char *)arg1->owner);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->owner = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_owner_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_owner_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_owner_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result = (char *) ((arg1)->owner);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_comment_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_comment_set(self,comment);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_comment_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_lock_t_comment_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->comment) free((char *)arg1->comment);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->comment = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_comment_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_comment_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_comment_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result = (char *) ((arg1)->comment);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_is_dav_comment_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_is_dav_comment_set(self,is_dav_comment);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_is_dav_comment_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_lock_t_is_dav_comment_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->is_dav_comment = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_is_dav_comment_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_is_dav_comment_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_is_dav_comment_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->is_dav_comment);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_creation_date_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    apr_time_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_creation_date_set(self,creation_date);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_creation_date_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_lock_t_creation_date_set" "', argument " "2"" of type '" "apr_time_t""'");
    } 
    arg2 = (apr_time_t)(val2);
    if (arg1) (arg1)->creation_date = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_creation_date_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_time_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_creation_date_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_creation_date_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result =  ((arg1)->creation_date);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_expiration_date_set) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    apr_time_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_t_expiration_date_set(self,expiration_date);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_expiration_date_set" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_lock_t_expiration_date_set" "', argument " "2"" of type '" "apr_time_t""'");
    } 
    arg2 = (apr_time_t)(val2);
    if (arg1) (arg1)->expiration_date = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_t_expiration_date_get) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_time_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_t_expiration_date_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_t_expiration_date_get" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    result =  ((arg1)->expiration_date);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_lock_t) {
  {
    int argvi = 0;
    svn_lock_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_lock_t();");
    }
    {
      result = (svn_lock_t *)calloc(1, sizeof(svn_lock_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_lock_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_lock_t) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_lock_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_lock_t" "', argument " "1"" of type '" "svn_lock_t *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_lock_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_lock_create(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_lock_t *)svn_lock_create(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_lock_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_lock_dup) {
  {
    svn_lock_t *arg1 = (svn_lock_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_lock_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_lock_dup(lock,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_lock_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_lock_dup" "', argument " "1"" of type '" "svn_lock_t const *""'"); 
    }
    arg1 = (svn_lock_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_lock_t *)svn_lock_dup((struct svn_lock_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_lock_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uuid_generate) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_uuid_generate(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (char *)svn_uuid_generate(arg1);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_start_set) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_merge_range_t_start_set(self,start);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_start_set" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_merge_range_t_start_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->start = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_start_get) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_merge_range_t_start_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_start_get" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->start);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_end_set) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_merge_range_t_end_set(self,end);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_end_set" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_merge_range_t_end_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->end = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_end_get) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_merge_range_t_end_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_end_get" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->end);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_inheritable_set) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_merge_range_t_inheritable_set(self,inheritable);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_inheritable_set" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_merge_range_t_inheritable_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->inheritable = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_t_inheritable_get) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_merge_range_t_inheritable_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_t_inheritable_get" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->inheritable);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_merge_range_t) {
  {
    int argvi = 0;
    svn_merge_range_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_merge_range_t();");
    }
    {
      result = (svn_merge_range_t *)calloc(1, sizeof(svn_merge_range_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_merge_range_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_merge_range_t) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_merge_range_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_merge_range_t" "', argument " "1"" of type '" "svn_merge_range_t *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_dup) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_merge_range_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_merge_range_dup(range,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_dup" "', argument " "1"" of type '" "svn_merge_range_t const *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_merge_range_t *)svn_merge_range_dup((struct svn_merge_range_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_merge_range_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_merge_range_contains_rev) {
  {
    svn_merge_range_t *arg1 = (svn_merge_range_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_merge_range_contains_rev(range,rev);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_merge_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_merge_range_contains_rev" "', argument " "1"" of type '" "svn_merge_range_t const *""'"); 
    }
    arg1 = (svn_merge_range_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_merge_range_contains_rev" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    {
      result = (svn_boolean_t)svn_merge_range_contains_rev((struct svn_merge_range_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_range_start_set) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_location_segment_t_range_start_set(self,range_start);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_range_start_set" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_location_segment_t_range_start_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->range_start = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_range_start_get) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_location_segment_t_range_start_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_range_start_get" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->range_start);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_range_end_set) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_location_segment_t_range_end_set(self,range_end);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_range_end_set" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_location_segment_t_range_end_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->range_end = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_range_end_get) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_location_segment_t_range_end_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_range_end_get" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->range_end);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_path_set) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_location_segment_t_path_set(self,path);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_path_set" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_location_segment_t_path_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->path) free((char *)arg1->path);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->path = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_t_path_get) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_location_segment_t_path_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_t_path_get" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    result = (char *) ((arg1)->path);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_location_segment_t) {
  {
    int argvi = 0;
    svn_location_segment_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_location_segment_t();");
    }
    {
      result = (svn_location_segment_t *)calloc(1, sizeof(svn_location_segment_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_location_segment_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_location_segment_t) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_location_segment_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_location_segment_t" "', argument " "1"" of type '" "svn_location_segment_t *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_segment_dup) {
  {
    svn_location_segment_t *arg1 = (svn_location_segment_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_location_segment_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_location_segment_dup(segment,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_location_segment_dup" "', argument " "1"" of type '" "svn_location_segment_t const *""'"); 
    }
    arg1 = (svn_location_segment_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_location_segment_t *)svn_location_segment_dup((struct svn_location_segment_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_location_segment_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_invoke_entry_receiver) {
  {
    svn_log_entry_receiver_t arg1 = (svn_log_entry_receiver_t) 0 ;
    void *arg2 = (void *) 0 ;
    svn_log_entry_t *arg3 = (svn_log_entry_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_log_invoke_entry_receiver(_obj,baton,log_entry,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_log_invoke_entry_receiver" "', argument " "1"" of type '" "svn_log_entry_receiver_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_invoke_entry_receiver" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_svn_log_entry_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_log_invoke_entry_receiver" "', argument " "3"" of type '" "svn_log_entry_t *""'"); 
    }
    arg3 = (svn_log_entry_t *)(argp3);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_log_invoke_entry_receiver(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_log_invoke_message_receiver) {
  {
    svn_log_message_receiver_t arg1 = (svn_log_message_receiver_t) 0 ;
    void *arg2 = (void *) 0 ;
    apr_hash_t *arg3 = (apr_hash_t *) 0 ;
    svn_revnum_t arg4 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    long val4 ;
    int ecode4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 7) || (items > 8)) {
      SWIG_croak("Usage: svn_log_invoke_message_receiver(_obj,baton,changed_paths,revision,author,date,message,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_log_invoke_message_receiver" "', argument " "1"" of type '" "svn_log_message_receiver_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_log_invoke_message_receiver" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_log_invoke_message_receiver" "', argument " "3"" of type '" "apr_hash_t *""'"); 
    }
    arg3 = (apr_hash_t *)(argp3);
    ecode4 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_log_invoke_message_receiver" "', argument " "4"" of type '" "svn_revnum_t""'");
    } 
    arg4 = (svn_revnum_t)(val4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_log_invoke_message_receiver" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_log_invoke_message_receiver" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_log_invoke_message_receiver" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    if (items > 7) {
      
    }
    {
      result = (svn_error_t *)svn_log_invoke_message_receiver(arg1,arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_invoke_callback2) {
  {
    svn_commit_callback2_t arg1 = (svn_commit_callback2_t) 0 ;
    svn_commit_info_t *arg2 = (svn_commit_info_t *) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_commit_invoke_callback2(_obj,commit_info,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_commit_invoke_callback2" "', argument " "1"" of type '" "svn_commit_callback2_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_commit_info_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_commit_invoke_callback2" "', argument " "2"" of type '" "svn_commit_info_t const *""'"); 
    }
    arg2 = (svn_commit_info_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_commit_invoke_callback2" "', argument " "3"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_commit_invoke_callback2(arg1,(struct svn_commit_info_t const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_commit_invoke_callback) {
  {
    svn_commit_callback_t arg1 = (svn_commit_callback_t) 0 ;
    svn_revnum_t arg2 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    void *arg5 = (void *) 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
      SWIG_croak("Usage: svn_commit_invoke_callback(_obj,new_revision,date,author,baton);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_commit_invoke_callback" "', argument " "1"" of type '" "svn_commit_callback_t""'"); 
      }
    }
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_commit_invoke_callback" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_commit_invoke_callback" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_commit_invoke_callback" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_ConvertPtr(ST(4),SWIG_as_voidptrptr(&arg5), 0, 0);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_commit_invoke_callback" "', argument " "5"" of type '" "void *""'"); 
    }
    {
      result = (svn_error_t *)svn_commit_invoke_callback(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_cancel_invoke_func) {
  {
    svn_cancel_func_t arg1 = (svn_cancel_func_t) 0 ;
    void *arg2 = (void *) 0 ;
    int res2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_cancel_invoke_func(_obj,cancel_baton);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_cancel_invoke_func" "', argument " "1"" of type '" "svn_cancel_func_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_cancel_invoke_func" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      result = (svn_error_t *)svn_cancel_invoke_func(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_location_invoke_segment_receiver) {
  {
    svn_location_segment_receiver_t arg1 = (svn_location_segment_receiver_t) 0 ;
    svn_location_segment_t *arg2 = (svn_location_segment_t *) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_location_invoke_segment_receiver(_obj,segment,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_location_invoke_segment_receiver" "', argument " "1"" of type '" "svn_location_segment_receiver_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_location_segment_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_location_invoke_segment_receiver" "', argument " "2"" of type '" "svn_location_segment_t *""'"); 
    }
    arg2 = (svn_location_segment_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_location_invoke_segment_receiver" "', argument " "3"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_location_invoke_segment_receiver(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_pool_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_allocator_t *arg2 = (apr_allocator_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    apr_pool_t *result = 0 ;
    dXSARGS;
    
    {
      arg2 = NULL;
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_pool_create(parent_pool,allocator);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_pool_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_pool_create" "', argument " "1"" of type '" "apr_pool_t *""'"); 
    }
    arg1 = (apr_pool_t *)(argp1);
    if (items > 1) {
      res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_allocator_t, 0 |  0 );
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_pool_create" "', argument " "2"" of type '" "apr_allocator_t *""'"); 
      }
      arg2 = (apr_allocator_t *)(argp2);
    }
    {
      result = (apr_pool_t *)svn_pool_create_ex(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_pool_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_major_set) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_t_major_set(self,major);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_major_set" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_version_t_major_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    if (arg1) (arg1)->major = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_major_get) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_t_major_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_major_get" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    result = (int) ((arg1)->major);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_minor_set) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_t_minor_set(self,minor);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_minor_set" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_version_t_minor_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    if (arg1) (arg1)->minor = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_minor_get) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_t_minor_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_minor_get" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    result = (int) ((arg1)->minor);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_patch_set) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_t_patch_set(self,patch);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_patch_set" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_version_t_patch_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    if (arg1) (arg1)->patch = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_patch_get) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_t_patch_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_patch_get" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    result = (int) ((arg1)->patch);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_tag_set) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_t_tag_set(self,tag);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_tag_set" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_version_t_tag_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->tag) free((char *)arg1->tag);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->tag = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_t_tag_get) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_t_tag_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_t_tag_get" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    result = (char *) ((arg1)->tag);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_version_t) {
  {
    int argvi = 0;
    struct svn_version_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_version_t();");
    }
    {
      result = (struct svn_version_t *)calloc(1, sizeof(struct svn_version_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_t, SWIG_OWNER | 0); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_version_t) {
  {
    struct svn_version_t *arg1 = (struct svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_version_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_version_t" "', argument " "1"" of type '" "struct svn_version_t *""'"); 
    }
    arg1 = (struct svn_version_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_ver_compatible) {
  {
    svn_version_t *arg1 = (svn_version_t *) 0 ;
    svn_version_t *arg2 = (svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_ver_compatible(my_version,lib_version);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_ver_compatible" "', argument " "1"" of type '" "svn_version_t const *""'"); 
    }
    arg1 = (svn_version_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_ver_compatible" "', argument " "2"" of type '" "svn_version_t const *""'"); 
    }
    arg2 = (svn_version_t *)(argp2);
    {
      result = (svn_boolean_t)svn_ver_compatible((struct svn_version_t const *)arg1,(struct svn_version_t const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_ver_equal) {
  {
    svn_version_t *arg1 = (svn_version_t *) 0 ;
    svn_version_t *arg2 = (svn_version_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_ver_equal(my_version,lib_version);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_ver_equal" "', argument " "1"" of type '" "svn_version_t const *""'"); 
    }
    arg1 = (svn_version_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_ver_equal" "', argument " "2"" of type '" "svn_version_t const *""'"); 
    }
    arg2 = (svn_version_t *)(argp2);
    {
      result = (svn_boolean_t)svn_ver_equal((struct svn_version_t const *)arg1,(struct svn_version_t const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_checklist_t_label_set) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_checklist_t_label_set(self,label);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_checklist_t_label_set" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_version_checklist_t_label_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->label) free((char *)arg1->label);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->label = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_checklist_t_label_get) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_checklist_t_label_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_checklist_t_label_get" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    result = (char *) ((arg1)->label);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_checklist_t_version_query_set) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    svn_version_t *(*arg2)(void) = (svn_version_t *(*)(void)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_version_checklist_t_version_query_set(self,version_query);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_checklist_t_version_query_set" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_void__p_svn_version_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_version_checklist_t_version_query_set" "', argument " "2"" of type '" "svn_version_t const *(*)(void)""'"); 
      }
    }
    if (arg1) (arg1)->version_query = (svn_version_t const *(*)(void))arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_checklist_t_version_query_get) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_version_t *(*result)(void) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_checklist_t_version_query_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_checklist_t_version_query_get" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    result = (svn_version_t *(*)(void)) ((arg1)->version_query);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_void__p_svn_version_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_version_checklist_t) {
  {
    int argvi = 0;
    svn_version_checklist_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_version_checklist_t();");
    }
    {
      result = (svn_version_checklist_t *)calloc(1, sizeof(svn_version_checklist_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_checklist_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_version_checklist_t) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_version_checklist_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_version_checklist_t" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_ver_check_list) {
  {
    svn_version_t *arg1 = (svn_version_t *) 0 ;
    svn_version_checklist_t *arg2 = (svn_version_checklist_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_ver_check_list(my_version,checklist);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_ver_check_list" "', argument " "1"" of type '" "svn_version_t const *""'"); 
    }
    arg1 = (svn_version_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_ver_check_list" "', argument " "2"" of type '" "svn_version_checklist_t const *""'"); 
    }
    arg2 = (svn_version_checklist_t *)(argp2);
    {
      result = (svn_error_t *)svn_ver_check_list((struct svn_version_t const *)arg1,(struct svn_version_checklist_t const *)arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_subr_version) {
  {
    int argvi = 0;
    svn_version_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: svn_subr_version();");
    }
    {
      result = (svn_version_t *)svn_subr_version();
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_t, 0 | 0); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_checklist_invoke_version_query) {
  {
    svn_version_checklist_t *arg1 = (svn_version_checklist_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_version_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_checklist_invoke_version_query(_obj);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_version_checklist_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_version_checklist_invoke_version_query" "', argument " "1"" of type '" "svn_version_checklist_t *""'"); 
    }
    arg1 = (svn_version_checklist_t *)(argp1);
    {
      result = (svn_version_t *)svn_version_checklist_invoke_version_query(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_version_invoke_func) {
  {
    svn_version_func_t arg1 = (svn_version_func_t) 0 ;
    int argvi = 0;
    svn_version_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_version_invoke_func(_obj);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_void__p_svn_version_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_version_invoke_func" "', argument " "1"" of type '" "svn_version_func_t""'"); 
      }
    }
    {
      result = (svn_version_t *)svn_version_invoke_func((struct svn_version_t const *(*)(void))arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_dup) {
  {
    svn_prop_t *arg1 = (svn_prop_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_prop_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_dup(prop,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_dup" "', argument " "1"" of type '" "svn_prop_t const *""'"); 
    }
    arg1 = (svn_prop_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_prop_t *)svn_prop_dup((struct svn_prop_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_prop_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_array_dup) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_array_header_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_array_dup(array,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_array_dup" "', argument " "1"" of type '" "apr_array_header_t const *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (apr_array_header_t *)svn_prop_array_dup((apr_array_header_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_array_header_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_hash_to_array) {
  {
    apr_hash_t *arg1 = (apr_hash_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_array_header_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_hash_to_array(hash,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_hash_to_array" "', argument " "1"" of type '" "apr_hash_t *""'"); 
    }
    arg1 = (apr_hash_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (apr_array_header_t *)svn_prop_hash_to_array(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_array_header_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_array_to_hash) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_array_to_hash(properties,result);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_array_to_hash" "', argument " "1"" of type '" "apr_array_header_t const *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_pool_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_prop_array_to_hash" "', argument " "2"" of type '" "apr_pool_t *""'"); 
    }
    arg2 = (apr_pool_t *)(argp2);
    {
      result = (apr_hash_t *)svn_prop_array_to_hash((apr_array_header_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_hash_dup) {
  {
    apr_hash_t *arg1 = (apr_hash_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_hash_dup(hash,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_hash_dup" "', argument " "1"" of type '" "apr_hash_t *""'"); 
    }
    arg1 = (apr_hash_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (apr_hash_t *)svn_prop_hash_dup(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_get_value) {
  {
    apr_hash_t *arg1 = (apr_hash_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_get_value(properties,prop_name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_get_value" "', argument " "1"" of type '" "apr_hash_t *""'"); 
    }
    arg1 = (apr_hash_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_prop_get_value" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (char *)svn_prop_get_value(arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_property_kind) {
  {
    int *arg1 = (int *) 0 ;
    char *arg2 = (char *) 0 ;
    int temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_prop_kind_t result;
    dXSARGS;
    
    arg1 = &temp1;
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_property_kind(prop_name);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_property_kind" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_prop_kind_t)svn_property_kind(arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_is_svn_prop) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_is_svn_prop(prop_name);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_is_svn_prop" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_prop_is_svn_prop((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_has_svn_prop) {
  {
    apr_hash_t *arg1 = (apr_hash_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_has_svn_prop(props,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_has_svn_prop" "', argument " "1"" of type '" "apr_hash_t const *""'"); 
    }
    arg1 = (apr_hash_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_boolean_t)svn_prop_has_svn_prop((apr_hash_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_is_boolean) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_is_boolean(prop_name);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_is_boolean" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_prop_is_boolean((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_needs_translation) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_needs_translation(prop_name);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_needs_translation" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_prop_needs_translation((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_categorize_props) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    apr_array_header_t **arg2 = (apr_array_header_t **) 0 ;
    apr_array_header_t **arg3 = (apr_array_header_t **) 0 ;
    apr_array_header_t **arg4 = (apr_array_header_t **) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    apr_array_header_t *temp2 ;
    apr_array_header_t *temp3 ;
    apr_array_header_t *temp4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    arg4 = &temp4;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_categorize_props(proplist,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_categorize_props" "', argument " "1"" of type '" "apr_array_header_t const *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_categorize_props((apr_array_header_t const *)arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_categorize_props arg 2 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_categorize_props is not implemented yet");
      
    }
    {
      /* FIXME: Missing argout typemap: svn_categorize_props arg 3 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_categorize_props is not implemented yet");
      
    }
    {
      /* FIXME: Missing argout typemap: svn_categorize_props arg 4 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_categorize_props is not implemented yet");
      
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_diffs) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_hash_t *arg2 = (apr_hash_t *) 0 ;
    apr_hash_t *arg3 = (apr_hash_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_prop_diffs(target_props,source_props,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_prop_diffs" "', argument " "2"" of type '" "apr_hash_t *""'"); 
    }
    arg2 = (apr_hash_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_prop_diffs" "', argument " "3"" of type '" "apr_hash_t *""'"); 
    }
    arg3 = (apr_hash_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_prop_diffs(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_prop_diffs arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_prop_diffs is not implemented yet");
      
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_name_is_valid) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_name_is_valid(prop_name);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_name_is_valid" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_prop_name_is_valid((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_name_set) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_name_set(self,name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_name_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc2_t_name_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->name) free((char *)arg1->name);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->name = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_name_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_name_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_name_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (char *) ((arg1)->name);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_cmd_func_set) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    svn_opt_subcommand_t *arg2 = (svn_opt_subcommand_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_cmd_func_set(self,cmd_func);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_cmd_func_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_opt_subcommand_desc2_t_cmd_func_set" "', argument " "2"" of type '" "svn_opt_subcommand_t *""'"); 
      }
    }
    if (arg1) (arg1)->cmd_func = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_cmd_func_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_opt_subcommand_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_cmd_func_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_cmd_func_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (svn_opt_subcommand_t *) ((arg1)->cmd_func);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_aliases_set) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    char **arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_aliases_set(self,aliases);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_aliases_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_p_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc2_t_aliases_set" "', argument " "2"" of type '" "char const *[3]""'"); 
    } 
    arg2 = (char **)(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)3; ++ii) arg1->aliases[ii] = arg2[ii];
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""aliases""' of type '""char const *[3]""'");
      }
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_aliases_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char **result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_aliases_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_aliases_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (char **)(char **) ((arg1)->aliases);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_char, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_help_set) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_help_set(self,help);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_help_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc2_t_help_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->help) free((char *)arg1->help);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->help = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_help_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_help_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_help_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (char *) ((arg1)->help);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_valid_options_set) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    int *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_valid_options_set(self,valid_options);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_valid_options_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc2_t_valid_options_set" "', argument " "2"" of type '" "int [50]""'"); 
    } 
    arg2 = (int *)(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)50; ++ii) arg1->valid_options[ii] = arg2[ii];
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""valid_options""' of type '""int [50]""'");
      }
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_valid_options_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_valid_options_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_valid_options_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (int *)(int *) ((arg1)->valid_options);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_desc_overrides_get) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_opt_subcommand_desc2_t_desc_overrides *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_desc_overrides_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    result = (svn_opt_subcommand_desc2_t_desc_overrides *)(svn_opt_subcommand_desc2_t_desc_overrides *) ((arg1)->desc_overrides);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_subcommand_desc2_t) {
  {
    int argvi = 0;
    svn_opt_subcommand_desc2_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_subcommand_desc2_t();");
    }
    {
      result = (svn_opt_subcommand_desc2_t *)calloc(1, sizeof(svn_opt_subcommand_desc2_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc2_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_subcommand_desc2_t) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_subcommand_desc2_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_opt_subcommand_desc2_t" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_desc_overrides_optch_set) {
  {
    svn_opt_subcommand_desc2_t_desc_overrides *arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_desc_overrides_optch_set(self,optch);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_optch_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t_desc_overrides *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_optch_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    if (arg1) (arg1)->optch = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_desc_overrides_optch_get) {
  {
    svn_opt_subcommand_desc2_t_desc_overrides *arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_desc_overrides_optch_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_optch_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t_desc_overrides *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *)(argp1);
    result = (int) ((arg1)->optch);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_desc_overrides_desc_set) {
  {
    svn_opt_subcommand_desc2_t_desc_overrides *arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_desc_overrides_desc_set(self,desc);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_desc_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t_desc_overrides *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_desc_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->desc) free((char *)arg1->desc);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->desc = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc2_t_desc_overrides_desc_get) {
  {
    svn_opt_subcommand_desc2_t_desc_overrides *arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc2_t_desc_overrides_desc_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc2_t_desc_overrides_desc_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t_desc_overrides *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *)(argp1);
    result = (char *) ((arg1)->desc);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_subcommand_desc2_t_desc_overrides) {
  {
    int argvi = 0;
    svn_opt_subcommand_desc2_t_desc_overrides *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_subcommand_desc2_t_desc_overrides();");
    }
    {
      result = (svn_opt_subcommand_desc2_t_desc_overrides *)calloc(1, sizeof(svn_opt_subcommand_desc2_t_desc_overrides));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_subcommand_desc2_t_desc_overrides) {
  {
    svn_opt_subcommand_desc2_t_desc_overrides *arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_subcommand_desc2_t_desc_overrides(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t_desc_overrides, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_opt_subcommand_desc2_t_desc_overrides" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t_desc_overrides *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t_desc_overrides *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_name_set) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_name_set(self,name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_name_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc_t_name_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->name) free((char *)arg1->name);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->name = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_name_get) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_name_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_name_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    result = (char *) ((arg1)->name);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_cmd_func_set) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    svn_opt_subcommand_t *arg2 = (svn_opt_subcommand_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_cmd_func_set(self,cmd_func);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_cmd_func_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_opt_subcommand_desc_t_cmd_func_set" "', argument " "2"" of type '" "svn_opt_subcommand_t *""'"); 
      }
    }
    if (arg1) (arg1)->cmd_func = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_cmd_func_get) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_opt_subcommand_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_cmd_func_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_cmd_func_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    result = (svn_opt_subcommand_t *) ((arg1)->cmd_func);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_aliases_set) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    char **arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_aliases_set(self,aliases);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_aliases_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_p_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc_t_aliases_set" "', argument " "2"" of type '" "char const *[3]""'"); 
    } 
    arg2 = (char **)(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)3; ++ii) arg1->aliases[ii] = arg2[ii];
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""aliases""' of type '""char const *[3]""'");
      }
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_aliases_get) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char **result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_aliases_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_aliases_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    result = (char **)(char **) ((arg1)->aliases);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_char, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_help_set) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_help_set(self,help);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_help_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc_t_help_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->help) free((char *)arg1->help);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->help = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_help_get) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_help_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_help_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    result = (char *) ((arg1)->help);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_valid_options_set) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    int *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_valid_options_set(self,valid_options);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_valid_options_set" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_desc_t_valid_options_set" "', argument " "2"" of type '" "int [50]""'"); 
    } 
    arg2 = (int *)(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)50; ++ii) arg1->valid_options[ii] = arg2[ii];
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""valid_options""' of type '""int [50]""'");
      }
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_desc_t_valid_options_get) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    int *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_subcommand_desc_t_valid_options_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_desc_t_valid_options_get" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    result = (int *)(int *) ((arg1)->valid_options);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_subcommand_desc_t) {
  {
    int argvi = 0;
    svn_opt_subcommand_desc_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_subcommand_desc_t();");
    }
    {
      result = (svn_opt_subcommand_desc_t *)calloc(1, sizeof(svn_opt_subcommand_desc_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_subcommand_desc_t) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_subcommand_desc_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_opt_subcommand_desc_t" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_get_canonical_subcommand2) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_opt_subcommand_desc2_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_get_canonical_subcommand2(table,cmd_name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_get_canonical_subcommand2" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_get_canonical_subcommand2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_opt_subcommand_desc2_t *)svn_opt_get_canonical_subcommand2((struct svn_opt_subcommand_desc2_t const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 | SWIG_SHADOW); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_get_canonical_subcommand) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_opt_subcommand_desc_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_get_canonical_subcommand(table,cmd_name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_get_canonical_subcommand" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t const *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_get_canonical_subcommand" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_opt_subcommand_desc_t *)svn_opt_get_canonical_subcommand((struct svn_opt_subcommand_desc_t const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 | SWIG_SHADOW); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_get_option_from_code2) {
  {
    int arg1 ;
    apr_getopt_option_t *arg2 = (apr_getopt_option_t *) 0 ;
    svn_opt_subcommand_desc2_t *arg3 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int val1 ;
    int ecode1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    apr_getopt_option_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_opt_get_option_from_code2(code,option_table,command,pool);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_opt_get_option_from_code2" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_get_option_from_code2" "', argument " "2"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg2 = (apr_getopt_option_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_get_option_from_code2" "', argument " "3"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg3 = (svn_opt_subcommand_desc2_t *)(argp3);
    if (items > 3) {
      
    }
    {
      result = (apr_getopt_option_t *)svn_opt_get_option_from_code2(arg1,(apr_getopt_option_t const *)arg2,(struct svn_opt_subcommand_desc2_t const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_getopt_option_t, 0 | 0); argvi++ ;
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_get_option_from_code) {
  {
    int arg1 ;
    apr_getopt_option_t *arg2 = (apr_getopt_option_t *) 0 ;
    int val1 ;
    int ecode1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    apr_getopt_option_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_get_option_from_code(code,option_table);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_opt_get_option_from_code" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_get_option_from_code" "', argument " "2"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg2 = (apr_getopt_option_t *)(argp2);
    {
      result = (apr_getopt_option_t *)svn_opt_get_option_from_code(arg1,(apr_getopt_option_t const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_getopt_option_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_takes_option3) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    int arg2 ;
    int *arg3 = (int *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int temp3 ;
    int res3 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    arg3 = &temp3;
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_takes_option3(command,option_code);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_takes_option3" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_subcommand_takes_option3" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    {
      result = (svn_boolean_t)svn_opt_subcommand_takes_option3((struct svn_opt_subcommand_desc2_t const *)arg1,arg2,(int const *)arg3);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (SWIG_IsTmpObj(res3)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg3)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_takes_option2) {
  {
    svn_opt_subcommand_desc2_t *arg1 = (svn_opt_subcommand_desc2_t *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_takes_option2(command,option_code);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_takes_option2" "', argument " "1"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_subcommand_takes_option2" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    {
      result = (svn_boolean_t)svn_opt_subcommand_takes_option2((struct svn_opt_subcommand_desc2_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_takes_option) {
  {
    svn_opt_subcommand_desc_t *arg1 = (svn_opt_subcommand_desc_t *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_subcommand_takes_option(command,option_code);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_takes_option" "', argument " "1"" of type '" "svn_opt_subcommand_desc_t const *""'"); 
    }
    arg1 = (svn_opt_subcommand_desc_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_subcommand_takes_option" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
    {
      result = (svn_boolean_t)svn_opt_subcommand_takes_option((struct svn_opt_subcommand_desc_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_print_generic_help2) {
  {
    char *arg1 = (char *) 0 ;
    svn_opt_subcommand_desc2_t *arg2 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_getopt_option_t *arg3 = (apr_getopt_option_t *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    FILE *arg6 = (FILE *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 6)) {
      SWIG_croak("Usage: svn_opt_print_generic_help2(header,cmd_table,opt_table,footer,pool,stream);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_print_generic_help2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_print_generic_help2" "', argument " "2"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg2 = (svn_opt_subcommand_desc2_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_print_generic_help2" "', argument " "3"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg3 = (apr_getopt_option_t *)(argp3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_opt_print_generic_help2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 4) {
      
    }
    if (items > 5) {
      {
        arg6 = PerlIO_exportFILE (IoIFP (sv_2io (ST(5))), NULL);
      }
    }
    {
      svn_opt_print_generic_help2((char const *)arg1,(struct svn_opt_subcommand_desc2_t const *)arg2,(apr_getopt_option_t const *)arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_format_option) {
  {
    char **arg1 = (char **) 0 ;
    apr_getopt_option_t *arg2 = (apr_getopt_option_t *) 0 ;
    svn_boolean_t arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_format_option(opt,doc,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_format_option" "', argument " "2"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg2 = (apr_getopt_option_t *)(argp2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_format_option" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    if (items > 2) {
      
    }
    {
      svn_opt_format_option((char const **)arg1,(apr_getopt_option_t const *)arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_help3) {
  {
    char *arg1 = (char *) 0 ;
    svn_opt_subcommand_desc2_t *arg2 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_getopt_option_t *arg3 = (apr_getopt_option_t *) 0 ;
    int *arg4 = (int *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int temp4 ;
    int res4 = SWIG_TMPOBJ ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg4 = &temp4;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_opt_subcommand_help3(subcommand,table,options_table,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_help3" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_help3" "', argument " "2"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg2 = (svn_opt_subcommand_desc2_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_subcommand_help3" "', argument " "3"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg3 = (apr_getopt_option_t *)(argp3);
    if (items > 3) {
      
    }
    {
      svn_opt_subcommand_help3((char const *)arg1,(struct svn_opt_subcommand_desc2_t const *)arg2,(apr_getopt_option_t const *)arg3,(int const *)arg4,arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_help2) {
  {
    char *arg1 = (char *) 0 ;
    svn_opt_subcommand_desc2_t *arg2 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_getopt_option_t *arg3 = (apr_getopt_option_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_opt_subcommand_help2(subcommand,table,options_table,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_help2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_help2" "', argument " "2"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg2 = (svn_opt_subcommand_desc2_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_subcommand_help2" "', argument " "3"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg3 = (apr_getopt_option_t *)(argp3);
    if (items > 3) {
      
    }
    {
      svn_opt_subcommand_help2((char const *)arg1,(struct svn_opt_subcommand_desc2_t const *)arg2,(apr_getopt_option_t const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_subcommand_help) {
  {
    char *arg1 = (char *) 0 ;
    svn_opt_subcommand_desc_t *arg2 = (svn_opt_subcommand_desc_t *) 0 ;
    apr_getopt_option_t *arg3 = (apr_getopt_option_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_opt_subcommand_help(subcommand,table,options_table,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_subcommand_help" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_subcommand_help" "', argument " "2"" of type '" "svn_opt_subcommand_desc_t const *""'"); 
    }
    arg2 = (svn_opt_subcommand_desc_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_subcommand_help" "', argument " "3"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg3 = (apr_getopt_option_t *)(argp3);
    if (items > 3) {
      
    }
    {
      svn_opt_subcommand_help((char const *)arg1,(struct svn_opt_subcommand_desc_t const *)arg2,(apr_getopt_option_t const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_value_t_number_set) {
  {
    svn_opt_revision_value_t *arg1 = (svn_opt_revision_value_t *) 0 ;
    svn_revnum_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_value_t_number_set(self,number);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_value_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_value_t_number_set" "', argument " "1"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg1 = (svn_opt_revision_value_t *)(argp1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_revision_value_t_number_set" "', argument " "2"" of type '" "svn_revnum_t""'");
    } 
    arg2 = (svn_revnum_t)(val2);
    if (arg1) (arg1)->number = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_value_t_number_get) {
  {
    svn_opt_revision_value_t *arg1 = (svn_opt_revision_value_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_revnum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_value_t_number_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_value_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_value_t_number_get" "', argument " "1"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg1 = (svn_opt_revision_value_t *)(argp1);
    result = (svn_revnum_t) ((arg1)->number);
    ST(argvi) = SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_value_t_date_set) {
  {
    svn_opt_revision_value_t *arg1 = (svn_opt_revision_value_t *) 0 ;
    apr_time_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_value_t_date_set(self,date);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_value_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_value_t_date_set" "', argument " "1"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg1 = (svn_opt_revision_value_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_revision_value_t_date_set" "', argument " "2"" of type '" "apr_time_t""'");
    } 
    arg2 = (apr_time_t)(val2);
    if (arg1) (arg1)->date = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_value_t_date_get) {
  {
    svn_opt_revision_value_t *arg1 = (svn_opt_revision_value_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_time_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_value_t_date_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_value_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_value_t_date_get" "', argument " "1"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg1 = (svn_opt_revision_value_t *)(argp1);
    result =  ((arg1)->date);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_revision_value_t) {
  {
    int argvi = 0;
    svn_opt_revision_value_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_revision_value_t();");
    }
    {
      result = (svn_opt_revision_value_t *)calloc(1, sizeof(svn_opt_revision_value_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_value_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_revision_value_t) {
  {
    svn_opt_revision_value_t *arg1 = (svn_opt_revision_value_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_revision_value_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_value_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_opt_revision_value_t" "', argument " "1"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg1 = (svn_opt_revision_value_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_t_kind_set) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    enum svn_opt_revision_kind arg2 ;
    svn_opt_revision_t rev1 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_t_kind_set(self,kind);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_opt_revision_t_kind_set" "', argument " "2"" of type '" "enum svn_opt_revision_kind""'");
    } 
    arg2 = (enum svn_opt_revision_kind)(val2);
    if (arg1) (arg1)->kind = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_t_kind_get) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_t rev1 ;
    int argvi = 0;
    enum svn_opt_revision_kind result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_t_kind_get(self);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    result = (enum svn_opt_revision_kind) ((arg1)->kind);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_t_value_set) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_value_t *arg2 = (svn_opt_revision_value_t *) 0 ;
    svn_opt_revision_t rev1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_t_value_set(self,value);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_opt_revision_value_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_revision_t_value_set" "', argument " "2"" of type '" "svn_opt_revision_value_t *""'"); 
    }
    arg2 = (svn_opt_revision_value_t *)(argp2);
    if (arg1) (arg1)->value = *arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_t_value_get) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_t rev1 ;
    int argvi = 0;
    svn_opt_revision_value_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_t_value_get(self);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    result = (svn_opt_revision_value_t *)& ((arg1)->value);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_value_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_revision_t) {
  {
    int argvi = 0;
    svn_opt_revision_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_revision_t();");
    }
    {
      result = (svn_opt_revision_t *)calloc(1, sizeof(svn_opt_revision_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_revision_t) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_t rev1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_revision_t(self);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_range_t_start_set) {
  {
    svn_opt_revision_range_t *arg1 = (svn_opt_revision_range_t *) 0 ;
    svn_opt_revision_t *arg2 = (svn_opt_revision_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_opt_revision_t rev2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_range_t_start_set(self,start);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_range_t_start_set" "', argument " "1"" of type '" "svn_opt_revision_range_t *""'"); 
    }
    arg1 = (svn_opt_revision_range_t *)(argp1);
    {
      arg2 = &rev2;
      if (ST(1) == NULL || ST(1) == &PL_sv_undef || !SvOK(ST(1))) {
        rev2.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(1)) && sv_derived_from(ST(1), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(1), (void **)&arg2, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(1))) {
        rev2.kind = svn_opt_revision_number;
        rev2.value.number = SvIV(ST(1));
      }
      else if (SvPOK(ST(1))) {
        char *input = SvPV_nolen(ST(1));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev2.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev2.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev2.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev2.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev2.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev2.kind = svn_opt_revision_date;
          rev2.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    if (arg1) (arg1)->start = *arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_range_t_start_get) {
  {
    svn_opt_revision_range_t *arg1 = (svn_opt_revision_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_opt_revision_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_range_t_start_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_range_t_start_get" "', argument " "1"" of type '" "svn_opt_revision_range_t *""'"); 
    }
    arg1 = (svn_opt_revision_range_t *)(argp1);
    result = (svn_opt_revision_t *)& ((arg1)->start);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_range_t_end_set) {
  {
    svn_opt_revision_range_t *arg1 = (svn_opt_revision_range_t *) 0 ;
    svn_opt_revision_t *arg2 = (svn_opt_revision_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_opt_revision_t rev2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_revision_range_t_end_set(self,end);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_range_t_end_set" "', argument " "1"" of type '" "svn_opt_revision_range_t *""'"); 
    }
    arg1 = (svn_opt_revision_range_t *)(argp1);
    {
      arg2 = &rev2;
      if (ST(1) == NULL || ST(1) == &PL_sv_undef || !SvOK(ST(1))) {
        rev2.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(1)) && sv_derived_from(ST(1), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(1), (void **)&arg2, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(1))) {
        rev2.kind = svn_opt_revision_number;
        rev2.value.number = SvIV(ST(1));
      }
      else if (SvPOK(ST(1))) {
        char *input = SvPV_nolen(ST(1));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev2.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev2.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev2.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev2.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev2.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev2.kind = svn_opt_revision_date;
          rev2.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    if (arg1) (arg1)->end = *arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_revision_range_t_end_get) {
  {
    svn_opt_revision_range_t *arg1 = (svn_opt_revision_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_opt_revision_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_opt_revision_range_t_end_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_range_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_revision_range_t_end_get" "', argument " "1"" of type '" "svn_opt_revision_range_t *""'"); 
    }
    arg1 = (svn_opt_revision_range_t *)(argp1);
    result = (svn_opt_revision_t *)& ((arg1)->end);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_opt_revision_range_t) {
  {
    int argvi = 0;
    svn_opt_revision_range_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_opt_revision_range_t();");
    }
    {
      result = (svn_opt_revision_range_t *)calloc(1, sizeof(svn_opt_revision_range_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_opt_revision_range_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_opt_revision_range_t) {
  {
    svn_opt_revision_range_t *arg1 = (svn_opt_revision_range_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_opt_revision_range_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_opt_revision_range_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_opt_revision_range_t" "', argument " "1"" of type '" "svn_opt_revision_range_t *""'"); 
    }
    arg1 = (svn_opt_revision_range_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_revision) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_t *arg2 = (svn_opt_revision_t *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_opt_revision_t rev1 ;
    svn_opt_revision_t rev2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_opt_parse_revision(start_revision,end_revision,arg,pool);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    {
      arg2 = &rev2;
      if (ST(1) == NULL || ST(1) == &PL_sv_undef || !SvOK(ST(1))) {
        rev2.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(1)) && sv_derived_from(ST(1), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(1), (void **)&arg2, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(1))) {
        rev2.kind = svn_opt_revision_number;
        rev2.value.number = SvIV(ST(1));
      }
      else if (SvPOK(ST(1))) {
        char *input = SvPV_nolen(ST(1));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev2.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev2.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev2.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev2.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev2.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev2.kind = svn_opt_revision_date;
          rev2.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_parse_revision" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 3) {
      
    }
    {
      result = (int)svn_opt_parse_revision(arg1,arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_revision_to_range) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_parse_revision_to_range(opt_ranges,arg,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_parse_revision_to_range" "', argument " "1"" of type '" "apr_array_header_t *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_parse_revision_to_range" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (int)svn_opt_parse_revision_to_range(arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_resolve_revisions) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    svn_opt_revision_t *arg2 = (svn_opt_revision_t *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_opt_revision_t rev1 ;
    svn_opt_revision_t rev2 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_opt_resolve_revisions(peg_rev,op_rev,is_url,notice_local_mods,pool);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    {
      arg2 = &rev2;
      if (ST(1) == NULL || ST(1) == &PL_sv_undef || !SvOK(ST(1))) {
        rev2.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(1)) && sv_derived_from(ST(1), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(1), (void **)&arg2, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(1))) {
        rev2.kind = svn_opt_revision_number;
        rev2.value.number = SvIV(ST(1));
      }
      else if (SvPOK(ST(1))) {
        char *input = SvPV_nolen(ST(1));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev2.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev2.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev2.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev2.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev2.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev2.kind = svn_opt_revision_date;
          rev2.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_resolve_revisions" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_opt_resolve_revisions" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_opt_resolve_revisions(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_args_to_target_array3) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_getopt_t *arg2 = (apr_getopt_t *) 0 ;
    apr_array_header_t *arg3 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_args_to_target_array3(os,known_targets,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_args_to_target_array3" "', argument " "2"" of type '" "apr_getopt_t *""'"); 
    }
    arg2 = (apr_getopt_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_args_to_target_array3" "', argument " "3"" of type '" "apr_array_header_t const *""'"); 
    }
    arg3 = (apr_array_header_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_opt_args_to_target_array3(arg1,arg2,(apr_array_header_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_array_to_list(*arg1); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_args_to_target_array2) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_getopt_t *arg2 = (apr_getopt_t *) 0 ;
    apr_array_header_t *arg3 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_args_to_target_array2(os,known_targets,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_args_to_target_array2" "', argument " "2"" of type '" "apr_getopt_t *""'"); 
    }
    arg2 = (apr_getopt_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_args_to_target_array2" "', argument " "3"" of type '" "apr_array_header_t const *""'"); 
    }
    arg3 = (apr_array_header_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_opt_args_to_target_array2(arg1,arg2,(apr_array_header_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_array_to_list(*arg1); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_revprop) {
  {
    apr_hash_t **arg1 = (apr_hash_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_hash_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_parse_revprop(revprop_spec,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_parse_revprop" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_opt_parse_revprop(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_prophash_to_hash(*arg1); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_push_implicit_dot_target) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_push_implicit_dot_target(targets,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_push_implicit_dot_target" "', argument " "1"" of type '" "apr_array_header_t *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    if (items > 1) {
      
    }
    {
      svn_opt_push_implicit_dot_target(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_num_args) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_getopt_t *arg2 = (apr_getopt_t *) 0 ;
    int arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_parse_num_args(os,num_args,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_parse_num_args" "', argument " "2"" of type '" "apr_getopt_t *""'"); 
    }
    arg2 = (apr_getopt_t *)(argp2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_parse_num_args" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_opt_parse_num_args(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_array_to_list(*arg1); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_all_args) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_getopt_t *arg2 = (apr_getopt_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_opt_parse_all_args(os,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_parse_all_args" "', argument " "2"" of type '" "apr_getopt_t *""'"); 
    }
    arg2 = (apr_getopt_t *)(argp2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_opt_parse_all_args(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_array_to_list(*arg1); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_parse_path) {
  {
    svn_opt_revision_t *arg1 = (svn_opt_revision_t *) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_opt_revision_t rev1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_opt_parse_path(rev,path,pool);");
    }
    {
      arg1 = &rev1;
      if (ST(0) == NULL || ST(0) == &PL_sv_undef || !SvOK(ST(0))) {
        rev1.kind = svn_opt_revision_unspecified;
      }
      else if (sv_isobject(ST(0)) && sv_derived_from(ST(0), "_p_svn_opt_revision_t")) {
        SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_svn_opt_revision_t, 0);
      }
      else if (looks_like_number(ST(0))) {
        rev1.kind = svn_opt_revision_number;
        rev1.value.number = SvIV(ST(0));
      }
      else if (SvPOK(ST(0))) {
        char *input = SvPV_nolen(ST(0));
        if (svn_cstring_casecmp(input, "BASE") == 0)
        rev1.kind = svn_opt_revision_base;
        else if (svn_cstring_casecmp(input, "HEAD") == 0)
        rev1.kind = svn_opt_revision_head;
        else if (svn_cstring_casecmp(input, "WORKING") == 0)
        rev1.kind = svn_opt_revision_working;
        else if (svn_cstring_casecmp(input, "COMMITTED") == 0)
        rev1.kind = svn_opt_revision_committed;
        else if (svn_cstring_casecmp(input, "PREV") == 0)
        rev1.kind = svn_opt_revision_previous;
        else if (*input == '{') {
          svn_boolean_t matched;
          apr_time_t tm;
          svn_error_t *err;
          
          char *end = strchr(input,'}');
          if (!end)
          SWIG_croak("unknown opt_revision_t type");
          *end = '\0';
          err = svn_parse_date (&matched, &tm, input + 1, apr_time_now(),
            svn_swig_pl_make_pool ((SV *)NULL));
          if (err) {
            svn_error_clear (err);
            SWIG_croak("unknown opt_revision_t type");
          }
          if (!matched)
          SWIG_croak("unknown opt_revision_t type");
          
          rev1.kind = svn_opt_revision_date;
          rev1.value.date = tm;
        } else
        SWIG_croak("unknown opt_revision_t type");
      } else
      SWIG_croak("unknown opt_revision_t type");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_opt_parse_path" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_opt_parse_path(arg1,(char const **)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_print_help3) {
  {
    apr_getopt_t *arg1 = (apr_getopt_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    svn_opt_subcommand_desc2_t *arg7 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_getopt_option_t *arg8 = (apr_getopt_option_t *) 0 ;
    int *arg9 = (int *) 0 ;
    char *arg10 = (char *) 0 ;
    apr_pool_t *arg11 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    void *argp7 = 0 ;
    int res7 = 0 ;
    void *argp8 = 0 ;
    int res8 = 0 ;
    int temp9 ;
    int res9 = SWIG_TMPOBJ ;
    int res10 ;
    char *buf10 = 0 ;
    int alloc10 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg11 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg9 = &temp9;
    if ((items < 9) || (items > 10)) {
      SWIG_croak("Usage: svn_opt_print_help3(os,pgm_name,print_version,quiet,version_footer,header,cmd_table,option_table,footer,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_print_help3" "', argument " "1"" of type '" "apr_getopt_t *""'"); 
    }
    arg1 = (apr_getopt_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_print_help3" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_print_help3" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_opt_print_help3" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_opt_print_help3" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_opt_print_help3" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_ConvertPtr(ST(6), &argp7,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_opt_print_help3" "', argument " "7"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg7 = (svn_opt_subcommand_desc2_t *)(argp7);
    res8 = SWIG_ConvertPtr(ST(7), &argp8,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_opt_print_help3" "', argument " "8"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg8 = (apr_getopt_option_t *)(argp8);
    res10 = SWIG_AsCharPtrAndSize(ST(8), &buf10, NULL, &alloc10);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "svn_opt_print_help3" "', argument " "10"" of type '" "char const *""'");
    }
    arg10 = (char *)(buf10);
    if (items > 9) {
      
    }
    {
      result = (svn_error_t *)svn_opt_print_help3(arg1,(char const *)arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(struct svn_opt_subcommand_desc2_t const *)arg7,(apr_getopt_option_t const *)arg8,(int const *)arg9,(char const *)arg10,arg11);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res9)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg9)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    
    if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    
    if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_print_help2) {
  {
    apr_getopt_t *arg1 = (apr_getopt_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    svn_opt_subcommand_desc2_t *arg7 = (svn_opt_subcommand_desc2_t *) 0 ;
    apr_getopt_option_t *arg8 = (apr_getopt_option_t *) 0 ;
    char *arg9 = (char *) 0 ;
    apr_pool_t *arg10 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    void *argp7 = 0 ;
    int res7 = 0 ;
    void *argp8 = 0 ;
    int res8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg10 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 9) || (items > 10)) {
      SWIG_croak("Usage: svn_opt_print_help2(os,pgm_name,print_version,quiet,version_footer,header,cmd_table,option_table,footer,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_print_help2" "', argument " "1"" of type '" "apr_getopt_t *""'"); 
    }
    arg1 = (apr_getopt_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_print_help2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_print_help2" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_opt_print_help2" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_opt_print_help2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_opt_print_help2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_ConvertPtr(ST(6), &argp7,SWIGTYPE_p_svn_opt_subcommand_desc2_t, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_opt_print_help2" "', argument " "7"" of type '" "svn_opt_subcommand_desc2_t const *""'"); 
    }
    arg7 = (svn_opt_subcommand_desc2_t *)(argp7);
    res8 = SWIG_ConvertPtr(ST(7), &argp8,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_opt_print_help2" "', argument " "8"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg8 = (apr_getopt_option_t *)(argp8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_opt_print_help2" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    if (items > 9) {
      
    }
    {
      result = (svn_error_t *)svn_opt_print_help2(arg1,(char const *)arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(struct svn_opt_subcommand_desc2_t const *)arg7,(apr_getopt_option_t const *)arg8,(char const *)arg9,arg10);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_opt_print_help) {
  {
    apr_getopt_t *arg1 = (apr_getopt_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    svn_opt_subcommand_desc_t *arg7 = (svn_opt_subcommand_desc_t *) 0 ;
    apr_getopt_option_t *arg8 = (apr_getopt_option_t *) 0 ;
    char *arg9 = (char *) 0 ;
    apr_pool_t *arg10 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    void *argp7 = 0 ;
    int res7 = 0 ;
    void *argp8 = 0 ;
    int res8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg10 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 9) || (items > 10)) {
      SWIG_croak("Usage: svn_opt_print_help(os,pgm_name,print_version,quiet,version_footer,header,cmd_table,option_table,footer,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_getopt_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_opt_print_help" "', argument " "1"" of type '" "apr_getopt_t *""'"); 
    }
    arg1 = (apr_getopt_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_opt_print_help" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_opt_print_help" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_opt_print_help" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_opt_print_help" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_opt_print_help" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_ConvertPtr(ST(6), &argp7,SWIGTYPE_p_svn_opt_subcommand_desc_t, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_opt_print_help" "', argument " "7"" of type '" "svn_opt_subcommand_desc_t const *""'"); 
    }
    arg7 = (svn_opt_subcommand_desc_t *)(argp7);
    res8 = SWIG_ConvertPtr(ST(7), &argp8,SWIGTYPE_p_apr_getopt_option_t, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_opt_print_help" "', argument " "8"" of type '" "apr_getopt_option_t const *""'"); 
    }
    arg8 = (apr_getopt_option_t *)(argp8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_opt_print_help" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    if (items > 9) {
      
    }
    {
      result = (svn_error_t *)svn_opt_print_help(arg1,(char const *)arg2,arg3,arg4,(char const *)arg5,(char const *)arg6,(struct svn_opt_subcommand_desc_t const *)arg7,(apr_getopt_option_t const *)arg8,(char const *)arg9,arg10);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_cred_kind_set) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_t_cred_kind_set(self,cred_kind);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_cred_kind_set" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_provider_t_cred_kind_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->cred_kind) free((char *)arg1->cred_kind);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->cred_kind = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_cred_kind_get) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_t_cred_kind_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_cred_kind_get" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    result = (char *) ((arg1)->cred_kind);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_first_credentials_set) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    svn_error_t *(*arg2)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *) = (svn_error_t *(*)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_t_first_credentials_set(self,first_credentials);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_first_credentials_set" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_provider_t_first_credentials_set" "', argument " "2"" of type '" "svn_error_t *(*)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *)""'"); 
      }
    }
    if (arg1) (arg1)->first_credentials = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_first_credentials_get) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_t_first_credentials_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_first_credentials_get" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    result = (svn_error_t *(*)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *)) ((arg1)->first_credentials);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_next_credentials_set) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    svn_error_t *(*arg2)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *) = (svn_error_t *(*)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_t_next_credentials_set(self,next_credentials);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_next_credentials_set" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_provider_t_next_credentials_set" "', argument " "2"" of type '" "svn_error_t *(*)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *)""'"); 
      }
    }
    if (arg1) (arg1)->next_credentials = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_next_credentials_get) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_t_next_credentials_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_next_credentials_get" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    result = (svn_error_t *(*)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *)) ((arg1)->next_credentials);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_save_credentials_set) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    svn_error_t *(*arg2)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *) = (svn_error_t *(*)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_t_save_credentials_set(self,save_credentials);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_save_credentials_set" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_provider_t_save_credentials_set" "', argument " "2"" of type '" "svn_error_t *(*)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *)""'"); 
      }
    }
    if (arg1) (arg1)->save_credentials = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_t_save_credentials_get) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_t_save_credentials_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_t_save_credentials_get" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    result = (svn_error_t *(*)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *)) ((arg1)->save_credentials);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_provider_t) {
  {
    int argvi = 0;
    svn_auth_provider_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_provider_t();");
    }
    {
      result = (svn_auth_provider_t *)calloc(1, sizeof(svn_auth_provider_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_provider_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_provider_t) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_provider_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_provider_t" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_object_t_vtable_set) {
  {
    svn_auth_provider_object_t *arg1 = (svn_auth_provider_object_t *) 0 ;
    svn_auth_provider_t *arg2 = (svn_auth_provider_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_object_t_vtable_set(self,vtable);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_object_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_object_t_vtable_set" "', argument " "1"" of type '" "svn_auth_provider_object_t *""'"); 
    }
    arg1 = (svn_auth_provider_object_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_auth_provider_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_provider_object_t_vtable_set" "', argument " "2"" of type '" "svn_auth_provider_t const *""'"); 
    }
    arg2 = (svn_auth_provider_t *)(argp2);
    if (arg1) (arg1)->vtable = (svn_auth_provider_t const *)arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_object_t_vtable_get) {
  {
    svn_auth_provider_object_t *arg1 = (svn_auth_provider_object_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_auth_provider_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_object_t_vtable_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_object_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_object_t_vtable_get" "', argument " "1"" of type '" "svn_auth_provider_object_t *""'"); 
    }
    arg1 = (svn_auth_provider_object_t *)(argp1);
    result = (svn_auth_provider_t *) ((arg1)->vtable);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_provider_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_object_t_provider_baton_set) {
  {
    svn_auth_provider_object_t *arg1 = (svn_auth_provider_object_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_provider_object_t_provider_baton_set(self,provider_baton);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_object_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_object_t_provider_baton_set" "', argument " "1"" of type '" "svn_auth_provider_object_t *""'"); 
    }
    arg1 = (svn_auth_provider_object_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_provider_object_t_provider_baton_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->provider_baton = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_object_t_provider_baton_get) {
  {
    svn_auth_provider_object_t *arg1 = (svn_auth_provider_object_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_provider_object_t_provider_baton_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_object_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_object_t_provider_baton_get" "', argument " "1"" of type '" "svn_auth_provider_object_t *""'"); 
    }
    arg1 = (svn_auth_provider_object_t *)(argp1);
    result = (void *) ((arg1)->provider_baton);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_provider_object_t) {
  {
    int argvi = 0;
    svn_auth_provider_object_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_provider_object_t();");
    }
    {
      result = (svn_auth_provider_object_t *)calloc(1, sizeof(svn_auth_provider_object_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_provider_object_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_provider_object_t) {
  {
    svn_auth_provider_object_t *arg1 = (svn_auth_provider_object_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_provider_object_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_object_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_provider_object_t" "', argument " "1"" of type '" "svn_auth_provider_object_t *""'"); 
    }
    arg1 = (svn_auth_provider_object_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_username_set) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_username_set(self,username);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_username_set" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_cred_simple_t_username_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->username) free((char *)arg1->username);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->username = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_username_get) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_username_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_username_get" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    result = (char *) ((arg1)->username);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_password_set) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_password_set(self,password);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_password_set" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_cred_simple_t_password_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->password) free((char *)arg1->password);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->password = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_password_get) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_password_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_password_get" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    result = (char *) ((arg1)->password);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_may_save_set) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_may_save_set(self,may_save);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_may_save_set" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_simple_t_may_save_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->may_save = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_simple_t_may_save_get) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_simple_t_may_save_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_simple_t_may_save_get" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->may_save);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_cred_simple_t) {
  {
    int argvi = 0;
    svn_auth_cred_simple_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_cred_simple_t();");
    }
    {
      result = (svn_auth_cred_simple_t *)calloc(1, sizeof(svn_auth_cred_simple_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_cred_simple_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_cred_simple_t) {
  {
    svn_auth_cred_simple_t *arg1 = (svn_auth_cred_simple_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_cred_simple_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_simple_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_cred_simple_t" "', argument " "1"" of type '" "svn_auth_cred_simple_t *""'"); 
    }
    arg1 = (svn_auth_cred_simple_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_username_t_username_set) {
  {
    svn_auth_cred_username_t *arg1 = (svn_auth_cred_username_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_username_t_username_set(self,username);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_username_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_username_t_username_set" "', argument " "1"" of type '" "svn_auth_cred_username_t *""'"); 
    }
    arg1 = (svn_auth_cred_username_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_cred_username_t_username_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->username) free((char *)arg1->username);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->username = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_username_t_username_get) {
  {
    svn_auth_cred_username_t *arg1 = (svn_auth_cred_username_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_username_t_username_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_username_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_username_t_username_get" "', argument " "1"" of type '" "svn_auth_cred_username_t *""'"); 
    }
    arg1 = (svn_auth_cred_username_t *)(argp1);
    result = (char *) ((arg1)->username);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_username_t_may_save_set) {
  {
    svn_auth_cred_username_t *arg1 = (svn_auth_cred_username_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_username_t_may_save_set(self,may_save);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_username_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_username_t_may_save_set" "', argument " "1"" of type '" "svn_auth_cred_username_t *""'"); 
    }
    arg1 = (svn_auth_cred_username_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_username_t_may_save_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->may_save = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_username_t_may_save_get) {
  {
    svn_auth_cred_username_t *arg1 = (svn_auth_cred_username_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_username_t_may_save_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_username_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_username_t_may_save_get" "', argument " "1"" of type '" "svn_auth_cred_username_t *""'"); 
    }
    arg1 = (svn_auth_cred_username_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->may_save);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_cred_username_t) {
  {
    int argvi = 0;
    svn_auth_cred_username_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_cred_username_t();");
    }
    {
      result = (svn_auth_cred_username_t *)calloc(1, sizeof(svn_auth_cred_username_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_cred_username_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_cred_username_t) {
  {
    svn_auth_cred_username_t *arg1 = (svn_auth_cred_username_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_cred_username_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_username_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_cred_username_t" "', argument " "1"" of type '" "svn_auth_cred_username_t *""'"); 
    }
    arg1 = (svn_auth_cred_username_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_t_cert_file_set) {
  {
    svn_auth_cred_ssl_client_cert_t *arg1 = (svn_auth_cred_ssl_client_cert_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_t_cert_file_set(self,cert_file);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_t_cert_file_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_cred_ssl_client_cert_t_cert_file_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->cert_file) free((char *)arg1->cert_file);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->cert_file = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_t_cert_file_get) {
  {
    svn_auth_cred_ssl_client_cert_t *arg1 = (svn_auth_cred_ssl_client_cert_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_t_cert_file_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_t_cert_file_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_t *)(argp1);
    result = (char *) ((arg1)->cert_file);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_t_may_save_set) {
  {
    svn_auth_cred_ssl_client_cert_t *arg1 = (svn_auth_cred_ssl_client_cert_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_t_may_save_set(self,may_save);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_t_may_save_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_ssl_client_cert_t_may_save_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->may_save = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_t_may_save_get) {
  {
    svn_auth_cred_ssl_client_cert_t *arg1 = (svn_auth_cred_ssl_client_cert_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_t_may_save_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_t_may_save_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->may_save);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_cred_ssl_client_cert_t) {
  {
    int argvi = 0;
    svn_auth_cred_ssl_client_cert_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_cred_ssl_client_cert_t();");
    }
    {
      result = (svn_auth_cred_ssl_client_cert_t *)calloc(1, sizeof(svn_auth_cred_ssl_client_cert_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_cred_ssl_client_cert_t) {
  {
    svn_auth_cred_ssl_client_cert_t *arg1 = (svn_auth_cred_ssl_client_cert_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_cred_ssl_client_cert_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_cred_ssl_client_cert_t" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_pw_t_password_set) {
  {
    svn_auth_cred_ssl_client_cert_pw_t *arg1 = (svn_auth_cred_ssl_client_cert_pw_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_pw_t_password_set(self,password);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_password_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_pw_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_pw_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_password_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->password) free((char *)arg1->password);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->password = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_pw_t_password_get) {
  {
    svn_auth_cred_ssl_client_cert_pw_t *arg1 = (svn_auth_cred_ssl_client_cert_pw_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_pw_t_password_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_password_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_pw_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_pw_t *)(argp1);
    result = (char *) ((arg1)->password);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_pw_t_may_save_set) {
  {
    svn_auth_cred_ssl_client_cert_pw_t *arg1 = (svn_auth_cred_ssl_client_cert_pw_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_pw_t_may_save_set(self,may_save);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_may_save_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_pw_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_pw_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_may_save_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->may_save = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_client_cert_pw_t_may_save_get) {
  {
    svn_auth_cred_ssl_client_cert_pw_t *arg1 = (svn_auth_cred_ssl_client_cert_pw_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_client_cert_pw_t_may_save_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_client_cert_pw_t_may_save_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_pw_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_pw_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->may_save);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_cred_ssl_client_cert_pw_t) {
  {
    int argvi = 0;
    svn_auth_cred_ssl_client_cert_pw_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_cred_ssl_client_cert_pw_t();");
    }
    {
      result = (svn_auth_cred_ssl_client_cert_pw_t *)calloc(1, sizeof(svn_auth_cred_ssl_client_cert_pw_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_cred_ssl_client_cert_pw_t) {
  {
    svn_auth_cred_ssl_client_cert_pw_t *arg1 = (svn_auth_cred_ssl_client_cert_pw_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_cred_ssl_client_cert_pw_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_cred_ssl_client_cert_pw_t" "', argument " "1"" of type '" "svn_auth_cred_ssl_client_cert_pw_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_client_cert_pw_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_hostname_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_hostname_set(self,hostname);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_hostname_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_hostname_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->hostname) free((char *)arg1->hostname);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->hostname = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_hostname_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_hostname_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_hostname_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->hostname);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_fingerprint_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_fingerprint_set(self,fingerprint);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_fingerprint_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_fingerprint_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->fingerprint) free((char *)arg1->fingerprint);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->fingerprint = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_fingerprint_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_fingerprint_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_fingerprint_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->fingerprint);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_valid_from_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_valid_from_set(self,valid_from);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_valid_from_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_valid_from_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->valid_from) free((char *)arg1->valid_from);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->valid_from = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_valid_from_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_valid_from_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_valid_from_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->valid_from);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_valid_until_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_valid_until_set(self,valid_until);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_valid_until_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_valid_until_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->valid_until) free((char *)arg1->valid_until);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->valid_until = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_valid_until_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_valid_until_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_valid_until_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->valid_until);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_issuer_dname_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_issuer_dname_set(self,issuer_dname);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_issuer_dname_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_issuer_dname_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->issuer_dname) free((char *)arg1->issuer_dname);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->issuer_dname = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_issuer_dname_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_issuer_dname_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_issuer_dname_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->issuer_dname);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_ascii_cert_set) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_ascii_cert_set(self,ascii_cert);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_ascii_cert_set" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_ssl_server_cert_info_t_ascii_cert_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->ascii_cert) free((char *)arg1->ascii_cert);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->ascii_cert = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_t_ascii_cert_get) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_t_ascii_cert_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_t_ascii_cert_get" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    result = (char *) ((arg1)->ascii_cert);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_ssl_server_cert_info_t) {
  {
    int argvi = 0;
    svn_auth_ssl_server_cert_info_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_ssl_server_cert_info_t();");
    }
    {
      result = (svn_auth_ssl_server_cert_info_t *)calloc(1, sizeof(svn_auth_ssl_server_cert_info_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_ssl_server_cert_info_t) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_ssl_server_cert_info_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_ssl_server_cert_info_t" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_ssl_server_cert_info_dup) {
  {
    svn_auth_ssl_server_cert_info_t *arg1 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_auth_ssl_server_cert_info_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_ssl_server_cert_info_dup(info,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_ssl_server_cert_info_dup" "', argument " "1"" of type '" "svn_auth_ssl_server_cert_info_t const *""'"); 
    }
    arg1 = (svn_auth_ssl_server_cert_info_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_auth_ssl_server_cert_info_t *)svn_auth_ssl_server_cert_info_dup((struct svn_auth_ssl_server_cert_info_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_server_trust_t_may_save_set) {
  {
    svn_auth_cred_ssl_server_trust_t *arg1 = (svn_auth_cred_ssl_server_trust_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_server_trust_t_may_save_set(self,may_save);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_server_trust_t_may_save_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_server_trust_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_server_trust_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_ssl_server_trust_t_may_save_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->may_save = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_server_trust_t_may_save_get) {
  {
    svn_auth_cred_ssl_server_trust_t *arg1 = (svn_auth_cred_ssl_server_trust_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_server_trust_t_may_save_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_server_trust_t_may_save_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_server_trust_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_server_trust_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->may_save);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_server_trust_t_accepted_failures_set) {
  {
    svn_auth_cred_ssl_server_trust_t *arg1 = (svn_auth_cred_ssl_server_trust_t *) 0 ;
    apr_uint32_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_server_trust_t_accepted_failures_set(self,accepted_failures);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_server_trust_t_accepted_failures_set" "', argument " "1"" of type '" "svn_auth_cred_ssl_server_trust_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_server_trust_t *)(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_auth_cred_ssl_server_trust_t_accepted_failures_set" "', argument " "2"" of type '" "apr_uint32_t""'");
    } 
    arg2 = (apr_uint32_t)(val2);
    if (arg1) (arg1)->accepted_failures = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_cred_ssl_server_trust_t_accepted_failures_get) {
  {
    svn_auth_cred_ssl_server_trust_t *arg1 = (svn_auth_cred_ssl_server_trust_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_uint32_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_cred_ssl_server_trust_t_accepted_failures_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_cred_ssl_server_trust_t_accepted_failures_get" "', argument " "1"" of type '" "svn_auth_cred_ssl_server_trust_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_server_trust_t *)(argp1);
    result =  ((arg1)->accepted_failures);
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_auth_cred_ssl_server_trust_t) {
  {
    int argvi = 0;
    svn_auth_cred_ssl_server_trust_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_auth_cred_ssl_server_trust_t();");
    }
    {
      result = (svn_auth_cred_ssl_server_trust_t *)calloc(1, sizeof(svn_auth_cred_ssl_server_trust_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_auth_cred_ssl_server_trust_t) {
  {
    svn_auth_cred_ssl_server_trust_t *arg1 = (svn_auth_cred_ssl_server_trust_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_auth_cred_ssl_server_trust_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_auth_cred_ssl_server_trust_t" "', argument " "1"" of type '" "svn_auth_cred_ssl_server_trust_t *""'"); 
    }
    arg1 = (svn_auth_cred_ssl_server_trust_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_open) {
  {
    svn_auth_baton_t **arg1 = (svn_auth_baton_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_baton_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_open(providers,pool);");
    }
    {
      arg2 = (apr_array_header_t *) svn_swig_pl_objs_to_array(ST(0),
        SWIGTYPE_p_svn_auth_provider_object_t, _global_pool);
    }
    if (items > 1) {
      
    }
    {
      svn_auth_open(arg1,(apr_array_header_t const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_baton_t, 0); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_set_parameter) {
  {
    svn_auth_baton_t *arg1 = (svn_auth_baton_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *arg3 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_set_parameter(auth_baton,name,value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_baton_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_set_parameter" "', argument " "1"" of type '" "svn_auth_baton_t *""'"); 
    }
    arg1 = (svn_auth_baton_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_set_parameter" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_set_parameter" "', argument " "3"" of type '" "void const *""'"); 
    }
    {
      svn_auth_set_parameter(arg1,(char const *)arg2,(void const *)arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_first_credentials) {
  {
    void **arg1 = (void **) 0 ;
    svn_auth_iterstate_t **arg2 = (svn_auth_iterstate_t **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_auth_baton_t *arg5 = (svn_auth_baton_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *temp1 ;
    svn_auth_iterstate_t *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_auth_first_credentials(cred_kind,realmstring,auth_baton,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_first_credentials" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(1), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_first_credentials" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_ConvertPtr(ST(2), &argp5,SWIGTYPE_p_svn_auth_baton_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_auth_first_credentials" "', argument " "5"" of type '" "svn_auth_baton_t *""'"); 
    }
    arg5 = (svn_auth_baton_t *)(argp5);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_auth_first_credentials(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_void, 0); argvi++  ;
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_iterstate_t, 0); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_next_credentials) {
  {
    void **arg1 = (void **) 0 ;
    svn_auth_iterstate_t *arg2 = (svn_auth_iterstate_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_next_credentials(state,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_svn_auth_iterstate_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_next_credentials" "', argument " "2"" of type '" "svn_auth_iterstate_t *""'"); 
    }
    arg2 = (svn_auth_iterstate_t *)(argp2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_auth_next_credentials(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_void, 0); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_save_credentials) {
  {
    svn_auth_iterstate_t *arg1 = (svn_auth_iterstate_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_save_credentials(state,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_iterstate_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_save_credentials" "', argument " "1"" of type '" "svn_auth_iterstate_t *""'"); 
    }
    arg1 = (svn_auth_iterstate_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_auth_save_credentials(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_simple_prompt_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_simple_prompt_func_t arg2 = (svn_auth_simple_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    int arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int val4 ;
    int ecode4 = 0 ;
    SV *_global_callback ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_simple_prompt_provider(prompt_func,prompt_baton,retry_limit,pool);");
    }
    {
      arg2 = svn_swig_pl_thunk_simple_prompt;
      arg3 = ST(0);
      _global_callback = ST(0);
    }
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_auth_get_simple_prompt_provider" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
    if (items > 2) {
      
    }
    {
      svn_auth_get_simple_prompt_provider(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_username_prompt_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_username_prompt_func_t arg2 = (svn_auth_username_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    int arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int val4 ;
    int ecode4 = 0 ;
    SV *_global_callback ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_username_prompt_provider(prompt_func,prompt_baton,retry_limit,pool);");
    }
    {
      arg2 = svn_swig_pl_thunk_username_prompt;
      arg3 = ST(0);
      _global_callback = ST(0);
    }
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_auth_get_username_prompt_provider" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
    if (items > 2) {
      
    }
    {
      svn_auth_get_username_prompt_provider(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_simple_provider2) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_plaintext_prompt_func_t arg2 = (svn_auth_plaintext_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    SV *_global_callback ;
    int argvi = 0;
    SV * _saved[1] ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_simple_provider2(plaintext_prompt_func,prompt_baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg2), SWIGTYPE_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_get_simple_provider2" "', argument " "2"" of type '" "svn_auth_plaintext_prompt_func_t""'"); 
      }
    }
    {
      _global_callback = ST(1);
      arg3 = (void *) _global_callback;
    }
    if (items > 2) {
      
    }
    _saved[0] = ST(1);
    {
      svn_auth_get_simple_provider2(arg1,arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_simple_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_get_simple_provider(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_auth_get_simple_provider(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_platform_specific_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_platform_specific_provider(provider_name,provider_type,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_get_platform_specific_provider" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_get_platform_specific_provider" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_auth_get_platform_specific_provider(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_platform_specific_client_providers) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    svn_config_t *arg2 = (svn_config_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_get_platform_specific_client_providers(config,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_auth_get_platform_specific_client_providers" "', argument " "2"" of type '" "svn_config_t *""'"); 
    }
    arg2 = (svn_config_t *)(argp2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_auth_get_platform_specific_client_providers(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,59,%append_output@*/ if (argvi >= items) EXTEND(sp,1); /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,56,%set_output@*/ ST(argvi) = svn_swig_pl_convert_array(*arg1,
        SWIGTYPE_p_svn_auth_provider_object_t); argvi++ /*@SWIG@*/
      /*@SWIG@*/
      ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_username_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_get_username_provider(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_auth_get_username_provider(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_server_trust_file_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_get_ssl_server_trust_file_provider(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_auth_get_ssl_server_trust_file_provider(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_client_cert_file_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_get_ssl_client_cert_file_provider(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_auth_get_ssl_client_cert_file_provider(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_client_cert_pw_file_provider2) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_plaintext_passphrase_prompt_func_t arg2 = (svn_auth_plaintext_passphrase_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    SV *_global_callback ;
    int argvi = 0;
    SV * _saved[1] ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_ssl_client_cert_pw_file_provider2(plaintext_passphrase_prompt_func,prompt_baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg2), SWIGTYPE_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_get_ssl_client_cert_pw_file_provider2" "', argument " "2"" of type '" "svn_auth_plaintext_passphrase_prompt_func_t""'"); 
      }
    }
    {
      _global_callback = ST(1);
      arg3 = (void *) _global_callback;
    }
    if (items > 2) {
      
    }
    _saved[0] = ST(1);
    {
      svn_auth_get_ssl_client_cert_pw_file_provider2(arg1,arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_client_cert_pw_file_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_auth_get_ssl_client_cert_pw_file_provider(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_auth_get_ssl_client_cert_pw_file_provider(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_server_trust_prompt_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_ssl_server_trust_prompt_func_t arg2 = (svn_auth_ssl_server_trust_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    SV *_global_callback ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_get_ssl_server_trust_prompt_provider(prompt_func,prompt_baton,pool);");
    }
    {
      arg2 = svn_swig_pl_thunk_ssl_server_trust_prompt;
      arg3 = ST(0);
      _global_callback = ST(0);
    }
    if (items > 1) {
      
    }
    {
      svn_auth_get_ssl_server_trust_prompt_provider(arg1,arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_client_cert_prompt_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_ssl_client_cert_prompt_func_t arg2 = (svn_auth_ssl_client_cert_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    int arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int val4 ;
    int ecode4 = 0 ;
    SV *_global_callback ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_ssl_client_cert_prompt_provider(prompt_func,prompt_baton,retry_limit,pool);");
    }
    {
      arg2 = svn_swig_pl_thunk_ssl_client_cert_prompt;
      arg3 = ST(0);
      _global_callback = ST(0);
    }
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_auth_get_ssl_client_cert_prompt_provider" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
    if (items > 2) {
      
    }
    {
      svn_auth_get_ssl_client_cert_prompt_provider(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_get_ssl_client_cert_pw_prompt_provider) {
  {
    svn_auth_provider_object_t **arg1 = (svn_auth_provider_object_t **) 0 ;
    svn_auth_ssl_client_cert_pw_prompt_func_t arg2 = (svn_auth_ssl_client_cert_pw_prompt_func_t) 0 ;
    void *arg3 = (void *) 0 ;
    int arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp1 ;
    int val4 ;
    int ecode4 = 0 ;
    SV *_global_callback ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_auth_get_ssl_client_cert_pw_prompt_provider(prompt_func,prompt_baton,retry_limit,pool);");
    }
    {
      arg2 = svn_swig_pl_thunk_ssl_client_cert_pw_prompt;
      arg3 = ST(0);
      _global_callback = ST(0);
    }
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_auth_get_ssl_client_cert_pw_prompt_provider" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
    if (items > 2) {
      
    }
    {
      svn_auth_get_ssl_client_cert_pw_prompt_provider(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    {
      /* callback baton */
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newRV_inc(_global_callback)); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_invoke_first_credentials) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void **arg2 = (void **) 0 ;
    void **arg3 = (void **) 0 ;
    void *arg4 = (void *) 0 ;
    apr_hash_t *arg5 = (apr_hash_t *) 0 ;
    char *arg6 = (char *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *temp2 ;
    void *temp3 ;
    int res4 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_auth_provider_invoke_first_credentials(_obj,provider_baton,parameters,realmstring,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_invoke_first_credentials" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    res4 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_provider_invoke_first_credentials" "', argument " "4"" of type '" "void *""'"); 
    }
    res5 = SWIG_ConvertPtr(ST(2), &argp5,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_auth_provider_invoke_first_credentials" "', argument " "5"" of type '" "apr_hash_t *""'"); 
    }
    arg5 = (apr_hash_t *)(argp5);
    res6 = SWIG_AsCharPtrAndSize(ST(3), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_auth_provider_invoke_first_credentials" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_auth_provider_invoke_first_credentials(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_void, 0); argvi++  ;
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg3, SWIGTYPE_p_void, 0); argvi++  ;
    }
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_invoke_next_credentials) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    void **arg2 = (void **) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    apr_hash_t *arg5 = (apr_hash_t *) 0 ;
    char *arg6 = (char *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *temp2 ;
    int res3 ;
    int res4 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 5) || (items > 6)) {
      SWIG_croak("Usage: svn_auth_provider_invoke_next_credentials(_obj,iter_baton,provider_baton,parameters,realmstring,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_invoke_next_credentials" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_provider_invoke_next_credentials" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_provider_invoke_next_credentials" "', argument " "4"" of type '" "void *""'"); 
    }
    res5 = SWIG_ConvertPtr(ST(3), &argp5,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_auth_provider_invoke_next_credentials" "', argument " "5"" of type '" "apr_hash_t *""'"); 
    }
    arg5 = (apr_hash_t *)(argp5);
    res6 = SWIG_AsCharPtrAndSize(ST(4), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_auth_provider_invoke_next_credentials" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_auth_provider_invoke_next_credentials(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_void, 0); argvi++  ;
    }
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_provider_invoke_save_credentials) {
  {
    svn_auth_provider_t *arg1 = (svn_auth_provider_t *) 0 ;
    svn_boolean_t *arg2 = (svn_boolean_t *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    apr_hash_t *arg5 = (apr_hash_t *) 0 ;
    char *arg6 = (char *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_boolean_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    int res3 ;
    int res4 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 5) || (items > 6)) {
      SWIG_croak("Usage: svn_auth_provider_invoke_save_credentials(_obj,credentials,provider_baton,parameters,realmstring,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_auth_provider_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_auth_provider_invoke_save_credentials" "', argument " "1"" of type '" "svn_auth_provider_t *""'"); 
    }
    arg1 = (svn_auth_provider_t *)(argp1);
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_provider_invoke_save_credentials" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_provider_invoke_save_credentials" "', argument " "4"" of type '" "void *""'"); 
    }
    res5 = SWIG_ConvertPtr(ST(3), &argp5,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_auth_provider_invoke_save_credentials" "', argument " "5"" of type '" "apr_hash_t *""'"); 
    }
    arg5 = (apr_hash_t *)(argp5);
    res6 = SWIG_AsCharPtrAndSize(ST(4), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_auth_provider_invoke_save_credentials" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_auth_provider_invoke_save_credentials(arg1,arg2,arg3,arg4,arg5,(char const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_simple_provider_func) {
  {
    svn_auth_simple_provider_func_t arg1 = (svn_auth_simple_provider_func_t) 0 ;
    svn_auth_provider_object_t **arg2 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp2 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_invoke_simple_provider_func(_obj,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_simple_provider_func" "', argument " "1"" of type '" "svn_auth_simple_provider_func_t""'"); 
      }
    }
    if (items > 1) {
      
    }
    {
      svn_auth_invoke_simple_provider_func(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_ssl_client_cert_pw_provider_func) {
  {
    svn_auth_ssl_client_cert_pw_provider_func_t arg1 = (svn_auth_ssl_client_cert_pw_provider_func_t) 0 ;
    svn_auth_provider_object_t **arg2 = (svn_auth_provider_object_t **) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_provider_object_t *temp2 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_auth_invoke_ssl_client_cert_pw_provider_func(_obj,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_ssl_client_cert_pw_provider_func" "', argument " "1"" of type '" "svn_auth_ssl_client_cert_pw_provider_func_t""'"); 
      }
    }
    if (items > 1) {
      
    }
    {
      svn_auth_invoke_ssl_client_cert_pw_provider_func(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_provider_object_t, 0); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_simple_prompt_func) {
  {
    svn_auth_simple_prompt_func_t arg1 = (svn_auth_simple_prompt_func_t) 0 ;
    svn_auth_cred_simple_t **arg2 = (svn_auth_cred_simple_t **) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    svn_boolean_t arg6 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_cred_simple_t *temp2 ;
    int res3 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int val6 ;
    int ecode6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 5) || (items > 6)) {
      SWIG_croak("Usage: svn_auth_invoke_simple_prompt_func(_obj,baton,realm,username,may_save,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_simple_prompt_func" "', argument " "1"" of type '" "svn_auth_simple_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_simple_prompt_func" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_simple_prompt_func" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_auth_invoke_simple_prompt_func" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    ecode6 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(4), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_auth_invoke_simple_prompt_func" "', argument " "6"" of type '" "svn_boolean_t""'");
    } 
    arg6 = (svn_boolean_t)(val6);
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_simple_prompt_func(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_cred_simple_t, 0); argvi++  ;
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_username_prompt_func) {
  {
    svn_auth_username_prompt_func_t arg1 = (svn_auth_username_prompt_func_t) 0 ;
    svn_auth_cred_username_t **arg2 = (svn_auth_cred_username_t **) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_cred_username_t *temp2 ;
    int res3 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_auth_invoke_username_prompt_func(_obj,baton,realm,may_save,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_username_prompt_func" "', argument " "1"" of type '" "svn_auth_username_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_username_prompt_func" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_username_prompt_func" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_auth_invoke_username_prompt_func" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_username_prompt_func(arg1,arg2,arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_cred_username_t, 0); argvi++  ;
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_ssl_server_trust_prompt_func) {
  {
    svn_auth_ssl_server_trust_prompt_func_t arg1 = (svn_auth_ssl_server_trust_prompt_func_t) 0 ;
    svn_auth_cred_ssl_server_trust_t **arg2 = (svn_auth_cred_ssl_server_trust_t **) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_uint32_t arg5 ;
    svn_auth_ssl_server_cert_info_t *arg6 = (svn_auth_ssl_server_cert_info_t *) 0 ;
    svn_boolean_t arg7 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_cred_ssl_server_trust_t *temp2 ;
    int res3 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    unsigned long val5 ;
    int ecode5 = 0 ;
    void *argp6 = 0 ;
    int res6 = 0 ;
    int val7 ;
    int ecode7 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 6) || (items > 7)) {
      SWIG_croak("Usage: svn_auth_invoke_ssl_server_trust_prompt_func(_obj,baton,realm,failures,cert_info,may_save,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "1"" of type '" "svn_auth_ssl_server_trust_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "5"" of type '" "apr_uint32_t""'");
    } 
    arg5 = (apr_uint32_t)(val5);
    res6 = SWIG_ConvertPtr(ST(4), &argp6,SWIGTYPE_p_svn_auth_ssl_server_cert_info_t, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "6"" of type '" "svn_auth_ssl_server_cert_info_t const *""'"); 
    }
    arg6 = (svn_auth_ssl_server_cert_info_t *)(argp6);
    ecode7 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(5), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_auth_invoke_ssl_server_trust_prompt_func" "', argument " "7"" of type '" "svn_boolean_t""'");
    } 
    arg7 = (svn_boolean_t)(val7);
    if (items > 6) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_ssl_server_trust_prompt_func(arg1,arg2,arg3,(char const *)arg4,arg5,(struct svn_auth_ssl_server_cert_info_t const *)arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_cred_ssl_server_trust_t, 0); argvi++  ;
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_ssl_client_cert_prompt_func) {
  {
    svn_auth_ssl_client_cert_prompt_func_t arg1 = (svn_auth_ssl_client_cert_prompt_func_t) 0 ;
    svn_auth_cred_ssl_client_cert_t **arg2 = (svn_auth_cred_ssl_client_cert_t **) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_cred_ssl_client_cert_t *temp2 ;
    int res3 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_auth_invoke_ssl_client_cert_prompt_func(_obj,baton,realm,may_save,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_ssl_client_cert_prompt_func" "', argument " "1"" of type '" "svn_auth_ssl_client_cert_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_ssl_client_cert_prompt_func" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_ssl_client_cert_prompt_func" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_auth_invoke_ssl_client_cert_prompt_func" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_ssl_client_cert_prompt_func(arg1,arg2,arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_cred_ssl_client_cert_t, 0); argvi++  ;
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_ssl_client_cert_pw_prompt_func) {
  {
    svn_auth_ssl_client_cert_pw_prompt_func_t arg1 = (svn_auth_ssl_client_cert_pw_prompt_func_t) 0 ;
    svn_auth_cred_ssl_client_cert_pw_t **arg2 = (svn_auth_cred_ssl_client_cert_pw_t **) 0 ;
    void *arg3 = (void *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_auth_cred_ssl_client_cert_pw_t *temp2 ;
    int res3 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_auth_invoke_ssl_client_cert_pw_prompt_func(_obj,baton,realm,may_save,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_ssl_client_cert_pw_prompt_func" "', argument " "1"" of type '" "svn_auth_ssl_client_cert_pw_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_ssl_client_cert_pw_prompt_func" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_ssl_client_cert_pw_prompt_func" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_auth_invoke_ssl_client_cert_pw_prompt_func" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_ssl_client_cert_pw_prompt_func(arg1,arg2,arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg2, SWIGTYPE_p_svn_auth_cred_ssl_client_cert_pw_t, 0); argvi++  ;
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_plaintext_prompt_func) {
  {
    svn_auth_plaintext_prompt_func_t arg1 = (svn_auth_plaintext_prompt_func_t) 0 ;
    svn_boolean_t *arg2 = (svn_boolean_t *) 0 ;
    char *arg3 = (char *) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_auth_invoke_plaintext_prompt_func(_obj,realmstring,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_plaintext_prompt_func" "', argument " "1"" of type '" "svn_auth_plaintext_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_plaintext_prompt_func" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_plaintext_prompt_func" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_plaintext_prompt_func(arg1,arg2,(char const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_auth_invoke_plaintext_passphrase_prompt_func) {
  {
    svn_auth_plaintext_passphrase_prompt_func_t arg1 = (svn_auth_plaintext_passphrase_prompt_func_t) 0 ;
    svn_boolean_t *arg2 = (svn_boolean_t *) 0 ;
    char *arg3 = (char *) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_auth_invoke_plaintext_passphrase_prompt_func(_obj,realmstring,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_auth_invoke_plaintext_passphrase_prompt_func" "', argument " "1"" of type '" "svn_auth_plaintext_passphrase_prompt_func_t""'"); 
      }
    }
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_auth_invoke_plaintext_passphrase_prompt_func" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_auth_invoke_plaintext_passphrase_prompt_func" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_auth_invoke_plaintext_passphrase_prompt_func(arg1,arg2,(char const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_config) {
  {
    apr_hash_t **arg1 = (apr_hash_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_hash_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_config_get_config(config_dir,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_get_config" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_config_get_config(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_convert_hash(*arg1, SWIGTYPE_p_svn_config_t); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_create) {
  {
    svn_config_t **arg1 = (svn_config_t **) 0 ;
    svn_boolean_t arg2 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_config_t *temp1 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_config_create(section_names_case_sensitive,result_pool);");
    }
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_config_create" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_config_create(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_config_t, 0); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_read2) {
  {
    svn_config_t **arg1 = (svn_config_t **) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_config_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_config_read2(file,must_exist,section_names_case_sensitive,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_read2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_config_read2" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_config_read2" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_config_read2(arg1,(char const *)arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_config_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_read) {
  {
    svn_config_t **arg1 = (svn_config_t **) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_config_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_config_read(file,must_exist,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_read" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_config_read" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_config_read(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_config_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_merge) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_config_merge(cfg,file,must_exist);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_merge" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_merge" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_config_merge" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    {
      result = (svn_error_t *)svn_config_merge(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    arg2 = &temp2;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_get(cfg,section,option,default_value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_get" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_config_get" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    {
      svn_config_get(arg1,(char const **)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_set) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_set(cfg,section,option,value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_set" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_set" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_set" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      svn_config_set(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_bool) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    svn_boolean_t *arg2 = (svn_boolean_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_boolean_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg2 = &temp2;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_get_bool(cfg,section,option,default_value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get_bool" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_bool" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_get_bool" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_config_get_bool" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    {
      result = (svn_error_t *)svn_config_get_bool(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_set_bool) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    svn_boolean_t arg4 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_set_bool(cfg,section,option,value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_set_bool" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_set_bool" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_set_bool" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_config_set_bool" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    {
      svn_config_set_bool(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_yes_no_ask) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg2 = &temp2;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_get_yes_no_ask(cfg,section,option,default_value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get_yes_no_ask" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_yes_no_ask" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_get_yes_no_ask" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_config_get_yes_no_ask" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    {
      result = (svn_error_t *)svn_config_get_yes_no_ask(arg1,(char const **)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_enumerate_sections) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    svn_config_section_enumerator_t arg2 = (svn_config_section_enumerator_t) 0 ;
    void *arg3 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res3 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_config_enumerate_sections(cfg,callback,baton);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_enumerate_sections" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__char_p_void__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_enumerate_sections" "', argument " "2"" of type '" "svn_config_section_enumerator_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_enumerate_sections" "', argument " "3"" of type '" "void *""'"); 
    }
    {
      result = (int)svn_config_enumerate_sections(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_enumerate_sections2) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    svn_config_section_enumerator2_t arg2 = (svn_config_section_enumerator2_t) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res3 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_config_enumerate_sections2(cfg,callback,baton,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_enumerate_sections2" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__char_p_void_p_apr_pool_t__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_enumerate_sections2" "', argument " "2"" of type '" "svn_config_section_enumerator2_t""'"); 
      }
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_enumerate_sections2" "', argument " "3"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (int)svn_config_enumerate_sections2(arg1,arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_enumerate) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_config_enumerator_t arg3 = (svn_config_enumerator_t) 0 ;
    void *arg4 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_config_enumerate(cfg,section,callback,baton);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_enumerate" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_enumerate" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      arg3 = svn_swig_pl_thunk_config_enumerator;
      arg4 = ST(2);
    }
    {
      result = (int)svn_config_enumerate(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_enumerate2) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    svn_config_enumerator2_t arg3 = (svn_config_enumerator2_t) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res4 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_config_enumerate2(cfg,section,callback,baton,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_enumerate2" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_enumerate2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      int res = SWIG_ConvertFunctionPtr(ST(2), (void**)(&arg3), SWIGTYPE_p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_enumerate2" "', argument " "3"" of type '" "svn_config_enumerator2_t""'"); 
      }
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_enumerate2" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (int)svn_config_enumerate2(arg1,(char const *)arg2,arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_has_section) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_config_has_section(cfg,section);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_has_section" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_has_section" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_boolean_t)svn_config_has_section(arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_find_group) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_config_find_group(cfg,key,master_section,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_find_group" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_find_group" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_find_group" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 3) {
      
    }
    {
      result = (char *)svn_config_find_group(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_server_setting) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_get_server_setting(cfg,server_group,option_name,default_value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get_server_setting" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_get_server_setting" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_server_setting" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_get_server_setting" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      result = (char *)svn_config_get_server_setting(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_server_setting_int) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_int64_t arg4 ;
    apr_int64_t *arg5 = (apr_int64_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    apr_int64_t temp5 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg5 = &temp5;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_config_get_server_setting_int(cfg,server_group,option_name,default_value,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get_server_setting_int" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_get_server_setting_int" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_server_setting_int" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_config_get_server_setting_int" "', argument " "4"" of type '" "apr_int64_t""'");
    } 
    arg4 = (apr_int64_t)(val4);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_config_get_server_setting_int(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t)*(arg5));
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(temp, 0)); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_server_setting_bool) {
  {
    svn_config_t *arg1 = (svn_config_t *) 0 ;
    svn_boolean_t *arg2 = (svn_boolean_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_boolean_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg2 = &temp2;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_get_server_setting_bool(cfg,server_group,option_name,default_value);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_config_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_get_server_setting_bool" "', argument " "1"" of type '" "svn_config_t *""'"); 
    }
    arg1 = (svn_config_t *)(argp1);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_server_setting_bool" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_get_server_setting_bool" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_config_get_server_setting_bool" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    {
      result = (svn_error_t *)svn_config_get_server_setting_bool(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_ensure) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_config_ensure(config_dir,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_ensure" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_config_ensure((char const *)arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_read_auth_data) {
  {
    apr_hash_t **arg1 = (apr_hash_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_hash_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_config_read_auth_data(cred_kind,realmstring,config_dir,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_read_auth_data" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_read_auth_data" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_read_auth_data" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_config_read_auth_data(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = !*arg1 ? &PL_sv_undef : svn_swig_pl_prophash_to_hash(*arg1); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_write_auth_data) {
  {
    apr_hash_t *arg1 = (apr_hash_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_config_write_auth_data(hash,cred_kind,realmstring,config_dir,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_config_write_auth_data" "', argument " "1"" of type '" "apr_hash_t *""'"); 
    }
    arg1 = (apr_hash_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_write_auth_data" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_write_auth_data" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_write_auth_data" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_config_write_auth_data(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_get_user_config_path) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_config_get_user_config_path(config_dir,fname,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_get_user_config_path" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_get_user_config_path" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_config_get_user_config_path((char const **)arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_invoke_section_enumerator) {
  {
    svn_config_section_enumerator_t arg1 = (svn_config_section_enumerator_t) 0 ;
    char *arg2 = (char *) 0 ;
    void *arg3 = (void *) 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_config_invoke_section_enumerator(_obj,name,baton);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__char_p_void__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_invoke_section_enumerator" "', argument " "1"" of type '" "svn_config_section_enumerator_t""'"); 
      }
    }
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_invoke_section_enumerator" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_invoke_section_enumerator" "', argument " "3"" of type '" "void *""'"); 
    }
    {
      result = (svn_boolean_t)svn_config_invoke_section_enumerator(arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_invoke_section_enumerator2) {
  {
    svn_config_section_enumerator2_t arg1 = (svn_config_section_enumerator2_t) 0 ;
    char *arg2 = (char *) 0 ;
    void *arg3 = (void *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_config_invoke_section_enumerator2(_obj,name,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__char_p_void_p_apr_pool_t__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_invoke_section_enumerator2" "', argument " "1"" of type '" "svn_config_section_enumerator2_t""'"); 
      }
    }
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_invoke_section_enumerator2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_invoke_section_enumerator2" "', argument " "3"" of type '" "void *""'"); 
    }
    if (items > 3) {
      
    }
    {
      result = (svn_boolean_t)svn_config_invoke_section_enumerator2(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_invoke_enumerator) {
  {
    svn_config_enumerator_t arg1 = (svn_config_enumerator_t) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    void *arg4 = (void *) 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_config_invoke_enumerator(_obj,name,value,baton);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__char_p_q_const__char_p_void__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_invoke_enumerator" "', argument " "1"" of type '" "svn_config_enumerator_t""'"); 
      }
    }
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_invoke_enumerator" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_invoke_enumerator" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_invoke_enumerator" "', argument " "4"" of type '" "void *""'"); 
    }
    {
      result = (svn_boolean_t)svn_config_invoke_enumerator(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_config_invoke_enumerator2) {
  {
    svn_config_enumerator2_t arg1 = (svn_config_enumerator2_t) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_config_invoke_enumerator2(_obj,name,value,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_config_invoke_enumerator2" "', argument " "1"" of type '" "svn_config_enumerator2_t""'"); 
      }
    }
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_config_invoke_enumerator2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_config_invoke_enumerator2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_config_invoke_enumerator2" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (svn_boolean_t)svn_config_invoke_enumerator2(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_initialize) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_utf_initialize(pool);");
    }
    if (items > 0) {
      
    }
    {
      svn_utf_initialize(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_stringbuf_to_utf8) {
  {
    svn_stringbuf_t **arg1 = (svn_stringbuf_t **) 0 ;
    svn_stringbuf_t *arg2 = (svn_stringbuf_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_stringbuf_to_utf8(src,pool);");
    }
    {
      apr_size_t len;
      char *buf;
      
      if (!SvOK(ST(0))) {
        arg2 = NULL;
      } else if (SvPOK(ST(0))) {
        buf = SvPV(ST(0), len);
        /* Another case of ugly pool handling, this should use the current
                   default pool, or make a new one if it doesn't exist yet */
        arg2 = svn_stringbuf_ncreate(buf,len,
          svn_swig_pl_make_pool ((SV *)NULL));
      } else {
        croak("Not a string");
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_stringbuf_to_utf8(arg1,(struct svn_stringbuf_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_string_to_utf8) {
  {
    svn_string_t **arg1 = (svn_string_t **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t *temp1 ;
    svn_string_t value2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_string_to_utf8(src,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_string_to_utf8((struct svn_string_t const **)arg1,(struct svn_string_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_to_utf8) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_cstring_to_utf8(src,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_to_utf8" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_to_utf8((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_to_utf8_ex2) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_utf_cstring_to_utf8_ex2(src,frompage,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_to_utf8_ex2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_utf_cstring_to_utf8_ex2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_to_utf8_ex2((char const **)arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_to_utf8_ex) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_utf_cstring_to_utf8_ex(src,frompage,convset_key,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_to_utf8_ex" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_utf_cstring_to_utf8_ex" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_utf_cstring_to_utf8_ex" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_to_utf8_ex((char const **)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_stringbuf_from_utf8) {
  {
    svn_stringbuf_t **arg1 = (svn_stringbuf_t **) 0 ;
    svn_stringbuf_t *arg2 = (svn_stringbuf_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_stringbuf_from_utf8(src,pool);");
    }
    {
      apr_size_t len;
      char *buf;
      
      if (!SvOK(ST(0))) {
        arg2 = NULL;
      } else if (SvPOK(ST(0))) {
        buf = SvPV(ST(0), len);
        /* Another case of ugly pool handling, this should use the current
                   default pool, or make a new one if it doesn't exist yet */
        arg2 = svn_stringbuf_ncreate(buf,len,
          svn_swig_pl_make_pool ((SV *)NULL));
      } else {
        croak("Not a string");
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_stringbuf_from_utf8(arg1,(struct svn_stringbuf_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_string_from_utf8) {
  {
    svn_string_t **arg1 = (svn_string_t **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t *temp1 ;
    svn_string_t value2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_string_from_utf8(src,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_string_from_utf8((struct svn_string_t const **)arg1,(struct svn_string_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8(src,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_from_utf8" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_from_utf8((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8_ex2) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8_ex2(src,topage,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_from_utf8_ex2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_utf_cstring_from_utf8_ex2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_from_utf8_ex2((char const **)arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8_ex) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8_ex(src,topage,convset_key,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_utf_cstring_from_utf8_ex" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_utf_cstring_from_utf8_ex" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_utf_cstring_from_utf8_ex" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_from_utf8_ex((char const **)arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8_fuzzy) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8_fuzzy(src,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_utf_cstring_from_utf8_fuzzy" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_utf_cstring_from_utf8_fuzzy((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8_stringbuf) {
  {
    char **arg1 = (char **) 0 ;
    svn_stringbuf_t *arg2 = (svn_stringbuf_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8_stringbuf(src,pool);");
    }
    {
      apr_size_t len;
      char *buf;
      
      if (!SvOK(ST(0))) {
        arg2 = NULL;
      } else if (SvPOK(ST(0))) {
        buf = SvPV(ST(0), len);
        /* Another case of ugly pool handling, this should use the current
                   default pool, or make a new one if it doesn't exist yet */
        arg2 = svn_stringbuf_ncreate(buf,len,
          svn_swig_pl_make_pool ((SV *)NULL));
      } else {
        croak("Not a string");
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_from_utf8_stringbuf((char const **)arg1,(struct svn_stringbuf_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_utf_cstring_from_utf8_string) {
  {
    char **arg1 = (char **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    svn_string_t value2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_utf_cstring_from_utf8_string(src,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_utf_cstring_from_utf8_string((char const **)arg1,(struct svn_string_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_nls_init) {
  {
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: svn_nls_init();");
    }
    {
      result = (svn_error_t *)svn_nls_init();
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_internal_style) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_path_internal_style(path,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_internal_style" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_path_internal_style((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_local_style) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_path_local_style(path,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_local_style" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_path_local_style((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_splitext) {
  {
    char **arg1 = (char **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_path_splitext(path,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_path_splitext" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 1) {
      
    }
    {
      svn_path_splitext((char const **)arg1,(char const **)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_is_empty) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_path_is_empty(path);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_is_empty" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (int)svn_path_is_empty((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_is_root) {
  {
    char *arg1 = (char *) 0 ;
    apr_size_t arg2 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    unsigned long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_is_root(dirent,len);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_is_root" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    ecode2 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_dirent_is_root" "', argument " "2"" of type '" "apr_size_t""'");
    } 
    arg2 = (apr_size_t)(val2);
    {
      result = (svn_boolean_t)svn_dirent_is_root((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_canonicalize) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_path_canonicalize(path,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_canonicalize" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_path_canonicalize((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_is_canonical) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_path_is_canonical(path,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_is_canonical" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (svn_boolean_t)svn_path_is_canonical((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_compare_paths) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    int result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_path_compare_paths(path1,path2);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_compare_paths" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_path_compare_paths" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (int)svn_path_compare_paths((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_get_longest_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_path_get_longest_ancestor(path1,path2,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_get_longest_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_path_get_longest_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_path_get_longest_ancestor((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_is_dotpath_present) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_path_is_dotpath_present(path);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_is_dotpath_present" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_path_is_dotpath_present((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_is_url) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_path_is_url(path);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_is_url" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_path_is_url((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_is_uri_safe) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_path_is_uri_safe(path);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_is_uri_safe" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_path_is_uri_safe((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_path_url_add_component2) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_path_url_add_component2(url,component,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_path_url_add_component2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_path_url_add_component2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_path_url_add_component2((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_internal_style) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_internal_style(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_internal_style" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_dirent_internal_style((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_local_style) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_local_style(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_local_style" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_dirent_local_style((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath__internal_style) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath__internal_style(relpath,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath__internal_style" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_relpath__internal_style((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_join) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_dirent_join(base,component,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_join" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_join" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_dirent_join((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_join) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_relpath_join(base,component,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_join" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_relpath_join" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_relpath_join((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_basename) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_basename(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_basename" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_dirent_basename((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_dirname) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_dirname(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_dirname" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_dirent_dirname((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_split) {
  {
    char **arg1 = (char **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_split(dirent,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_dirent_split" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 1) {
      
    }
    {
      svn_dirent_split((char const **)arg1,(char const **)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_split) {
  {
    char **arg1 = (char **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath_split(relpath,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_relpath_split" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 1) {
      
    }
    {
      svn_relpath_split((char const **)arg1,(char const **)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_basename) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath_basename(relpath,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_basename" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_relpath_basename((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_dirname) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath_dirname(relpath,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_dirname" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_relpath_dirname((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_split) {
  {
    char **arg1 = (char **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_split(uri,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_uri_split" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 1) {
      
    }
    {
      svn_uri_split((char const **)arg1,(char const **)arg2,(char const *)arg3,arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_basename) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_basename(uri,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_basename" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_uri_basename((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_dirname) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_dirname(uri,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_dirname" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_uri_dirname((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_is_absolute) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_dirent_is_absolute(dirent);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_is_absolute" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_dirent_is_absolute((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_is_root) {
  {
    char *arg1 = (char *) 0 ;
    apr_size_t arg2 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    unsigned long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_is_root(uri,len);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_is_root" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    ecode2 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_uri_is_root" "', argument " "2"" of type '" "apr_size_t""'");
    } 
    arg2 = (apr_size_t)(val2);
    {
      result = (svn_boolean_t)svn_uri_is_root((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_canonicalize) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_canonicalize(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_canonicalize" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_dirent_canonicalize((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_canonicalize) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath_canonicalize(relpath,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_canonicalize" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_relpath_canonicalize((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_canonicalize) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_canonicalize(uri,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_canonicalize" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (char *)svn_uri_canonicalize((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_is_canonical) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_is_canonical(dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_is_canonical" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (svn_boolean_t)svn_dirent_is_canonical((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_is_canonical) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_relpath_is_canonical(relpath);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_is_canonical" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_boolean_t)svn_relpath_is_canonical((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_is_canonical) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_is_canonical(uri,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_is_canonical" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      result = (svn_boolean_t)svn_uri_is_canonical((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_get_longest_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_dirent_get_longest_ancestor(dirent1,dirent2,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_get_longest_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_get_longest_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_dirent_get_longest_ancestor((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_get_longest_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_relpath_get_longest_ancestor(relpath1,relpath2,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_get_longest_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_relpath_get_longest_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_relpath_get_longest_ancestor((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_get_longest_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_uri_get_longest_ancestor(uri1,uri2,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_get_longest_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri_get_longest_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_uri_get_longest_ancestor((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_get_absolute) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_get_absolute(relative,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_get_absolute" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_dirent_get_absolute((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri__is_child) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_uri__is_child(parent_uri,child_uri,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri__is_child" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri__is_child" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_uri__is_child((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_is_child) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_dirent_is_child(parent_dirent,child_dirent,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_is_child" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_is_child" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_dirent_is_child((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath__is_child) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_relpath__is_child(parent_relpath,child_relpath,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath__is_child" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_relpath__is_child" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_relpath__is_child((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_is_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_is_ancestor(parent_dirent,child_dirent);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_is_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_is_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_boolean_t)svn_dirent_is_ancestor((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath__is_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath__is_ancestor(parent_relpath,child_relpath);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath__is_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_relpath__is_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_boolean_t)svn_relpath__is_ancestor((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri__is_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_uri__is_ancestor(parent_uri,child_uri);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri__is_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri__is_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_boolean_t)svn_uri__is_ancestor((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_dirent_skip_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_dirent_skip_ancestor(parent_dirent,child_dirent);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_dirent_skip_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_dirent_skip_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (char *)svn_dirent_skip_ancestor((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_relpath_skip_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_relpath_skip_ancestor(parent_relpath,child_relpath);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_relpath_skip_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_relpath_skip_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (char *)svn_relpath_skip_ancestor((char const *)arg1,(char const *)arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_skip_ancestor) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_uri_skip_ancestor(parent_uri,child_uri,result_pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_uri_skip_ancestor" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri_skip_ancestor" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (char *)svn_uri_skip_ancestor((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_get_dirent_from_file_url) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_get_dirent_from_file_url(url,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri_get_dirent_from_file_url" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_uri_get_dirent_from_file_url((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_uri_get_file_url_from_dirent) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_uri_get_file_url_from_dirent(dirent,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_uri_get_file_url_from_dirent" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_uri_get_file_url_from_dirent((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_parse) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_mergeinfo_parse(input,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_parse" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_parse(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_parse arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_parse is not implemented yet");
      
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_diff) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t *arg2 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg3 = (svn_mergeinfo_t) 0 ;
    svn_mergeinfo_t arg4 = (svn_mergeinfo_t) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    svn_mergeinfo_t temp2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_mergeinfo_diff(mergefrom,mergeto,consider_inheritance,pool);");
    }
    res3 = SWIG_ConvertPtr(ST(0), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_diff" "', argument " "3"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg3 = (svn_mergeinfo_t)(argp3);
    res4 = SWIG_ConvertPtr(ST(1), &argp4,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_mergeinfo_diff" "', argument " "4"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg4 = (svn_mergeinfo_t)(argp4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_mergeinfo_diff" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_diff(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_diff arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_diff is not implemented yet");
      
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_diff arg 2 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_diff is not implemented yet");
      
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_catalog_merge) {
  {
    svn_mergeinfo_catalog_t arg1 = (svn_mergeinfo_catalog_t) 0 ;
    svn_mergeinfo_catalog_t arg2 = (svn_mergeinfo_catalog_t) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 4)) {
      SWIG_croak("Usage: svn_mergeinfo_catalog_merge(mergeinfo_catalog,changes_catalog,result_pool,scratch_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_mergeinfo_catalog_merge" "', argument " "1"" of type '" "svn_mergeinfo_catalog_t""'"); 
    }
    arg1 = (svn_mergeinfo_catalog_t)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_catalog_merge" "', argument " "2"" of type '" "svn_mergeinfo_catalog_t""'"); 
    }
    arg2 = (svn_mergeinfo_catalog_t)(argp2);
    if (items > 2) {
      
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_catalog_merge(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_remove) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    svn_mergeinfo_t arg3 = (svn_mergeinfo_t) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_mergeinfo_remove(eraser,whiteboard,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_remove" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_remove" "', argument " "3"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg3 = (svn_mergeinfo_t)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_remove(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_remove arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_remove is not implemented yet");
      
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_remove2) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    svn_mergeinfo_t arg3 = (svn_mergeinfo_t) 0 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 5)) {
      SWIG_croak("Usage: svn_mergeinfo_remove2(eraser,whiteboard,consider_inheritance,result_pool,scratch_pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_remove2" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_remove2" "', argument " "3"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg3 = (svn_mergeinfo_t)(argp3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_mergeinfo_remove2" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_remove2(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_remove2 arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_remove2 is not implemented yet");
      
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_diff) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_array_header_t **arg2 = (apr_array_header_t **) 0 ;
    apr_array_header_t *arg3 = (apr_array_header_t *) 0 ;
    apr_array_header_t *arg4 = (apr_array_header_t *) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    apr_array_header_t *temp2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_rangelist_diff(from,to,consider_inheritance,pool);");
    }
    res3 = SWIG_ConvertPtr(ST(0), &argp3,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_rangelist_diff" "', argument " "3"" of type '" "apr_array_header_t const *""'"); 
    }
    arg3 = (apr_array_header_t *)(argp3);
    res4 = SWIG_ConvertPtr(ST(1), &argp4,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_rangelist_diff" "', argument " "4"" of type '" "apr_array_header_t const *""'"); 
    }
    arg4 = (apr_array_header_t *)(argp4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_rangelist_diff" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_diff(arg1,arg2,(apr_array_header_t const *)arg3,(apr_array_header_t const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_diff arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_diff is not implemented yet");
      
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_diff arg 2 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_diff is not implemented yet");
      
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_remove) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    apr_array_header_t *arg3 = (apr_array_header_t *) 0 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_rangelist_remove(eraser,whiteboard,consider_inheritance,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_rangelist_remove" "', argument " "2"" of type '" "apr_array_header_t const *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_rangelist_remove" "', argument " "3"" of type '" "apr_array_header_t const *""'"); 
    }
    arg3 = (apr_array_header_t *)(argp3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_rangelist_remove" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_remove(arg1,(apr_array_header_t const *)arg2,(apr_array_header_t const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_remove arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_remove is not implemented yet");
      
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_intersect2) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    svn_mergeinfo_t arg3 = (svn_mergeinfo_t) 0 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 5)) {
      SWIG_croak("Usage: svn_mergeinfo_intersect2(mergeinfo1,mergeinfo2,consider_inheritance,result_pool,scratch_pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_intersect2" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_intersect2" "', argument " "3"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg3 = (svn_mergeinfo_t)(argp3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_mergeinfo_intersect2" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_intersect2(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_intersect2 arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_intersect2 is not implemented yet");
      
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_intersect) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    svn_mergeinfo_t arg3 = (svn_mergeinfo_t) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_mergeinfo_intersect(mergeinfo1,mergeinfo2,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_intersect" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_intersect" "', argument " "3"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg3 = (svn_mergeinfo_t)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_intersect(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_intersect arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_intersect is not implemented yet");
      
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_intersect) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    apr_array_header_t *arg3 = (apr_array_header_t *) 0 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_rangelist_intersect(rangelist1,rangelist2,consider_inheritance,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_rangelist_intersect" "', argument " "2"" of type '" "apr_array_header_t const *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_rangelist_intersect" "', argument " "3"" of type '" "apr_array_header_t const *""'"); 
    }
    arg3 = (apr_array_header_t *)(argp3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_rangelist_intersect" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_intersect(arg1,(apr_array_header_t const *)arg2,(apr_array_header_t const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_intersect arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_intersect is not implemented yet");
      
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_to_string) {
  {
    svn_string_t **arg1 = (svn_string_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_rangelist_to_string(rangelist,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_rangelist_to_string" "', argument " "2"" of type '" "apr_array_header_t const *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_to_string(arg1,(apr_array_header_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_inheritable2) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    svn_revnum_t arg3 ;
    svn_revnum_t arg4 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    long val3 ;
    int ecode3 = 0 ;
    long val4 ;
    int ecode4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 6)) {
      SWIG_croak("Usage: svn_rangelist_inheritable2(rangelist,start,end,inheritable,result_pool,scratch_pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_rangelist_inheritable2" "', argument " "2"" of type '" "apr_array_header_t const *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    ecode3 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_rangelist_inheritable2" "', argument " "3"" of type '" "svn_revnum_t""'");
    } 
    arg3 = (svn_revnum_t)(val3);
    ecode4 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_rangelist_inheritable2" "', argument " "4"" of type '" "svn_revnum_t""'");
    } 
    arg4 = (svn_revnum_t)(val4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_rangelist_inheritable2" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 4) {
      
    }
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_inheritable2(arg1,(apr_array_header_t const *)arg2,arg3,arg4,arg5,arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_inheritable2 arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_inheritable2 is not implemented yet");
      
    }
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_inheritable) {
  {
    apr_array_header_t **arg1 = (apr_array_header_t **) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    svn_revnum_t arg3 ;
    svn_revnum_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_array_header_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    long val3 ;
    int ecode3 = 0 ;
    long val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_rangelist_inheritable(rangelist,start,end,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_rangelist_inheritable" "', argument " "2"" of type '" "apr_array_header_t const *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    ecode3 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_rangelist_inheritable" "', argument " "3"" of type '" "svn_revnum_t""'");
    } 
    arg3 = (svn_revnum_t)(val3);
    ecode4 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_rangelist_inheritable" "', argument " "4"" of type '" "svn_revnum_t""'");
    } 
    arg4 = (svn_revnum_t)(val4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_rangelist_inheritable(arg1,(apr_array_header_t const *)arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_rangelist_inheritable arg 1 (apr_array_header_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_rangelist_inheritable is not implemented yet");
      
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_inheritable2) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    char *arg3 = (char *) 0 ;
    svn_revnum_t arg4 ;
    svn_revnum_t arg5 ;
    svn_boolean_t arg6 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    long val4 ;
    int ecode4 = 0 ;
    long val5 ;
    int ecode5 = 0 ;
    int val6 ;
    int ecode6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 5) || (items > 7)) {
      SWIG_croak("Usage: svn_mergeinfo_inheritable2(mergeinfo,path,start,end,inheritable,result_pool,scratch_pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_inheritable2" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_inheritable2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_mergeinfo_inheritable2" "', argument " "4"" of type '" "svn_revnum_t""'");
    } 
    arg4 = (svn_revnum_t)(val4);
    ecode5 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_mergeinfo_inheritable2" "', argument " "5"" of type '" "svn_revnum_t""'");
    } 
    arg5 = (svn_revnum_t)(val5);
    ecode6 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(4), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_mergeinfo_inheritable2" "', argument " "6"" of type '" "svn_boolean_t""'");
    } 
    arg6 = (svn_boolean_t)(val6);
    if (items > 5) {
      
    }
    if (items > 6) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_inheritable2(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_inheritable2 arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_inheritable2 is not implemented yet");
      
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_inheritable) {
  {
    svn_mergeinfo_t *arg1 = (svn_mergeinfo_t *) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    char *arg3 = (char *) 0 ;
    svn_revnum_t arg4 ;
    svn_revnum_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_mergeinfo_t temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    long val4 ;
    int ecode4 = 0 ;
    long val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_mergeinfo_inheritable(mergeinfo,path,start,end,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_inheritable" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_mergeinfo_inheritable" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_mergeinfo_inheritable" "', argument " "4"" of type '" "svn_revnum_t""'");
    } 
    arg4 = (svn_revnum_t)(val4);
    ecode5 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_mergeinfo_inheritable" "', argument " "5"" of type '" "svn_revnum_t""'");
    } 
    arg5 = (svn_revnum_t)(val5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_inheritable(arg1,arg2,(char const *)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_mergeinfo_inheritable arg 1 (svn_mergeinfo_t *) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_mergeinfo_inheritable is not implemented yet");
      
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_to_string) {
  {
    svn_string_t **arg1 = (svn_string_t **) 0 ;
    svn_mergeinfo_t arg2 = (svn_mergeinfo_t) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_mergeinfo_to_string(mergeinput,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_mergeinfo_to_string" "', argument " "2"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg2 = (svn_mergeinfo_t)(argp2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_mergeinfo_to_string(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_catalog_dup) {
  {
    svn_mergeinfo_catalog_t arg1 = (svn_mergeinfo_catalog_t) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_mergeinfo_catalog_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_mergeinfo_catalog_dup(mergeinfo_catalog,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_mergeinfo_catalog_dup" "', argument " "1"" of type '" "svn_mergeinfo_catalog_t""'"); 
    }
    arg1 = (svn_mergeinfo_catalog_t)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_mergeinfo_catalog_t)svn_mergeinfo_catalog_dup(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_mergeinfo_dup) {
  {
    svn_mergeinfo_t arg1 = (svn_mergeinfo_t) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_mergeinfo_t result;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_mergeinfo_dup(mergeinfo,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_hash_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_mergeinfo_dup" "', argument " "1"" of type '" "svn_mergeinfo_t""'"); 
    }
    arg1 = (svn_mergeinfo_t)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_mergeinfo_t)svn_mergeinfo_dup(arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_rangelist_dup) {
  {
    apr_array_header_t *arg1 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_array_header_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_rangelist_dup(rangelist,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_rangelist_dup" "', argument " "1"" of type '" "apr_array_header_t const *""'"); 
    }
    arg1 = (apr_array_header_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (apr_array_header_t *)svn_rangelist_dup((apr_array_header_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_array_header_t, 0 | 0); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_inheritance_to_word) {
  {
    svn_mergeinfo_inheritance_t arg1 ;
    int val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_inheritance_to_word(inherit);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_inheritance_to_word" "', argument " "1"" of type '" "svn_mergeinfo_inheritance_t""'");
    } 
    arg1 = (svn_mergeinfo_inheritance_t)(val1);
    {
      result = (char *)svn_inheritance_to_word(arg1);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_inheritance_from_word) {
  {
    char *arg1 = (char *) 0 ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    svn_mergeinfo_inheritance_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_inheritance_from_word(word);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_inheritance_from_word" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    {
      result = (svn_mergeinfo_inheritance_t)svn_inheritance_from_word((char const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_kind_set) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    svn_node_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent2_t_kind_set(self,kind);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_kind_set" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent2_t_kind_set" "', argument " "2"" of type '" "svn_node_kind_t""'");
    } 
    arg2 = (svn_node_kind_t)(val2);
    if (arg1) (arg1)->kind = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_kind_get) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_node_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent2_t_kind_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_kind_get" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    result = (svn_node_kind_t) ((arg1)->kind);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_special_set) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent2_t_special_set(self,special);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_special_set" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent2_t_special_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->special = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_special_get) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent2_t_special_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_special_get" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->special);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_filesize_set) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    svn_filesize_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent2_t_filesize_set(self,filesize);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_filesize_set" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent2_t_filesize_set" "', argument " "2"" of type '" "svn_filesize_t""'");
    } 
    arg2 = (svn_filesize_t)(val2);
    if (arg1) (arg1)->filesize = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_filesize_get) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_filesize_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent2_t_filesize_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_filesize_get" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    result =  ((arg1)->filesize);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_mtime_set) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    apr_time_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent2_t_mtime_set(self,mtime);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_mtime_set" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent2_t_mtime_set" "', argument " "2"" of type '" "apr_time_t""'");
    } 
    arg2 = (apr_time_t)(val2);
    if (arg1) (arg1)->mtime = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_t_mtime_get) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_time_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent2_t_mtime_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_t_mtime_get" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    result =  ((arg1)->mtime);
    {
      char temp[256];
      sprintf(temp, "%" APR_INT64_T_FMT, (apr_int64_t) result);
      ST(argvi) = sv_newmortal();
      sv_setpv((SV*)ST(argvi++), temp);
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_io_dirent2_t) {
  {
    int argvi = 0;
    svn_io_dirent2_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_io_dirent2_t();");
    }
    {
      result = (svn_io_dirent2_t *)calloc(1, sizeof(svn_io_dirent2_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_io_dirent2_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_io_dirent2_t) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_io_dirent2_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_io_dirent2_t" "', argument " "1"" of type '" "svn_io_dirent2_t *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_io_dirent2_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent2_create(result_pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_io_dirent2_t *)svn_io_dirent2_create(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_io_dirent2_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent2_dup) {
  {
    svn_io_dirent2_t *arg1 = (svn_io_dirent2_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_io_dirent2_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent2_dup(item,result_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent2_dup" "', argument " "1"" of type '" "svn_io_dirent2_t const *""'"); 
    }
    arg1 = (svn_io_dirent2_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_io_dirent2_t *)svn_io_dirent2_dup((struct svn_io_dirent2_t const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_io_dirent2_t, 0 | SWIG_SHADOW); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent_t_kind_set) {
  {
    svn_io_dirent_t *arg1 = (svn_io_dirent_t *) 0 ;
    svn_node_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent_t_kind_set(self,kind);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent_t_kind_set" "', argument " "1"" of type '" "svn_io_dirent_t *""'"); 
    }
    arg1 = (svn_io_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent_t_kind_set" "', argument " "2"" of type '" "svn_node_kind_t""'");
    } 
    arg2 = (svn_node_kind_t)(val2);
    if (arg1) (arg1)->kind = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent_t_kind_get) {
  {
    svn_io_dirent_t *arg1 = (svn_io_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_node_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent_t_kind_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent_t_kind_get" "', argument " "1"" of type '" "svn_io_dirent_t *""'"); 
    }
    arg1 = (svn_io_dirent_t *)(argp1);
    result = (svn_node_kind_t) ((arg1)->kind);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent_t_special_set) {
  {
    svn_io_dirent_t *arg1 = (svn_io_dirent_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_dirent_t_special_set(self,special);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent_t_special_set" "', argument " "1"" of type '" "svn_io_dirent_t *""'"); 
    }
    arg1 = (svn_io_dirent_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dirent_t_special_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->special = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dirent_t_special_get) {
  {
    svn_io_dirent_t *arg1 = (svn_io_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dirent_t_special_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dirent_t_special_get" "', argument " "1"" of type '" "svn_io_dirent_t *""'"); 
    }
    arg1 = (svn_io_dirent_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->special);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_io_dirent_t) {
  {
    int argvi = 0;
    svn_io_dirent_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_io_dirent_t();");
    }
    {
      result = (svn_io_dirent_t *)calloc(1, sizeof(svn_io_dirent_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_io_dirent_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_io_dirent_t) {
  {
    svn_io_dirent_t *arg1 = (svn_io_dirent_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_io_dirent_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_io_dirent_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_io_dirent_t" "', argument " "1"" of type '" "svn_io_dirent_t *""'"); 
    }
    arg1 = (svn_io_dirent_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_open_uniquely_named) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    svn_io_file_del_t arg6 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int val6 ;
    int ecode6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 4) || (items > 6)) {
      SWIG_croak("Usage: svn_io_open_uniquely_named(dirpath,filename,suffix,delete_when,result_pool,scratch_pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_open_uniquely_named" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(1), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_open_uniquely_named" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(2), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_io_open_uniquely_named" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    ecode6 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_io_open_uniquely_named" "', argument " "6"" of type '" "svn_io_file_del_t""'");
    } 
    arg6 = (svn_io_file_del_t)(val6);
    if (items > 4) {
      
    }
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_io_open_uniquely_named(arg1,(char const **)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_open_unique_file3) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    svn_io_file_del_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 2) || (items > 4)) {
      SWIG_croak("Usage: svn_io_open_unique_file3(dirpath,delete_when,result_pool,scratch_pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_open_unique_file3" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_io_open_unique_file3" "', argument " "4"" of type '" "svn_io_file_del_t""'");
    } 
    arg4 = (svn_io_file_del_t)(val4);
    if (items > 2) {
      
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_open_unique_file3(arg1,(char const **)arg2,(char const *)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_open_unique_file2) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_io_file_del_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_io_open_unique_file2(path,suffix,delete_when,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_open_unique_file2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(1), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_open_unique_file2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_io_open_unique_file2" "', argument " "5"" of type '" "svn_io_file_del_t""'");
    } 
    arg5 = (svn_io_file_del_t)(val5);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_open_unique_file2(arg1,(char const **)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_open_unique_file) {
  {
    apr_file_t **arg1 = (apr_file_t **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_file_t *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_io_open_unique_file(path,suffix,delete_on_close,pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_open_unique_file" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(1), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_open_unique_file" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_io_open_unique_file" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_open_unique_file(arg1,(char const **)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_apr_file_t, 0); argvi++  ;
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_copy_perms) {
  {
    char *arg1 = (char *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_copy_perms(src,dst,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_copy_perms" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_copy_perms" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_copy_perms((char const *)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_sleep_for_timestamps) {
  {
    char *arg1 = (char *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_sleep_for_timestamps(path,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_sleep_for_timestamps" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    if (items > 1) {
      
    }
    {
      svn_io_sleep_for_timestamps((char const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_checksum2) {
  {
    svn_checksum_t **arg1 = (svn_checksum_t **) 0 ;
    char *arg2 = (char *) 0 ;
    svn_checksum_kind_t arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_checksum_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    void *argp3 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_file_checksum2(file,kind,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_file_checksum2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      res3 = SWIG_ConvertPtr(ST(1), &argp3, SWIGTYPE_p_svn_checksum_kind_t,  0 );
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_file_checksum2" "', argument " "3"" of type '" "svn_checksum_kind_t""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "svn_io_file_checksum2" "', argument " "3"" of type '" "svn_checksum_kind_t""'");
      } else {
        arg3 = *((svn_checksum_kind_t *)(argp3));
      }
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_checksum2(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_io_file_checksum2 arg 1 (svn_checksum_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_io_file_checksum2 is not implemented yet");
      
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_checksum) {
  {
    unsigned char *arg1 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    unsigned char temp1[APR_MD5_DIGESTSIZE] ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_file_checksum(file,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_file_checksum" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_checksum(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,59,%append_output@*/ if (argvi >= items) EXTEND(sp,1); /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,56,%set_output@*/ ST(argvi) = sv_2mortal(newSVpv(svn_md5_digest_to_cstring(arg1,
            _global_pool),
          0)); argvi++ /*@SWIG@*/
      
      /*@SWIG@*/
      
      ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_files_contents_same_p) {
  {
    svn_boolean_t *arg1 = (svn_boolean_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_files_contents_same_p(file1,file2,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_files_contents_same_p" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_files_contents_same_p" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_files_contents_same_p(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_set_skip) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_skip_fn_t arg2 = (svn_stream_skip_fn_t) 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_set_skip(stream,skip_fn);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_size_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_set_skip" "', argument " "2"" of type '" "svn_stream_skip_fn_t""'"); 
      }
    }
    {
      svn_stream_set_skip(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_set_mark) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_mark_fn_t arg2 = (svn_stream_mark_fn_t) 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_set_mark(stream,mark_fn);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_set_mark" "', argument " "2"" of type '" "svn_stream_mark_fn_t""'"); 
      }
    }
    {
      svn_stream_set_mark(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_set_seek) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_seek_fn_t arg2 = (svn_stream_seek_fn_t) 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_set_seek(stream,seek_fn);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_set_seek" "', argument " "2"" of type '" "svn_stream_seek_fn_t""'"); 
      }
    }
    {
      svn_stream_set_seek(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_empty) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_empty(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_empty(arg1);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_disown) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_disown(stream,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    if (items > 1) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_disown(arg1,arg2);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_open_readonly) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_open_readonly(path,result_pool,scratch_pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_open_readonly" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_open_readonly(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_open_writable) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_open_writable(path,result_pool,scratch_pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_open_writable" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_open_writable(arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_open_unique) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    char **arg2 = (char **) 0 ;
    char *arg3 = (char *) 0 ;
    svn_io_file_del_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    char *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    arg2 = &temp2;
    if ((items < 2) || (items > 4)) {
      SWIG_croak("Usage: svn_stream_open_unique(dirpath,delete_when,result_pool,scratch_pool);");
    }
    res3 = SWIG_AsCharPtrAndSize(ST(0), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_stream_open_unique" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_stream_open_unique" "', argument " "4"" of type '" "svn_io_file_del_t""'");
    } 
    arg4 = (svn_io_file_del_t)(val4);
    if (items > 2) {
      
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_stream_open_unique(arg1,(char const **)arg2,(char const *)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    {
      if (*arg2 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg2, 0)); argvi++  ;
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_from_aprfile2) {
  {
    apr_file_t *arg1 = (apr_file_t *) 0 ;
    svn_boolean_t arg2 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_from_aprfile2(file,disown,pool);");
    }
    {
      arg1 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_stream_from_aprfile2" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (items > 2) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_from_aprfile2(arg1,arg2,arg3);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_from_aprfile) {
  {
    apr_file_t *arg1 = (apr_file_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_from_aprfile(file,pool);");
    }
    {
      arg1 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    if (items > 1) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_from_aprfile(arg1,arg2);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_for_stdin) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_for_stdin(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_error_t *)svn_stream_for_stdin(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_for_stderr) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_for_stderr(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_error_t *)svn_stream_for_stderr(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_for_stdout) {
  {
    svn_stream_t **arg1 = (svn_stream_t **) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_for_stdout(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_error_t *)svn_stream_for_stdout(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_from_stream(*arg1); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_from_stringbuf) {
  {
    svn_stringbuf_t *arg1 = (svn_stringbuf_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_from_stringbuf(str,pool);");
    }
    {
      apr_size_t len;
      char *buf;
      
      if (!SvOK(ST(0))) {
        arg1 = NULL;
      } else if (SvPOK(ST(0))) {
        buf = SvPV(ST(0), len);
        /* Another case of ugly pool handling, this should use the current
                   default pool, or make a new one if it doesn't exist yet */
        arg1 = svn_stringbuf_ncreate(buf,len,
          svn_swig_pl_make_pool ((SV *)NULL));
      } else {
        croak("Not a string");
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_from_stringbuf(arg1,arg2);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_from_string) {
  {
    svn_string_t *arg1 = (svn_string_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t value1 ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_from_string(str,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value1.data = SvPV(ST(0), value1.len);
        arg1 = &value1;
      }
      else {
        arg1 = NULL;
      }
    }
    if (items > 1) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_from_string((struct svn_string_t const *)arg1,arg2);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_compressed) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_compressed(stream,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    if (items > 1) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_compressed(arg1,arg2);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_checksummed2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_checksum_t **arg2 = (svn_checksum_t **) 0 ;
    svn_checksum_t **arg3 = (svn_checksum_t **) 0 ;
    svn_checksum_kind_t arg4 ;
    svn_boolean_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_checksum_t *temp2 ;
    svn_checksum_t *temp3 ;
    void *argp4 ;
    int res4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_stream_checksummed2(stream,checksum_kind,read_all,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      res4 = SWIG_ConvertPtr(ST(1), &argp4, SWIGTYPE_p_svn_checksum_kind_t,  0 );
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_stream_checksummed2" "', argument " "4"" of type '" "svn_checksum_kind_t""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "svn_stream_checksummed2" "', argument " "4"" of type '" "svn_checksum_kind_t""'");
      } else {
        arg4 = *((svn_checksum_kind_t *)(argp4));
      }
    }
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_stream_checksummed2" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    if (items > 3) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_checksummed2(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    {
      /* FIXME: Missing argout typemap: svn_stream_checksummed2 arg 2 (svn_checksum_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_stream_checksummed2 is not implemented yet");
      
    }
    {
      /* FIXME: Missing argout typemap: svn_stream_checksummed2 arg 3 (svn_checksum_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_stream_checksummed2 is not implemented yet");
      
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_read) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_size_t *arg3 = (apr_size_t *) 0 ;
    apr_size_t temp2 ;
    int argvi = 0;
    SV * _saved[1] ;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_read(stream,buffer,len);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      temp2 = SvIV(ST(1));
      arg2 = malloc(temp2);
      arg3 = (apr_size_t *)&temp2;
    }
    _saved[0] = ST(1);
    {
      result = (svn_error_t *)svn_stream_read(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn(arg2, *arg3)); argvi++  ;
      free(arg2);
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_skip) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    apr_size_t arg2 ;
    unsigned long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_skip(stream,len);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    ecode2 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_stream_skip" "', argument " "2"" of type '" "apr_size_t""'");
    } 
    arg2 = (apr_size_t)(val2);
    {
      result = (svn_error_t *)svn_stream_skip(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_write) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_size_t *arg3 = (apr_size_t *) 0 ;
    apr_size_t temp2 ;
    int argvi = 0;
    SV * _saved[1] ;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_write(stream,data,len);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      arg2 = SvPV(ST(1), temp2);
      arg3 = (apr_size_t *)&temp2;
    }
    _saved[0] = ST(1);
    {
      result = (svn_error_t *)svn_stream_write(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSViv(*arg3)); argvi++  ;
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_close) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_close(stream);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      result = (svn_error_t *)svn_stream_close(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_reset) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_reset(stream);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      result = (svn_error_t *)svn_stream_reset(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_supports_mark) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_stream_supports_mark(stream);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      result = (svn_boolean_t)svn_stream_supports_mark(arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_mark) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_mark_t **arg2 = (svn_stream_mark_t **) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stream_mark_t *temp2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_mark(stream,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_stream_mark(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_stream_mark arg 2 (svn_stream_mark_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_stream_mark is not implemented yet");
      
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_seek) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_mark_t *arg2 = (svn_stream_mark_t *) 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_stream_seek(stream,mark);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_stream_mark_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_seek" "', argument " "2"" of type '" "svn_stream_mark_t const *""'"); 
    }
    arg2 = (svn_stream_mark_t *)(argp2);
    {
      result = (svn_error_t *)svn_stream_seek(arg1,(struct svn_stream_mark_t const *)arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_tee) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_stream_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_tee(out1,out2,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(1));
    }
    if (items > 2) {
      
    }
    {
      result = (svn_stream_t *)svn_stream_tee(arg1,arg2,arg3);
      
      
      
    }
    {
      ST(argvi) = svn_swig_pl_from_stream (result);
      argvi++;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_readline) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stringbuf_t **arg2 = (svn_stringbuf_t **) 0 ;
    char *arg3 = (char *) 0 ;
    svn_boolean_t *arg4 = (svn_boolean_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    svn_boolean_t temp4 ;
    int res4 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg4 = &temp4;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_readline(stream,eol,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_stream_readline" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_readline(arg1,arg2,(char const *)arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg2)->data, (*arg2)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_copy3) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    svn_cancel_func_t arg3 = (svn_cancel_func_t) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_stream_copy3(from,to,cancel_func,cancel_baton,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(1));
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(2), (void**)(&arg3), SWIGTYPE_p_f_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_copy3" "', argument " "3"" of type '" "svn_cancel_func_t""'"); 
      }
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_stream_copy3" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_stream_copy3(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_copy2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    svn_cancel_func_t arg3 = (svn_cancel_func_t) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_stream_copy2(from,to,cancel_func,cancel_baton,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(1));
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(2), (void**)(&arg3), SWIGTYPE_p_f_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_copy2" "', argument " "3"" of type '" "svn_cancel_func_t""'"); 
      }
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_stream_copy2" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_stream_copy2(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_copy) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_copy(from,to,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(1));
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_copy(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_contents_same2) {
  {
    svn_boolean_t *arg1 = (svn_boolean_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    svn_stream_t *arg3 = (svn_stream_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_contents_same2(stream1,stream2,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg3, ST(1));
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_contents_same2(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_contents_same) {
  {
    svn_boolean_t *arg1 = (svn_boolean_t *) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    svn_stream_t *arg3 = (svn_stream_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_boolean_t temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_contents_same(stream1,stream2,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(0));
    }
    {
      svn_swig_pl_make_stream (&arg3, ST(1));
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_contents_same(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_string_from_stream) {
  {
    svn_string_t **arg1 = (svn_string_t **) 0 ;
    svn_stream_t *arg2 = (svn_stream_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_string_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_string_from_stream(stream,result_pool,scratch_pool);");
    }
    {
      svn_swig_pl_make_stream (&arg2, ST(0));
    }
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_string_from_stream(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stringbuf_from_file2) {
  {
    svn_stringbuf_t **arg1 = (svn_stringbuf_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stringbuf_from_file2(filename,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stringbuf_from_file2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_stringbuf_from_file2(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stringbuf_from_file) {
  {
    svn_stringbuf_t **arg1 = (svn_stringbuf_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stringbuf_from_file(filename,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stringbuf_from_file" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_stringbuf_from_file(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stringbuf_from_aprfile) {
  {
    svn_stringbuf_t **arg1 = (svn_stringbuf_t **) 0 ;
    apr_file_t *arg2 = (apr_file_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_stringbuf_t *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_stringbuf_from_aprfile(file,pool);");
    }
    {
      arg2 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_stringbuf_from_aprfile(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg1)->data, (*arg1)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_remove_file2) {
  {
    char *arg1 = (char *) 0 ;
    svn_boolean_t arg2 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_remove_file2(path,ignore_enoent,scratch_pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_remove_file2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_remove_file2" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_remove_file2((char const *)arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_remove_dir2) {
  {
    char *arg1 = (char *) 0 ;
    svn_boolean_t arg2 ;
    svn_cancel_func_t arg3 = (svn_cancel_func_t) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_io_remove_dir2(path,ignore_enoent,cancel_func,cancel_baton,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_remove_dir2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_remove_dir2" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    {
      int res = SWIG_ConvertFunctionPtr(ST(2), (void**)(&arg3), SWIGTYPE_p_f_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_io_remove_dir2" "', argument " "3"" of type '" "svn_cancel_func_t""'"); 
      }
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_remove_dir2" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_io_remove_dir2((char const *)arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_get_dirents3) {
  {
    apr_hash_t **arg1 = (apr_hash_t **) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_hash_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 4)) {
      SWIG_croak("Usage: svn_io_get_dirents3(path,only_check_type,result_pool,scratch_pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_get_dirents3" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_io_get_dirents3" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    if (items > 2) {
      
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_get_dirents3(arg1,(char const *)arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = svn_swig_pl_convert_hash(*arg1, SWIGTYPE_p_svn_dirent_t); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_stat_dirent) {
  {
    svn_io_dirent2_t **arg1 = (svn_io_dirent2_t **) 0 ;
    char *arg2 = (char *) 0 ;
    svn_boolean_t arg3 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_io_dirent2_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 4)) {
      SWIG_croak("Usage: svn_io_stat_dirent(path,ignore_enoent,result_pool,scratch_pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_stat_dirent" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_io_stat_dirent" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    if (items > 2) {
      
    }
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_stat_dirent((struct svn_io_dirent2_t const **)arg1,(char const *)arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_io_stat_dirent arg 1 (svn_io_dirent2_t const **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_io_stat_dirent is not implemented yet");
      
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dir_walk2) {
  {
    char *arg1 = (char *) 0 ;
    apr_int32_t arg2 ;
    svn_io_walk_func_t arg3 = (svn_io_walk_func_t) 0 ;
    void *arg4 = (void *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    int res4 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_io_dir_walk2(dirname,wanted,walk_func,walk_baton,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dir_walk2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    ecode2 = SWIG_AsVal_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_dir_walk2" "', argument " "2"" of type '" "apr_int32_t""'");
    } 
    arg2 = (apr_int32_t)(val2);
    {
      int res = SWIG_ConvertFunctionPtr(ST(2), (void**)(&arg3), SWIGTYPE_p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_io_dir_walk2" "', argument " "3"" of type '" "svn_io_walk_func_t""'"); 
      }
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_dir_walk2" "', argument " "4"" of type '" "void *""'"); 
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_io_dir_walk2((char const *)arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_start_cmd2) {
  {
    apr_proc_t *arg1 = (apr_proc_t *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char **arg4 = (char **) 0 ;
    svn_boolean_t arg5 ;
    svn_boolean_t arg6 ;
    apr_file_t *arg7 = (apr_file_t *) 0 ;
    svn_boolean_t arg8 ;
    apr_file_t *arg9 = (apr_file_t *) 0 ;
    svn_boolean_t arg10 ;
    apr_file_t *arg11 = (apr_file_t *) 0 ;
    apr_pool_t *arg12 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int val6 ;
    int ecode6 = 0 ;
    int val8 ;
    int ecode8 = 0 ;
    int val10 ;
    int ecode10 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg12 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 11) || (items > 12)) {
      SWIG_croak("Usage: svn_io_start_cmd2(cmd_proc,path,cmd,args,inherit,infile_pipe,infile,outfile_pipe,outfile,errfile_pipe,errfile,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_proc_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_start_cmd2" "', argument " "1"" of type '" "apr_proc_t *""'"); 
    }
    arg1 = (apr_proc_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_start_cmd2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_start_cmd2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(3), &argp4,SWIGTYPE_p_p_char, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_start_cmd2" "', argument " "4"" of type '" "char const *const *""'"); 
    }
    arg4 = (char **)(argp4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_io_start_cmd2" "', argument " "5"" of type '" "svn_boolean_t""'");
    } 
    arg5 = (svn_boolean_t)(val5);
    ecode6 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_io_start_cmd2" "', argument " "6"" of type '" "svn_boolean_t""'");
    } 
    arg6 = (svn_boolean_t)(val6);
    {
      arg7 = svn_swig_pl_make_file(ST(6), _global_pool);
    }
    ecode8 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_io_start_cmd2" "', argument " "8"" of type '" "svn_boolean_t""'");
    } 
    arg8 = (svn_boolean_t)(val8);
    {
      arg9 = svn_swig_pl_make_file(ST(8), _global_pool);
    }
    ecode10 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "svn_io_start_cmd2" "', argument " "10"" of type '" "svn_boolean_t""'");
    } 
    arg10 = (svn_boolean_t)(val10);
    {
      arg11 = svn_swig_pl_make_file(ST(10), _global_pool);
    }
    if (items > 11) {
      
    }
    {
      result = (svn_error_t *)svn_io_start_cmd2(arg1,(char const *)arg2,(char const *)arg3,(char const *const *)arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_run_diff2) {
  {
    char *arg1 = (char *) 0 ;
    char **arg2 = (char **) 0 ;
    int arg3 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    int *arg8 = (int *) 0 ;
    apr_file_t *arg9 = (apr_file_t *) 0 ;
    apr_file_t *arg10 = (apr_file_t *) 0 ;
    char *arg11 = (char *) 0 ;
    apr_pool_t *arg12 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res1 ;
    char *buf1 = 0 ;
    int alloc1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int temp8 ;
    int res8 = SWIG_TMPOBJ ;
    int res11 ;
    char *buf11 = 0 ;
    int alloc11 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg12 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg8 = &temp8;
    if ((items < 10) || (items > 11)) {
      SWIG_croak("Usage: svn_io_run_diff2(dir,user_args,num_user_args,label1,label2,from,to,outfile,errfile,diff_cmd,pool);");
    }
    res1 = SWIG_AsCharPtrAndSize(ST(0), &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_run_diff2" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_p_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_run_diff2" "', argument " "2"" of type '" "char const *const *""'"); 
    }
    arg2 = (char **)(argp2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_io_run_diff2" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_run_diff2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_io_run_diff2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_io_run_diff2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_io_run_diff2" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    {
      arg9 = svn_swig_pl_make_file(ST(7), _global_pool);
    }
    {
      arg10 = svn_swig_pl_make_file(ST(8), _global_pool);
    }
    res11 = SWIG_AsCharPtrAndSize(ST(9), &buf11, NULL, &alloc11);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "svn_io_run_diff2" "', argument " "11"" of type '" "char const *""'");
    }
    arg11 = (char *)(buf11);
    if (items > 10) {
      
    }
    {
      result = (svn_error_t *)svn_io_run_diff2((char const *)arg1,(char const *const *)arg2,arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9,arg10,(char const *)arg11,arg12);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res8)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg8)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    
    
    if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
    
    XSRETURN(argvi);
  fail:
    if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    
    
    if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_run_diff3_3) {
  {
    int *arg1 = (int *) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    apr_file_t *arg9 = (apr_file_t *) 0 ;
    char *arg10 = (char *) 0 ;
    apr_array_header_t *arg11 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg12 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int temp1 ;
    int res1 = SWIG_TMPOBJ ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int res10 ;
    char *buf10 = 0 ;
    int alloc10 = 0 ;
    void *argp11 = 0 ;
    int res11 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg12 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 10) || (items > 11)) {
      SWIG_croak("Usage: svn_io_run_diff3_3(dir,mine,older,yours,mine_label,older_label,yours_label,merged,diff3_cmd,user_args,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_run_diff3_3" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_run_diff3_3" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_run_diff3_3" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_io_run_diff3_3" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(4), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_io_run_diff3_3" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(5), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_io_run_diff3_3" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(6), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_io_run_diff3_3" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    {
      arg9 = svn_swig_pl_make_file(ST(7), _global_pool);
    }
    res10 = SWIG_AsCharPtrAndSize(ST(8), &buf10, NULL, &alloc10);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "svn_io_run_diff3_3" "', argument " "10"" of type '" "char const *""'");
    }
    arg10 = (char *)(buf10);
    res11 = SWIG_ConvertPtr(ST(9), &argp11,SWIGTYPE_p_apr_array_header_t, 0 |  0 );
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "svn_io_run_diff3_3" "', argument " "11"" of type '" "apr_array_header_t const *""'"); 
    }
    arg11 = (apr_array_header_t *)(argp11);
    if (items > 10) {
      
    }
    {
      result = (svn_error_t *)svn_io_run_diff3_3(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,arg9,(char const *)arg10,(apr_array_header_t const *)arg11,arg12);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res1)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg1)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res1) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg1), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    
    if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    
    if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_parse_mimetypes_file) {
  {
    apr_hash_t **arg1 = (apr_hash_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    apr_hash_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_parse_mimetypes_file(mimetypes_file,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_parse_mimetypes_file" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_io_parse_mimetypes_file(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_io_parse_mimetypes_file arg 1 (apr_hash_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_io_parse_mimetypes_file is not implemented yet");
      
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_detect_mimetype2) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_hash_t *arg3 = (apr_hash_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_detect_mimetype2(file,mimetype_map,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_detect_mimetype2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      arg3 = svn_swig_pl_strings_to_hash(ST(1), _global_pool);
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_detect_mimetype2((char const **)arg1,(char const *)arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_detect_mimetype) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_detect_mimetype(file,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_detect_mimetype" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_io_detect_mimetype((char const **)arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_is_binary_data) {
  {
    void *arg1 = (void *) 0 ;
    apr_size_t arg2 ;
    int res1 ;
    unsigned long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_io_is_binary_data(buf,len);");
    }
    res1 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg1), 0, 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_is_binary_data" "', argument " "1"" of type '" "void const *""'"); 
    }
    ecode2 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_is_binary_data" "', argument " "2"" of type '" "apr_size_t""'");
    } 
    arg2 = (apr_size_t)(val2);
    {
      result = (svn_boolean_t)svn_io_is_binary_data((void const *)arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_putc) {
  {
    char arg1 ;
    apr_file_t *arg2 = (apr_file_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char val1 ;
    int ecode1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_file_putc(ch,file,pool);");
    }
    ecode1 = SWIG_AsVal_char SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_io_file_putc" "', argument " "1"" of type '" "char""'");
    } 
    arg1 = (char)(val1);
    {
      arg2 = svn_swig_pl_make_file(ST(1), _global_pool);
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_putc(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_read_full2) {
  {
    apr_file_t *arg1 = (apr_file_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_size_t arg3 ;
    apr_size_t *arg4 = (apr_size_t *) 0 ;
    svn_boolean_t *arg5 = (svn_boolean_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    unsigned long val3 ;
    int ecode3 = 0 ;
    apr_size_t temp4 ;
    int res4 = SWIG_TMPOBJ ;
    svn_boolean_t temp5 ;
    int res5 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg4 = &temp4;
    arg5 = &temp5;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_io_file_read_full2(file,buf,nbytes,pool);");
    }
    {
      arg1 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_file_read_full2" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_io_file_read_full2" "', argument " "3"" of type '" "apr_size_t""'");
    } 
    arg3 = (apr_size_t)(val3);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_read_full2(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_apr_size_t, new_flags); argvi++  ;
    }
    if (SWIG_IsTmpObj(res5)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg5)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_write_unique) {
  {
    char **arg1 = (char **) 0 ;
    char *arg2 = (char *) 0 ;
    void *arg3 = (void *) 0 ;
    apr_size_t arg4 ;
    svn_io_file_del_t arg5 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    unsigned long val4 ;
    int ecode4 = 0 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_io_write_unique(dirpath,buf,nbytes,delete_when,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_write_unique" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_write_unique" "', argument " "3"" of type '" "void const *""'"); 
    }
    ecode4 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_io_write_unique" "', argument " "4"" of type '" "apr_size_t""'");
    } 
    arg4 = (apr_size_t)(val4);
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_io_write_unique" "', argument " "5"" of type '" "svn_io_file_del_t""'");
    } 
    arg5 = (svn_io_file_del_t)(val5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_io_write_unique((char const **)arg1,(char const *)arg2,(void const *)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_trunc) {
  {
    apr_file_t *arg1 = (apr_file_t *) 0 ;
    apr_off_t arg2 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    long long val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_io_file_trunc(file,offset,pool);");
    }
    {
      arg1 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    ecode2 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_io_file_trunc" "', argument " "2"" of type '" "apr_off_t""'");
    } 
    arg2 = (apr_off_t)(val2);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_trunc(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_dir_close) {
  {
    apr_dir_t *arg1 = (apr_dir_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_io_dir_close(thedir);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_apr_dir_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_io_dir_close" "', argument " "1"" of type '" "apr_dir_t *""'"); 
    }
    arg1 = (apr_dir_t *)(argp1);
    {
      result = (svn_error_t *)svn_io_dir_close(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_file_name_get) {
  {
    char **arg1 = (char **) 0 ;
    apr_file_t *arg2 = (apr_file_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    char *temp1 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_io_file_name_get(file,pool);");
    }
    {
      arg2 = svn_swig_pl_make_file(ST(0), _global_pool);
    }
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_io_file_name_get((char const **)arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg1 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg1, 0)); argvi++  ;
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_read_invoke_fn) {
  {
    svn_read_fn_t arg1 = (svn_read_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_size_t *arg4 = (apr_size_t *) 0 ;
    int res2 ;
    apr_size_t temp3 ;
    int argvi = 0;
    SV * _saved[1] ;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_read_invoke_fn(_obj,baton,buffer,len);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_char_p_apr_size_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_read_invoke_fn" "', argument " "1"" of type '" "svn_read_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_read_invoke_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      temp3 = SvIV(ST(2));
      arg3 = malloc(temp3);
      arg4 = (apr_size_t *)&temp3;
    }
    _saved[0] = ST(2);
    {
      result = (svn_error_t *)svn_read_invoke_fn(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn(arg3, *arg4)); argvi++  ;
      free(arg3);
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_invoke_skip_fn) {
  {
    svn_stream_skip_fn_t arg1 = (svn_stream_skip_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    apr_size_t arg3 ;
    int res2 ;
    unsigned long val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_invoke_skip_fn(_obj,baton,len);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_apr_size_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_invoke_skip_fn" "', argument " "1"" of type '" "svn_stream_skip_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_invoke_skip_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_stream_invoke_skip_fn" "', argument " "3"" of type '" "apr_size_t""'");
    } 
    arg3 = (apr_size_t)(val3);
    {
      result = (svn_error_t *)svn_stream_invoke_skip_fn(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_write_invoke_fn) {
  {
    svn_write_fn_t arg1 = (svn_write_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_size_t *arg4 = (apr_size_t *) 0 ;
    int res2 ;
    apr_size_t temp3 ;
    int argvi = 0;
    SV * _saved[1] ;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_write_invoke_fn(_obj,baton,data,len);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_write_invoke_fn" "', argument " "1"" of type '" "svn_write_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_write_invoke_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      arg3 = SvPV(ST(2), temp3);
      arg4 = (apr_size_t *)&temp3;
    }
    _saved[0] = ST(2);
    {
      result = (svn_error_t *)svn_write_invoke_fn(arg1,arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSViv(*arg4)); argvi++  ;
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_close_invoke_fn) {
  {
    svn_close_fn_t arg1 = (svn_close_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    int res2 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_close_invoke_fn(_obj,baton);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_close_invoke_fn" "', argument " "1"" of type '" "svn_close_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_close_invoke_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      result = (svn_error_t *)svn_close_invoke_fn(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_invoke_mark_fn) {
  {
    svn_stream_mark_fn_t arg1 = (svn_stream_mark_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    svn_stream_mark_t **arg3 = (svn_stream_mark_t **) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    svn_stream_mark_t *temp3 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg3 = &temp3;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_invoke_mark_fn(_obj,baton,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_invoke_mark_fn" "', argument " "1"" of type '" "svn_stream_mark_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_invoke_mark_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_stream_invoke_mark_fn(arg1,arg2,arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_stream_invoke_mark_fn arg 3 (svn_stream_mark_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_stream_invoke_mark_fn is not implemented yet");
      
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_stream_invoke_seek_fn) {
  {
    svn_stream_seek_fn_t arg1 = (svn_stream_seek_fn_t) 0 ;
    void *arg2 = (void *) 0 ;
    svn_stream_mark_t *arg3 = (svn_stream_mark_t *) 0 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_stream_invoke_seek_fn(_obj,baton,mark);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_stream_invoke_seek_fn" "', argument " "1"" of type '" "svn_stream_seek_fn_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_stream_invoke_seek_fn" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_svn_stream_mark_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_stream_invoke_seek_fn" "', argument " "3"" of type '" "svn_stream_mark_t const *""'"); 
    }
    arg3 = (svn_stream_mark_t *)(argp3);
    {
      result = (svn_error_t *)svn_stream_invoke_seek_fn(arg1,arg2,(struct svn_stream_mark_t const *)arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_io_invoke_walk_func) {
  {
    svn_io_walk_func_t arg1 = (svn_io_walk_func_t) 0 ;
    void *arg2 = (void *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_finfo_t *arg4 = (apr_finfo_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int res2 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_io_invoke_walk_func(_obj,baton,path,finfo,pool);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_io_invoke_walk_func" "', argument " "1"" of type '" "svn_io_walk_func_t""'"); 
      }
    }
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_io_invoke_walk_func" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_io_invoke_walk_func" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(3), &argp4,SWIGTYPE_p_apr_finfo_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_io_invoke_walk_func" "', argument " "4"" of type '" "apr_finfo_t const *""'"); 
    }
    arg4 = (apr_finfo_t *)(argp4);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_io_invoke_walk_func(arg1,arg2,(char const *)arg3,(apr_finfo_t const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_md5_empty_string_digest) {
  {
    int argvi = 0;
    unsigned char *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: svn_md5_empty_string_digest();");
    }
    {
      result = (unsigned char *)svn_md5_empty_string_digest();
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 | 0); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_svn_md5_digest_to_cstring_display) {
  {
    unsigned char *arg1 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    SV * _saved[1] ;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_md5_digest_to_cstring_display(digest,pool);");
    }
    {
      SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_unsigned_char, 0);
    }
    if (items > 1) {
      
    }
    _saved[0] = ST(0);
    {
      result = (char *)svn_md5_digest_to_cstring_display((unsigned char const (*))arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_md5_digest_to_cstring) {
  {
    unsigned char *arg1 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    SV * _saved[1] ;
    char *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_md5_digest_to_cstring(digest,pool);");
    }
    {
      SWIG_ConvertPtr(ST(0), (void **)&arg1, SWIGTYPE_p_unsigned_char, 0);
    }
    if (items > 1) {
      
    }
    _saved[0] = ST(0);
    {
      result = (char *)svn_md5_digest_to_cstring((unsigned char const (*))arg1,arg2);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_md5_digests_match) {
  {
    unsigned char *arg1 ;
    unsigned char *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_md5_digests_match(d1,d2);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_md5_digests_match" "', argument " "1"" of type '" "unsigned char const []""'"); 
    } 
    arg1 = (unsigned char *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_md5_digests_match" "', argument " "2"" of type '" "unsigned char const []""'"); 
    } 
    arg2 = (unsigned char *)(argp2);
    {
      result = (svn_boolean_t)svn_md5_digests_match((unsigned char const (*))arg1,(unsigned char const (*))arg2);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_version) {
  {
    int argvi = 0;
    svn_version_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: svn_diff_version();");
    }
    {
      result = (svn_version_t *)svn_diff_version();
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_version_t, 0 | 0); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasources_open_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t) = (svn_error_t *(*)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasources_open_set(self,datasources_open);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasources_open_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_datasources_open_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t)""'"); 
      }
    }
    if (arg1) (arg1)->datasources_open = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasources_open_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasources_open_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasources_open_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t)) ((arg1)->datasources_open);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasource_close_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    svn_error_t *(*arg2)(void *,svn_diff_datasource_e) = (svn_error_t *(*)(void *,svn_diff_datasource_e)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasource_close_set(self,datasource_close);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasource_close_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_datasource_close_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,svn_diff_datasource_e)""'"); 
      }
    }
    if (arg1) (arg1)->datasource_close = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasource_close_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,svn_diff_datasource_e) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasource_close_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasource_close_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (svn_error_t *(*)(void *,svn_diff_datasource_e)) ((arg1)->datasource_close);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasource_get_next_token_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    svn_error_t *(*arg2)(apr_uint32_t *,void **,void *,svn_diff_datasource_e) = (svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasource_get_next_token_set(self,datasource_get_next_token);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasource_get_next_token_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_datasource_get_next_token_set" "', argument " "2"" of type '" "svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)""'"); 
      }
    }
    if (arg1) (arg1)->datasource_get_next_token = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_datasource_get_next_token_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(apr_uint32_t *,void **,void *,svn_diff_datasource_e) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_datasource_get_next_token_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_datasource_get_next_token_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)) ((arg1)->datasource_get_next_token);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_compare_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    svn_error_t *(*arg2)(void *,void *,void *,int *) = (svn_error_t *(*)(void *,void *,void *,int *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_compare_set(self,token_compare);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_compare_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_void_p_void_p_int__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_token_compare_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,void *,void *,int *)""'"); 
      }
    }
    if (arg1) (arg1)->token_compare = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_compare_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,void *,void *,int *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_compare_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_compare_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (svn_error_t *(*)(void *,void *,void *,int *)) ((arg1)->token_compare);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_void_p_void_p_int__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_discard_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void (*arg2)(void *,void *) = (void (*)(void *,void *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_discard_set(self,token_discard);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_discard_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_void__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_token_discard_set" "', argument " "2"" of type '" "void (*)(void *,void *)""'"); 
      }
    }
    if (arg1) (arg1)->token_discard = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_discard_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void (*result)(void *,void *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_discard_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_discard_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (void (*)(void *,void *)) ((arg1)->token_discard);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_void__void); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_discard_all_set) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void (*arg2)(void *) = (void (*)(void *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_discard_all_set(self,token_discard_all);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_discard_all_set" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns2_t_token_discard_all_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
      }
    }
    if (arg1) (arg1)->token_discard_all = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_t_token_discard_all_get) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void (*result)(void *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns2_t_token_discard_all_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_t_token_discard_all_get" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    result = (void (*)(void *)) ((arg1)->token_discard_all);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_diff_fns2_t) {
  {
    int argvi = 0;
    svn_diff_fns2_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_diff_fns2_t();");
    }
    {
      result = (svn_diff_fns2_t *)calloc(1, sizeof(svn_diff_fns2_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_diff_fns2_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_diff_fns2_t) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_diff_fns2_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_diff_fns2_t" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_open_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,svn_diff_datasource_e) = (svn_error_t *(*)(void *,svn_diff_datasource_e)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_open_set(self,datasource_open);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_open_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_datasource_open_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,svn_diff_datasource_e)""'"); 
      }
    }
    if (arg1) (arg1)->datasource_open = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_open_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,svn_diff_datasource_e) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_open_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_open_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,svn_diff_datasource_e)) ((arg1)->datasource_open);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_close_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,svn_diff_datasource_e) = (svn_error_t *(*)(void *,svn_diff_datasource_e)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_close_set(self,datasource_close);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_close_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_datasource_close_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,svn_diff_datasource_e)""'"); 
      }
    }
    if (arg1) (arg1)->datasource_close = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_close_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,svn_diff_datasource_e) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_close_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_close_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,svn_diff_datasource_e)) ((arg1)->datasource_close);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_svn_diff_datasource_e__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_get_next_token_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    svn_error_t *(*arg2)(apr_uint32_t *,void **,void *,svn_diff_datasource_e) = (svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_get_next_token_set(self,datasource_get_next_token);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_get_next_token_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_datasource_get_next_token_set" "', argument " "2"" of type '" "svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)""'"); 
      }
    }
    if (arg1) (arg1)->datasource_get_next_token = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_datasource_get_next_token_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(apr_uint32_t *,void **,void *,svn_diff_datasource_e) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_datasource_get_next_token_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_datasource_get_next_token_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)) ((arg1)->datasource_get_next_token);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_compare_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,void *,void *,int *) = (svn_error_t *(*)(void *,void *,void *,int *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_compare_set(self,token_compare);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_compare_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_void_p_void_p_int__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_token_compare_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,void *,void *,int *)""'"); 
      }
    }
    if (arg1) (arg1)->token_compare = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_compare_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,void *,void *,int *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_compare_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_compare_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,void *,void *,int *)) ((arg1)->token_compare);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_void_p_void_p_int__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_discard_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void (*arg2)(void *,void *) = (void (*)(void *,void *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_discard_set(self,token_discard);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_discard_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_void__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_token_discard_set" "', argument " "2"" of type '" "void (*)(void *,void *)""'"); 
      }
    }
    if (arg1) (arg1)->token_discard = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_discard_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void (*result)(void *,void *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_discard_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_discard_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (void (*)(void *,void *)) ((arg1)->token_discard);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_p_void__void); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_discard_all_set) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void (*arg2)(void *) = (void (*)(void *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_discard_all_set(self,token_discard_all);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_discard_all_set" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void__void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_fns_t_token_discard_all_set" "', argument " "2"" of type '" "void (*)(void *)""'"); 
      }
    }
    if (arg1) (arg1)->token_discard_all = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_t_token_discard_all_get) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    void (*result)(void *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_fns_t_token_discard_all_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_t_token_discard_all_get" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    result = (void (*)(void *)) ((arg1)->token_discard_all);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void__void); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_diff_fns_t) {
  {
    int argvi = 0;
    svn_diff_fns_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_diff_fns_t();");
    }
    {
      result = (svn_diff_fns_t *)calloc(1, sizeof(svn_diff_fns_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_diff_fns_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_diff_fns_t) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_diff_fns_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_diff_fns_t" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns2_t *arg3 = (svn_diff_fns2_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff_2(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff_2" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff_2" "', argument " "3"" of type '" "svn_diff_fns2_t const *""'"); 
    }
    arg3 = (svn_diff_fns2_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff_2(arg1,arg2,(struct svn_diff_fns2_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns_t *arg3 = (svn_diff_fns_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff" "', argument " "3"" of type '" "svn_diff_fns_t const *""'"); 
    }
    arg3 = (svn_diff_fns_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff(arg1,arg2,(struct svn_diff_fns_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff3_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns2_t *arg3 = (svn_diff_fns2_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff3_2(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff3_2" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff3_2" "', argument " "3"" of type '" "svn_diff_fns2_t const *""'"); 
    }
    arg3 = (svn_diff_fns2_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff3_2(arg1,arg2,(struct svn_diff_fns2_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff3) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns_t *arg3 = (svn_diff_fns_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff3(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff3" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff3" "', argument " "3"" of type '" "svn_diff_fns_t const *""'"); 
    }
    arg3 = (svn_diff_fns_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff3(arg1,arg2,(struct svn_diff_fns_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff4_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns2_t *arg3 = (svn_diff_fns2_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff4_2(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff4_2" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff4_2" "', argument " "3"" of type '" "svn_diff_fns2_t const *""'"); 
    }
    arg3 = (svn_diff_fns2_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff4_2(arg1,arg2,(struct svn_diff_fns2_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_diff4) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_fns_t *arg3 = (svn_diff_fns_t *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_diff4(diff_baton,diff_fns,pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_diff4" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(1), &argp3,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_diff4" "', argument " "3"" of type '" "svn_diff_fns_t const *""'"); 
    }
    arg3 = (svn_diff_fns_t *)(argp3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_diff4(arg1,arg2,(struct svn_diff_fns_t const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_contains_conflicts) {
  {
    svn_diff_t *arg1 = (svn_diff_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_contains_conflicts(diff);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_contains_conflicts" "', argument " "1"" of type '" "svn_diff_t *""'"); 
    }
    arg1 = (svn_diff_t *)(argp1);
    {
      result = (svn_boolean_t)svn_diff_contains_conflicts(arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_contains_diffs) {
  {
    svn_diff_t *arg1 = (svn_diff_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_contains_diffs(diff);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_contains_diffs" "', argument " "1"" of type '" "svn_diff_t *""'"); 
    }
    arg1 = (svn_diff_t *)(argp1);
    {
      result = (svn_boolean_t)svn_diff_contains_diffs(arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_common_set) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_common_set(self,output_common);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_common_set" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_output_fns_t_output_common_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)""'"); 
      }
    }
    if (arg1) (arg1)->output_common = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_common_get) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_common_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_common_get" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) ((arg1)->output_common);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_modified_set) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_modified_set(self,output_diff_modified);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_modified_set" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_output_fns_t_output_diff_modified_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)""'"); 
      }
    }
    if (arg1) (arg1)->output_diff_modified = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_modified_get) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_modified_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_modified_get" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) ((arg1)->output_diff_modified);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_latest_set) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_latest_set(self,output_diff_latest);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_latest_set" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_output_fns_t_output_diff_latest_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)""'"); 
      }
    }
    if (arg1) (arg1)->output_diff_latest = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_latest_get) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_latest_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_latest_get" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) ((arg1)->output_diff_latest);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_common_set) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_common_set(self,output_diff_common);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_common_set" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_output_fns_t_output_diff_common_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)""'"); 
      }
    }
    if (arg1) (arg1)->output_diff_common = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_diff_common_get) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_diff_common_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_diff_common_get" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)) ((arg1)->output_diff_common);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_conflict_set) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    svn_error_t *(*arg2)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *) = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *)) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_conflict_set(self,output_conflict);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_conflict_set" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(ST(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_diff_output_fns_t_output_conflict_set" "', argument " "2"" of type '" "svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *)""'"); 
      }
    }
    if (arg1) (arg1)->output_conflict = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_t_output_conflict_get) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *(*result)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *) = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_output_fns_t_output_conflict_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_t_output_conflict_get" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    result = (svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *)) ((arg1)->output_conflict);
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_diff_output_fns_t) {
  {
    int argvi = 0;
    svn_diff_output_fns_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_diff_output_fns_t();");
    }
    {
      result = (svn_diff_output_fns_t *)calloc(1, sizeof(svn_diff_output_fns_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_diff_output_fns_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_diff_output_fns_t) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_diff_output_fns_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_diff_output_fns_t" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output) {
  {
    svn_diff_t *arg1 = (svn_diff_t *) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_output_fns_t *arg3 = (svn_diff_output_fns_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_output(diff,output_baton,output_fns);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output" "', argument " "1"" of type '" "svn_diff_t *""'"); 
    }
    arg1 = (svn_diff_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_output" "', argument " "3"" of type '" "svn_diff_output_fns_t const *""'"); 
    }
    arg3 = (svn_diff_output_fns_t *)(argp3);
    {
      result = (svn_error_t *)svn_diff_output(arg1,arg2,(struct svn_diff_output_fns_t const *)arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_ignore_space_set) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    svn_diff_file_ignore_space_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_file_options_t_ignore_space_set(self,ignore_space);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_ignore_space_set" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_diff_file_options_t_ignore_space_set" "', argument " "2"" of type '" "svn_diff_file_ignore_space_t""'");
    } 
    arg2 = (svn_diff_file_ignore_space_t)(val2);
    if (arg1) (arg1)->ignore_space = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_ignore_space_get) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_diff_file_ignore_space_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_file_options_t_ignore_space_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_ignore_space_get" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    result = (svn_diff_file_ignore_space_t) ((arg1)->ignore_space);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_ignore_eol_style_set) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_file_options_t_ignore_eol_style_set(self,ignore_eol_style);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_ignore_eol_style_set" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_diff_file_options_t_ignore_eol_style_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->ignore_eol_style = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_ignore_eol_style_get) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_file_options_t_ignore_eol_style_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_ignore_eol_style_get" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->ignore_eol_style);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_show_c_function_set) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_file_options_t_show_c_function_set(self,show_c_function);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_show_c_function_set" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_diff_file_options_t_show_c_function_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->show_c_function = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_t_show_c_function_get) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_file_options_t_show_c_function_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_t_show_c_function_get" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->show_c_function);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_diff_file_options_t) {
  {
    int argvi = 0;
    svn_diff_file_options_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_diff_file_options_t();");
    }
    {
      result = (svn_diff_file_options_t *)calloc(1, sizeof(svn_diff_file_options_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_diff_file_options_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_diff_file_options_t) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_diff_file_options_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_diff_file_options_t" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_create) {
  {
    apr_pool_t *arg1 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    int argvi = 0;
    svn_diff_file_options_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg1 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 0) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_file_options_create(pool);");
    }
    if (items > 0) {
      
    }
    {
      result = (svn_diff_file_options_t *)svn_diff_file_options_create(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_diff_file_options_t, 0 | SWIG_SHADOW); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_options_parse) {
  {
    svn_diff_file_options_t *arg1 = (svn_diff_file_options_t *) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_file_options_parse(options,args,pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_file_options_parse" "', argument " "1"" of type '" "svn_diff_file_options_t *""'"); 
    }
    arg1 = (svn_diff_file_options_t *)(argp1);
    {
      arg2 = (apr_array_header_t *) svn_swig_pl_strings_to_array(ST(1),
        _global_pool);
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_options_parse(arg1,(apr_array_header_t const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    svn_diff_file_options_t *arg4 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_diff_file_diff_2(original,modified,options,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff_2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff_2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_ConvertPtr(ST(2), &argp4,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_diff_2" "', argument " "4"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg4 = (svn_diff_file_options_t *)(argp4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff_2(arg1,(char const *)arg2,(char const *)arg3,(struct svn_diff_file_options_t const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    apr_pool_t *arg4 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg4 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 2) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_file_diff(original,modified,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff(arg1,(char const *)arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff3_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    svn_diff_file_options_t *arg5 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_diff_file_diff3_2(original,modified,latest,options,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff3_2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff3_2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_diff3_2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_ConvertPtr(ST(3), &argp5,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_diff3_2" "', argument " "5"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg5 = (svn_diff_file_options_t *)(argp5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff3_2(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(struct svn_diff_file_options_t const *)arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff3) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_diff_file_diff3(original,modified,latest,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff3" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff3" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_diff3" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff3(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff4_2) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    svn_diff_file_options_t *arg6 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    void *argp6 = 0 ;
    int res6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 5) || (items > 6)) {
      SWIG_croak("Usage: svn_diff_file_diff4_2(original,modified,latest,ancestor,options,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff4_2" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff4_2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_diff4_2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_diff4_2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_ConvertPtr(ST(4), &argp6,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_diff4_2" "', argument " "6"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg6 = (svn_diff_file_options_t *)(argp6);
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff4_2(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(struct svn_diff_file_options_t const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_diff4) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    char *arg2 = (char *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_diff_file_diff4(original,modified,latest,ancestor,pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_diff4" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    res3 = SWIG_AsCharPtrAndSize(ST(1), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_diff4" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(2), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_diff4" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(3), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_diff4" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_diff4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_output_unified3) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    svn_boolean_t arg9 ;
    apr_pool_t *arg10 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int val9 ;
    int ecode9 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg10 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 9) || (items > 10)) {
      SWIG_croak("Usage: svn_diff_file_output_unified3(output_stream,diff,original_path,modified_path,original_header,modified_header,header_encoding,relative_to_dir,show_c_function,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_output_unified3" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_output_unified3" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_output_unified3" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_output_unified3" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_output_unified3" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_file_output_unified3" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(7), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_diff_file_output_unified3" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    ecode9 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "svn_diff_file_output_unified3" "', argument " "9"" of type '" "svn_boolean_t""'");
    } 
    arg9 = (svn_boolean_t)(val9);
    if (items > 9) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_output_unified3(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,arg9,arg10);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_output_unified2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 7) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_file_output_unified2(output_stream,diff,original_path,modified_path,original_header,modified_header,header_encoding,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_output_unified2" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_output_unified2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_output_unified2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_output_unified2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_output_unified2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_file_output_unified2" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    if (items > 7) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_output_unified2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_output_unified) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 6) || (items > 7)) {
      SWIG_croak("Usage: svn_diff_file_output_unified(output_stream,diff,original_path,modified_path,original_header,modified_header,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_output_unified" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_output_unified" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_output_unified" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_output_unified" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_output_unified" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    if (items > 6) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_output_unified(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_output_merge2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    char *arg9 = (char *) 0 ;
    svn_diff_conflict_display_style_t arg10 ;
    apr_pool_t *arg11 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int val10 ;
    int ecode10 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg11 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 10) || (items > 11)) {
      SWIG_croak("Usage: svn_diff_file_output_merge2(output_stream,diff,original_path,modified_path,latest_path,conflict_original,conflict_modified,conflict_latest,conflict_separator,conflict_style,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_output_merge2" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_output_merge2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_output_merge2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_output_merge2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_output_merge2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_file_output_merge2" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(7), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_diff_file_output_merge2" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_diff_file_output_merge2" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    ecode10 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "svn_diff_file_output_merge2" "', argument " "10"" of type '" "svn_diff_conflict_display_style_t""'");
    } 
    arg10 = (svn_diff_conflict_display_style_t)(val10);
    if (items > 10) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_output_merge2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,(char const *)arg9,arg10,arg11);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_file_output_merge) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    char *arg9 = (char *) 0 ;
    svn_boolean_t arg10 ;
    svn_boolean_t arg11 ;
    apr_pool_t *arg12 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int val10 ;
    int ecode10 = 0 ;
    int val11 ;
    int ecode11 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg12 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 11) || (items > 12)) {
      SWIG_croak("Usage: svn_diff_file_output_merge(output_stream,diff,original_path,modified_path,latest_path,conflict_original,conflict_modified,conflict_latest,conflict_separator,display_original_in_conflict,display_resolved_conflicts,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_file_output_merge" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_file_output_merge" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_file_output_merge" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_file_output_merge" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_file_output_merge" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_file_output_merge" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(7), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_diff_file_output_merge" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_diff_file_output_merge" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    ecode10 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "svn_diff_file_output_merge" "', argument " "10"" of type '" "svn_boolean_t""'");
    } 
    arg10 = (svn_boolean_t)(val10);
    ecode11 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(10), &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "svn_diff_file_output_merge" "', argument " "11"" of type '" "svn_boolean_t""'");
    } 
    arg11 = (svn_boolean_t)(val11);
    if (items > 11) {
      
    }
    {
      result = (svn_error_t *)svn_diff_file_output_merge(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,(char const *)arg9,arg10,arg11,arg12);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_diff) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    svn_string_t *arg3 = (svn_string_t *) 0 ;
    svn_diff_file_options_t *arg4 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    svn_string_t value2 ;
    svn_string_t value3 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 4)) {
      SWIG_croak("Usage: svn_diff_mem_string_diff(original,modified,options,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    {
      if (SvOK(ST(1))) {
        value3.data = SvPV(ST(1), value3.len);
        arg3 = &value3;
      }
      else {
        arg3 = NULL;
      }
    }
    res4 = SWIG_ConvertPtr(ST(2), &argp4,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_mem_string_diff" "', argument " "4"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg4 = (svn_diff_file_options_t *)(argp4);
    if (items > 3) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_diff(arg1,(struct svn_string_t const *)arg2,(struct svn_string_t const *)arg3,(struct svn_diff_file_options_t const *)arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_diff3) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    svn_string_t *arg3 = (svn_string_t *) 0 ;
    svn_string_t *arg4 = (svn_string_t *) 0 ;
    svn_diff_file_options_t *arg5 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    svn_string_t value2 ;
    svn_string_t value3 ;
    svn_string_t value4 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 4) || (items > 5)) {
      SWIG_croak("Usage: svn_diff_mem_string_diff3(original,modified,latest,options,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    {
      if (SvOK(ST(1))) {
        value3.data = SvPV(ST(1), value3.len);
        arg3 = &value3;
      }
      else {
        arg3 = NULL;
      }
    }
    {
      if (SvOK(ST(2))) {
        value4.data = SvPV(ST(2), value4.len);
        arg4 = &value4;
      }
      else {
        arg4 = NULL;
      }
    }
    res5 = SWIG_ConvertPtr(ST(3), &argp5,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_mem_string_diff3" "', argument " "5"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg5 = (svn_diff_file_options_t *)(argp5);
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_diff3(arg1,(struct svn_string_t const *)arg2,(struct svn_string_t const *)arg3,(struct svn_string_t const *)arg4,(struct svn_diff_file_options_t const *)arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_diff4) {
  {
    svn_diff_t **arg1 = (svn_diff_t **) 0 ;
    svn_string_t *arg2 = (svn_string_t *) 0 ;
    svn_string_t *arg3 = (svn_string_t *) 0 ;
    svn_string_t *arg4 = (svn_string_t *) 0 ;
    svn_string_t *arg5 = (svn_string_t *) 0 ;
    svn_diff_file_options_t *arg6 = (svn_diff_file_options_t *) 0 ;
    apr_pool_t *arg7 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_diff_t *temp1 ;
    svn_string_t value2 ;
    svn_string_t value3 ;
    svn_string_t value4 ;
    svn_string_t value5 ;
    void *argp6 = 0 ;
    int res6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg7 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 5) || (items > 6)) {
      SWIG_croak("Usage: svn_diff_mem_string_diff4(original,modified,latest,ancestor,options,pool);");
    }
    {
      if (SvOK(ST(0))) {
        value2.data = SvPV(ST(0), value2.len);
        arg2 = &value2;
      }
      else {
        arg2 = NULL;
      }
    }
    {
      if (SvOK(ST(1))) {
        value3.data = SvPV(ST(1), value3.len);
        arg3 = &value3;
      }
      else {
        arg3 = NULL;
      }
    }
    {
      if (SvOK(ST(2))) {
        value4.data = SvPV(ST(2), value4.len);
        arg4 = &value4;
      }
      else {
        arg4 = NULL;
      }
    }
    {
      if (SvOK(ST(3))) {
        value5.data = SvPV(ST(3), value5.len);
        arg5 = &value5;
      }
      else {
        arg5 = NULL;
      }
    }
    res6 = SWIG_ConvertPtr(ST(4), &argp6,SWIGTYPE_p_svn_diff_file_options_t, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_mem_string_diff4" "', argument " "6"" of type '" "svn_diff_file_options_t const *""'"); 
    }
    arg6 = (svn_diff_file_options_t *)(argp6);
    if (items > 5) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_diff4(arg1,(struct svn_string_t const *)arg2,(struct svn_string_t const *)arg3,(struct svn_string_t const *)arg4,(struct svn_string_t const *)arg5,(struct svn_diff_file_options_t const *)arg6,arg7);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg1, SWIGTYPE_p_svn_diff_t, 0); argvi++  ;
    }
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_output_unified2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    svn_boolean_t arg3 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    svn_string_t *arg8 = (svn_string_t *) 0 ;
    svn_string_t *arg9 = (svn_string_t *) 0 ;
    apr_pool_t *arg10 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    svn_string_t value8 ;
    svn_string_t value9 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg10 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 9) || (items > 10)) {
      SWIG_croak("Usage: svn_diff_mem_string_output_unified2(output_stream,diff,with_diff_header,hunk_delimiter,original_header,modified_header,header_encoding,original,modified,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_mem_string_output_unified2" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    {
      if (SvOK(ST(7))) {
        value8.data = SvPV(ST(7), value8.len);
        arg8 = &value8;
      }
      else {
        arg8 = NULL;
      }
    }
    {
      if (SvOK(ST(8))) {
        value9.data = SvPV(ST(8), value9.len);
        arg9 = &value9;
      }
      else {
        arg9 = NULL;
      }
    }
    if (items > 9) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_output_unified2(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,(struct svn_string_t const *)arg8,(struct svn_string_t const *)arg9,arg10);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_output_unified) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    char *arg3 = (char *) 0 ;
    char *arg4 = (char *) 0 ;
    char *arg5 = (char *) 0 ;
    svn_string_t *arg6 = (svn_string_t *) 0 ;
    svn_string_t *arg7 = (svn_string_t *) 0 ;
    apr_pool_t *arg8 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    svn_string_t value6 ;
    svn_string_t value7 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg8 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 7) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_mem_string_output_unified(output_stream,diff,original_header,modified_header,header_encoding,original,modified,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_mem_string_output_unified" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_mem_string_output_unified" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_mem_string_output_unified" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_mem_string_output_unified" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    {
      if (SvOK(ST(5))) {
        value6.data = SvPV(ST(5), value6.len);
        arg6 = &value6;
      }
      else {
        arg6 = NULL;
      }
    }
    {
      if (SvOK(ST(6))) {
        value7.data = SvPV(ST(6), value7.len);
        arg7 = &value7;
      }
      else {
        arg7 = NULL;
      }
    }
    if (items > 7) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_output_unified(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(struct svn_string_t const *)arg6,(struct svn_string_t const *)arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_output_merge2) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    svn_string_t *arg3 = (svn_string_t *) 0 ;
    svn_string_t *arg4 = (svn_string_t *) 0 ;
    svn_string_t *arg5 = (svn_string_t *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    char *arg9 = (char *) 0 ;
    svn_diff_conflict_display_style_t arg10 ;
    apr_pool_t *arg11 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    svn_string_t value3 ;
    svn_string_t value4 ;
    svn_string_t value5 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int val10 ;
    int ecode10 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg11 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 10) || (items > 11)) {
      SWIG_croak("Usage: svn_diff_mem_string_output_merge2(output_stream,diff,original,modified,latest,conflict_original,conflict_modified,conflict_latest,conflict_separator,style,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    {
      if (SvOK(ST(2))) {
        value3.data = SvPV(ST(2), value3.len);
        arg3 = &value3;
      }
      else {
        arg3 = NULL;
      }
    }
    {
      if (SvOK(ST(3))) {
        value4.data = SvPV(ST(3), value4.len);
        arg4 = &value4;
      }
      else {
        arg4 = NULL;
      }
    }
    {
      if (SvOK(ST(4))) {
        value5.data = SvPV(ST(4), value5.len);
        arg5 = &value5;
      }
      else {
        arg5 = NULL;
      }
    }
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(7), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    ecode10 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "svn_diff_mem_string_output_merge2" "', argument " "10"" of type '" "svn_diff_conflict_display_style_t""'");
    } 
    arg10 = (svn_diff_conflict_display_style_t)(val10);
    if (items > 10) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_output_merge2(arg1,arg2,(struct svn_string_t const *)arg3,(struct svn_string_t const *)arg4,(struct svn_string_t const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,(char const *)arg9,arg10,arg11);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_mem_string_output_merge) {
  {
    svn_stream_t *arg1 = (svn_stream_t *) 0 ;
    svn_diff_t *arg2 = (svn_diff_t *) 0 ;
    svn_string_t *arg3 = (svn_string_t *) 0 ;
    svn_string_t *arg4 = (svn_string_t *) 0 ;
    svn_string_t *arg5 = (svn_string_t *) 0 ;
    char *arg6 = (char *) 0 ;
    char *arg7 = (char *) 0 ;
    char *arg8 = (char *) 0 ;
    char *arg9 = (char *) 0 ;
    svn_boolean_t arg10 ;
    svn_boolean_t arg11 ;
    apr_pool_t *arg12 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    svn_string_t value3 ;
    svn_string_t value4 ;
    svn_string_t value5 ;
    int res6 ;
    char *buf6 = 0 ;
    int alloc6 = 0 ;
    int res7 ;
    char *buf7 = 0 ;
    int alloc7 = 0 ;
    int res8 ;
    char *buf8 = 0 ;
    int alloc8 = 0 ;
    int res9 ;
    char *buf9 = 0 ;
    int alloc9 = 0 ;
    int val10 ;
    int ecode10 = 0 ;
    int val11 ;
    int ecode11 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg12 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 11) || (items > 12)) {
      SWIG_croak("Usage: svn_diff_mem_string_output_merge(output_stream,diff,original,modified,latest,conflict_original,conflict_modified,conflict_latest,conflict_separator,display_original_in_conflict,display_resolved_conflicts,pool);");
    }
    {
      svn_swig_pl_make_stream (&arg1, ST(0));
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_mem_string_output_merge" "', argument " "2"" of type '" "svn_diff_t *""'"); 
    }
    arg2 = (svn_diff_t *)(argp2);
    {
      if (SvOK(ST(2))) {
        value3.data = SvPV(ST(2), value3.len);
        arg3 = &value3;
      }
      else {
        arg3 = NULL;
      }
    }
    {
      if (SvOK(ST(3))) {
        value4.data = SvPV(ST(3), value4.len);
        arg4 = &value4;
      }
      else {
        arg4 = NULL;
      }
    }
    {
      if (SvOK(ST(4))) {
        value5.data = SvPV(ST(4), value5.len);
        arg5 = &value5;
      }
      else {
        arg5 = NULL;
      }
    }
    res6 = SWIG_AsCharPtrAndSize(ST(5), &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "svn_diff_mem_string_output_merge" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
    res7 = SWIG_AsCharPtrAndSize(ST(6), &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "svn_diff_mem_string_output_merge" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
    res8 = SWIG_AsCharPtrAndSize(ST(7), &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "svn_diff_mem_string_output_merge" "', argument " "8"" of type '" "char const *""'");
    }
    arg8 = (char *)(buf8);
    res9 = SWIG_AsCharPtrAndSize(ST(8), &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_diff_mem_string_output_merge" "', argument " "9"" of type '" "char const *""'");
    }
    arg9 = (char *)(buf9);
    ecode10 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "svn_diff_mem_string_output_merge" "', argument " "10"" of type '" "svn_boolean_t""'");
    } 
    arg10 = (svn_boolean_t)(val10);
    ecode11 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(10), &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "svn_diff_mem_string_output_merge" "', argument " "11"" of type '" "svn_boolean_t""'");
    } 
    arg11 = (svn_boolean_t)(val11);
    if (items > 11) {
      
    }
    {
      result = (svn_error_t *)svn_diff_mem_string_output_merge(arg1,arg2,(struct svn_string_t const *)arg3,(struct svn_string_t const *)arg4,(struct svn_string_t const *)arg5,(char const *)arg6,(char const *)arg7,(char const *)arg8,(char const *)arg9,arg10,arg11,arg12);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
    if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
    if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
    if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_readline_diff_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    svn_stringbuf_t **arg2 = (svn_stringbuf_t **) 0 ;
    char **arg3 = (char **) 0 ;
    svn_boolean_t *arg4 = (svn_boolean_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_stringbuf_t *temp2 ;
    char *temp3 ;
    svn_boolean_t temp4 ;
    int res4 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    arg4 = &temp4;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_hunk_readline_diff_text(hunk,result_pool,scratch_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_readline_diff_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_hunk_readline_diff_text(arg1,arg2,(char const **)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg2)->data, (*arg2)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    {
      if (*arg3 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg3, 0)); argvi++  ;
      }
    }
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_readline_original_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    svn_stringbuf_t **arg2 = (svn_stringbuf_t **) 0 ;
    char **arg3 = (char **) 0 ;
    svn_boolean_t *arg4 = (svn_boolean_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_stringbuf_t *temp2 ;
    char *temp3 ;
    svn_boolean_t temp4 ;
    int res4 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    arg4 = &temp4;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_hunk_readline_original_text(hunk,result_pool,scratch_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_readline_original_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_hunk_readline_original_text(arg1,arg2,(char const **)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg2)->data, (*arg2)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    {
      if (*arg3 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg3, 0)); argvi++  ;
      }
    }
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_readline_modified_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    svn_stringbuf_t **arg2 = (svn_stringbuf_t **) 0 ;
    char **arg3 = (char **) 0 ;
    svn_boolean_t *arg4 = (svn_boolean_t *) 0 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    svn_stringbuf_t *temp2 ;
    char *temp3 ;
    svn_boolean_t temp4 ;
    int res4 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg2 = &temp2;
    arg3 = &temp3;
    arg4 = &temp4;
    if ((items < 1) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_hunk_readline_modified_text(hunk,result_pool,scratch_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_readline_modified_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    if (items > 1) {
      
    }
    if (items > 2) {
      
    }
    {
      result = (svn_error_t *)svn_diff_hunk_readline_modified_text(arg1,arg2,(char const **)arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      if (*arg2) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpvn((*arg2)->data, (*arg2)->len)); argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      }
    }
    {
      if (*arg3 == NULL) {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = &PL_sv_undef; argvi++  ;
      } else {
        if (argvi >= items) EXTEND(sp,1);  ST(argvi) = sv_2mortal(newSVpv(*arg3, 0)); argvi++  ;
      }
    }
    if (SWIG_IsTmpObj(res4)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg4)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_reset_diff_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_reset_diff_text(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_reset_diff_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      svn_diff_hunk_reset_diff_text(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_reset_original_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_reset_original_text(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_reset_original_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      svn_diff_hunk_reset_original_text(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_reset_modified_text) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_reset_modified_text(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_reset_modified_text" "', argument " "1"" of type '" "svn_diff_hunk_t *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      svn_diff_hunk_reset_modified_text(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_original_start) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_original_start(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_original_start" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_original_start((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_original_length) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_original_length(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_original_length" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_original_length((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_modified_start) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_modified_start(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_modified_start" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_modified_start((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_modified_length) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_modified_length(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_modified_length" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_modified_length((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_leading_context) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_leading_context(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_leading_context" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_leading_context((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_hunk_get_trailing_context) {
  {
    svn_diff_hunk_t *arg1 = (svn_diff_hunk_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_linenum_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_diff_hunk_get_trailing_context(hunk);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_hunk_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_hunk_get_trailing_context" "', argument " "1"" of type '" "svn_diff_hunk_t const *""'"); 
    }
    arg1 = (svn_diff_hunk_t *)(argp1);
    {
      result = (svn_linenum_t)svn_diff_hunk_get_trailing_context((struct svn_diff_hunk_t const *)arg1);
      
      
      
    }
    ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((unsigned long)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_name_set) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_patch_t_name_set(self,name);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_name_set" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_prop_patch_t_name_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->name) free((char *)arg1->name);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->name = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_name_get) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_patch_t_name_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_name_get" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    result = (char *) ((arg1)->name);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_operation_set) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    svn_diff_operation_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_patch_t_operation_set(self,operation);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_operation_set" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_prop_patch_t_operation_set" "', argument " "2"" of type '" "svn_diff_operation_kind_t""'");
    } 
    arg2 = (svn_diff_operation_kind_t)(val2);
    if (arg1) (arg1)->operation = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_operation_get) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_diff_operation_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_patch_t_operation_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_operation_get" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    result = (svn_diff_operation_kind_t) ((arg1)->operation);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_hunks_set) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_prop_patch_t_hunks_set(self,hunks);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_hunks_set" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_array_header_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_prop_patch_t_hunks_set" "', argument " "2"" of type '" "apr_array_header_t *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    if (arg1) (arg1)->hunks = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_prop_patch_t_hunks_get) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_array_header_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_prop_patch_t_hunks_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_prop_patch_t_hunks_get" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    result = (apr_array_header_t *) ((arg1)->hunks);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_array_header_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_prop_patch_t) {
  {
    int argvi = 0;
    svn_prop_patch_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_prop_patch_t();");
    }
    {
      result = (svn_prop_patch_t *)calloc(1, sizeof(svn_prop_patch_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_prop_patch_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_prop_patch_t) {
  {
    svn_prop_patch_t *arg1 = (svn_prop_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_prop_patch_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_prop_patch_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_prop_patch_t" "', argument " "1"" of type '" "svn_prop_patch_t *""'"); 
    }
    arg1 = (svn_prop_patch_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_old_filename_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_old_filename_set(self,old_filename);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_old_filename_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_patch_t_old_filename_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->old_filename) free((char *)arg1->old_filename);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->old_filename = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_old_filename_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_old_filename_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_old_filename_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (char *) ((arg1)->old_filename);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_new_filename_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_new_filename_set(self,new_filename);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_new_filename_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_patch_t_new_filename_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      apr_size_t len = strlen(arg2) + 1;
      char *copied;
      if (arg1->new_filename) free((char *)arg1->new_filename);
      copied = malloc(len);
      memcpy(copied, arg2, len);
      arg1->new_filename = copied;
    }
    ST(argvi) = sv_newmortal();
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_new_filename_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_new_filename_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_new_filename_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (char *) ((arg1)->new_filename);
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_hunks_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    apr_array_header_t *arg2 = (apr_array_header_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_hunks_set(self,hunks);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_hunks_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_array_header_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_patch_t_hunks_set" "', argument " "2"" of type '" "apr_array_header_t *""'"); 
    }
    arg2 = (apr_array_header_t *)(argp2);
    if (arg1) (arg1)->hunks = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_hunks_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_array_header_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_hunks_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_hunks_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (apr_array_header_t *) ((arg1)->hunks);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_array_header_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_prop_patches_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    apr_hash_t *arg2 = (apr_hash_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_prop_patches_set(self,prop_patches);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_prop_patches_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_apr_hash_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_patch_t_prop_patches_set" "', argument " "2"" of type '" "apr_hash_t *""'"); 
    }
    arg2 = (apr_hash_t *)(argp2);
    if (arg1) (arg1)->prop_patches = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_prop_patches_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    apr_hash_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_prop_patches_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_prop_patches_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (apr_hash_t *) ((arg1)->prop_patches);
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_apr_hash_t, 0 | 0); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_operation_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    svn_diff_operation_kind_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_operation_set(self,operation);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_operation_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_patch_t_operation_set" "', argument " "2"" of type '" "svn_diff_operation_kind_t""'");
    } 
    arg2 = (svn_diff_operation_kind_t)(val2);
    if (arg1) (arg1)->operation = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_operation_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_diff_operation_kind_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_operation_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_operation_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (svn_diff_operation_kind_t) ((arg1)->operation);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_reverse_set) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    svn_boolean_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_patch_t_reverse_set(self,reverse);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_reverse_set" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_patch_t_reverse_set" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    if (arg1) (arg1)->reverse = arg2;
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_patch_t_reverse_get) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_boolean_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_patch_t_reverse_get(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_patch_t_reverse_get" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    result = (svn_boolean_t) ((arg1)->reverse);
    ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(result)); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_new_svn_patch_t) {
  {
    int argvi = 0;
    svn_patch_t *result = 0 ;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
      SWIG_croak("Usage: new_svn_patch_t();");
    }
    {
      result = (svn_patch_t *)calloc(1, sizeof(svn_patch_t));
      
      
      
    }
    ST(argvi) = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_svn_patch_t, SWIG_OWNER | SWIG_SHADOW); argvi++ ;
    XSRETURN(argvi);
  fail:
    SWIG_croak_null();
  }
}


XS(_wrap_delete_svn_patch_t) {
  {
    svn_patch_t *arg1 = (svn_patch_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: delete_svn_patch_t(self);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_t, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_svn_patch_t" "', argument " "1"" of type '" "svn_patch_t *""'"); 
    }
    arg1 = (svn_patch_t *)(argp1);
    {
      free((char *) arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_open_patch_file) {
  {
    svn_patch_file_t **arg1 = (svn_patch_file_t **) 0 ;
    char *arg2 = (char *) 0 ;
    apr_pool_t *arg3 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_patch_file_t *temp1 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg3 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_open_patch_file(local_abspath,result_pool);");
    }
    res2 = SWIG_AsCharPtrAndSize(ST(0), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_open_patch_file" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_diff_open_patch_file(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_diff_open_patch_file arg 1 (svn_patch_file_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_diff_open_patch_file is not implemented yet");
      
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_parse_next_patch) {
  {
    svn_patch_t **arg1 = (svn_patch_t **) 0 ;
    svn_patch_file_t *arg2 = (svn_patch_file_t *) 0 ;
    svn_boolean_t arg3 ;
    svn_boolean_t arg4 ;
    apr_pool_t *arg5 = (apr_pool_t *) 0 ;
    apr_pool_t *arg6 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    svn_patch_t *temp1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg5 = svn_swig_pl_make_pool (ST(items-1));
    }
    {
      _global_pool = arg6 = svn_swig_pl_make_pool (ST(items-1));
    }
    arg1 = &temp1;
    if ((items < 3) || (items > 5)) {
      SWIG_croak("Usage: svn_diff_parse_next_patch(patch_file,reverse,ignore_whitespace,result_pool,scratch_pool);");
    }
    res2 = SWIG_ConvertPtr(ST(0), &argp2,SWIGTYPE_p_svn_patch_file_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_parse_next_patch" "', argument " "2"" of type '" "svn_patch_file_t *""'"); 
    }
    arg2 = (svn_patch_file_t *)(argp2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_parse_next_patch" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_parse_next_patch" "', argument " "4"" of type '" "svn_boolean_t""'");
    } 
    arg4 = (svn_boolean_t)(val4);
    if (items > 3) {
      
    }
    if (items > 4) {
      
    }
    {
      result = (svn_error_t *)svn_diff_parse_next_patch(arg1,arg2,arg3,arg4,arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    {
      /* FIXME: Missing argout typemap: svn_diff_parse_next_patch arg 1 (svn_patch_t **) */
      
      
      
      
      SWIG_exception(SWIG_ValueError, "svn_diff_parse_next_patch is not implemented yet");
      
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_close_patch_file) {
  {
    svn_patch_file_t *arg1 = (svn_patch_file_t *) 0 ;
    apr_pool_t *arg2 = (apr_pool_t *) 0 ;
    apr_pool_t *_global_pool ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    {
      _global_pool = arg2 = svn_swig_pl_make_pool (ST(items-1));
    }
    if ((items < 1) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_close_patch_file(patch_file,scratch_pool);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_patch_file_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_close_patch_file" "', argument " "1"" of type '" "svn_patch_file_t *""'"); 
    }
    arg1 = (svn_patch_file_t *)(argp1);
    if (items > 1) {
      
    }
    {
      result = (svn_error_t *)svn_diff_close_patch_file(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_datasources_open) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t *arg3 = (apr_off_t *) 0 ;
    apr_off_t *arg4 = (apr_off_t *) 0 ;
    svn_diff_datasource_e *arg5 = (svn_diff_datasource_e *) 0 ;
    apr_size_t arg6 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    void *argp4 = 0 ;
    int res4 = 0 ;
    void *argp5 = 0 ;
    int res5 = 0 ;
    unsigned long val6 ;
    int ecode6 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 6) || (items > 6)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_datasources_open(_obj,diff_baton,prefix_lines,suffix_lines,datasources,datasources_len);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2), &argp3,SWIGTYPE_p_apr_off_t, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "3"" of type '" "apr_off_t *""'"); 
    }
    arg3 = (apr_off_t *)(argp3);
    res4 = SWIG_ConvertPtr(ST(3), &argp4,SWIGTYPE_p_apr_off_t, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "4"" of type '" "apr_off_t *""'"); 
    }
    arg4 = (apr_off_t *)(argp4);
    res5 = SWIG_ConvertPtr(ST(4), &argp5,SWIGTYPE_p_svn_diff_datasource_e, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "5"" of type '" "svn_diff_datasource_e const *""'"); 
    }
    arg5 = (svn_diff_datasource_e *)(argp5);
    ecode6 = SWIG_AsVal_unsigned_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_fns2_invoke_datasources_open" "', argument " "6"" of type '" "apr_size_t""'");
    } 
    arg6 = (apr_size_t)(val6);
    {
      result = (svn_error_t *)svn_diff_fns2_invoke_datasources_open(arg1,arg2,arg3,arg4,(enum svn_diff_datasource_e const *)arg5,arg6);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_datasource_close) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_datasource_e arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_datasource_close(_obj,diff_baton,datasource);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_datasource_close" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns2_invoke_datasource_close" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_fns2_invoke_datasource_close" "', argument " "3"" of type '" "svn_diff_datasource_e""'");
    } 
    arg3 = (svn_diff_datasource_e)(val3);
    {
      result = (svn_error_t *)svn_diff_fns2_invoke_datasource_close(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_datasource_get_next_token) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    apr_uint32_t *arg2 = (apr_uint32_t *) 0 ;
    void **arg3 = (void **) 0 ;
    void *arg4 = (void *) 0 ;
    svn_diff_datasource_e arg5 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    apr_uint32_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    void *temp3 ;
    int res4 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg2 = &temp2;
    arg3 = &temp3;
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_datasource_get_next_token(_obj,diff_baton,datasource);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_datasource_get_next_token" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res4 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_fns2_invoke_datasource_get_next_token" "', argument " "4"" of type '" "void *""'"); 
    }
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_fns2_invoke_datasource_get_next_token" "', argument " "5"" of type '" "svn_diff_datasource_e""'");
    } 
    arg5 = (svn_diff_datasource_e)(val5);
    {
      result = (svn_error_t *)svn_diff_fns2_invoke_datasource_get_next_token(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_apr_uint32_t, new_flags); argvi++  ;
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg3, SWIGTYPE_p_void, 0); argvi++  ;
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_token_compare) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    int *arg5 = (int *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int res3 ;
    int res4 ;
    int temp5 ;
    int res5 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg5 = &temp5;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_token_compare(_obj,diff_baton,ltoken,rtoken);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_token_compare" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns2_invoke_token_compare" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_fns2_invoke_token_compare" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_fns2_invoke_token_compare" "', argument " "4"" of type '" "void *""'"); 
    }
    {
      result = (svn_error_t *)svn_diff_fns2_invoke_token_compare(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res5)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg5)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_token_discard) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int res3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_token_discard(_obj,diff_baton,token);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_token_discard" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns2_invoke_token_discard" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_fns2_invoke_token_discard" "', argument " "3"" of type '" "void *""'"); 
    }
    {
      svn_diff_fns2_invoke_token_discard(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns2_invoke_token_discard_all) {
  {
    svn_diff_fns2_t *arg1 = (svn_diff_fns2_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns2_invoke_token_discard_all(_obj,diff_baton);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns2_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns2_invoke_token_discard_all" "', argument " "1"" of type '" "svn_diff_fns2_t *""'"); 
    }
    arg1 = (svn_diff_fns2_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns2_invoke_token_discard_all" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      svn_diff_fns2_invoke_token_discard_all(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_datasource_open) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_datasource_e arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_datasource_open(_obj,diff_baton,datasource);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_datasource_open" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns_invoke_datasource_open" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_fns_invoke_datasource_open" "', argument " "3"" of type '" "svn_diff_datasource_e""'");
    } 
    arg3 = (svn_diff_datasource_e)(val3);
    {
      result = (svn_error_t *)svn_diff_fns_invoke_datasource_open(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_datasource_close) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    svn_diff_datasource_e arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_datasource_close(_obj,diff_baton,datasource);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_datasource_close" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns_invoke_datasource_close" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_fns_invoke_datasource_close" "', argument " "3"" of type '" "svn_diff_datasource_e""'");
    } 
    arg3 = (svn_diff_datasource_e)(val3);
    {
      result = (svn_error_t *)svn_diff_fns_invoke_datasource_close(arg1,arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_datasource_get_next_token) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    apr_uint32_t *arg2 = (apr_uint32_t *) 0 ;
    void **arg3 = (void **) 0 ;
    void *arg4 = (void *) 0 ;
    svn_diff_datasource_e arg5 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    apr_uint32_t temp2 ;
    int res2 = SWIG_TMPOBJ ;
    void *temp3 ;
    int res4 ;
    int val5 ;
    int ecode5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg2 = &temp2;
    arg3 = &temp3;
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_datasource_get_next_token(_obj,diff_baton,datasource);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_datasource_get_next_token" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res4 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_fns_invoke_datasource_get_next_token" "', argument " "4"" of type '" "void *""'"); 
    }
    ecode5 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_fns_invoke_datasource_get_next_token" "', argument " "5"" of type '" "svn_diff_datasource_e""'");
    } 
    arg5 = (svn_diff_datasource_e)(val5);
    {
      result = (svn_error_t *)svn_diff_fns_invoke_datasource_get_next_token(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res2)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_unsigned_SS_long  SWIG_PERL_CALL_ARGS_1((*arg2)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_apr_uint32_t, new_flags); argvi++  ;
    }
    {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj(*arg3, SWIGTYPE_p_void, 0); argvi++  ;
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_token_compare) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *arg4 = (void *) 0 ;
    int *arg5 = (int *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int res3 ;
    int res4 ;
    int temp5 ;
    int res5 = SWIG_TMPOBJ ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    arg5 = &temp5;
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_token_compare(_obj,diff_baton,ltoken,rtoken);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_token_compare" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns_invoke_token_compare" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_fns_invoke_token_compare" "', argument " "3"" of type '" "void *""'"); 
    }
    res4 = SWIG_ConvertPtr(ST(3),SWIG_as_voidptrptr(&arg4), 0, 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_diff_fns_invoke_token_compare" "', argument " "4"" of type '" "void *""'"); 
    }
    {
      result = (svn_error_t *)svn_diff_fns_invoke_token_compare(arg1,arg2,arg3,arg4,arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    if (SWIG_IsTmpObj(res5)) {
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_From_int  SWIG_PERL_CALL_ARGS_1((*arg5)); argvi++  ;
    } else {
      int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN | 0) : 0;
      if (argvi >= items) EXTEND(sp,1);  ST(argvi) = SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags); argvi++  ;
    }
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_token_discard) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *arg3 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int res3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_token_discard(_obj,diff_baton,token);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_token_discard" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns_invoke_token_discard" "', argument " "2"" of type '" "void *""'"); 
    }
    res3 = SWIG_ConvertPtr(ST(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_diff_fns_invoke_token_discard" "', argument " "3"" of type '" "void *""'"); 
    }
    {
      svn_diff_fns_invoke_token_discard(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_fns_invoke_token_discard_all) {
  {
    svn_diff_fns_t *arg1 = (svn_diff_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_diff_fns_invoke_token_discard_all(_obj,diff_baton);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_fns_invoke_token_discard_all" "', argument " "1"" of type '" "svn_diff_fns_t *""'"); 
    }
    arg1 = (svn_diff_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_fns_invoke_token_discard_all" "', argument " "2"" of type '" "void *""'"); 
    }
    {
      svn_diff_fns_invoke_token_discard_all(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_invoke_output_common) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t arg3 ;
    apr_off_t arg4 ;
    apr_off_t arg5 ;
    apr_off_t arg6 ;
    apr_off_t arg7 ;
    apr_off_t arg8 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    long long val3 ;
    int ecode3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    long long val5 ;
    int ecode5 = 0 ;
    long long val6 ;
    int ecode6 = 0 ;
    long long val7 ;
    int ecode7 = 0 ;
    long long val8 ;
    int ecode8 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 8) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_output_fns_invoke_output_common(_obj,output_baton,original_start,original_length,modified_start,modified_length,latest_start,latest_length);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "3"" of type '" "apr_off_t""'");
    } 
    arg3 = (apr_off_t)(val3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "4"" of type '" "apr_off_t""'");
    } 
    arg4 = (apr_off_t)(val4);
    ecode5 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "5"" of type '" "apr_off_t""'");
    } 
    arg5 = (apr_off_t)(val5);
    ecode6 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "6"" of type '" "apr_off_t""'");
    } 
    arg6 = (apr_off_t)(val6);
    ecode7 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "7"" of type '" "apr_off_t""'");
    } 
    arg7 = (apr_off_t)(val7);
    ecode8 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_diff_output_fns_invoke_output_common" "', argument " "8"" of type '" "apr_off_t""'");
    } 
    arg8 = (apr_off_t)(val8);
    {
      result = (svn_error_t *)svn_diff_output_fns_invoke_output_common(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_invoke_output_diff_modified) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t arg3 ;
    apr_off_t arg4 ;
    apr_off_t arg5 ;
    apr_off_t arg6 ;
    apr_off_t arg7 ;
    apr_off_t arg8 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    long long val3 ;
    int ecode3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    long long val5 ;
    int ecode5 = 0 ;
    long long val6 ;
    int ecode6 = 0 ;
    long long val7 ;
    int ecode7 = 0 ;
    long long val8 ;
    int ecode8 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 8) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_output_fns_invoke_output_diff_modified(_obj,output_baton,original_start,original_length,modified_start,modified_length,latest_start,latest_length);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "3"" of type '" "apr_off_t""'");
    } 
    arg3 = (apr_off_t)(val3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "4"" of type '" "apr_off_t""'");
    } 
    arg4 = (apr_off_t)(val4);
    ecode5 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "5"" of type '" "apr_off_t""'");
    } 
    arg5 = (apr_off_t)(val5);
    ecode6 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "6"" of type '" "apr_off_t""'");
    } 
    arg6 = (apr_off_t)(val6);
    ecode7 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "7"" of type '" "apr_off_t""'");
    } 
    arg7 = (apr_off_t)(val7);
    ecode8 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_diff_output_fns_invoke_output_diff_modified" "', argument " "8"" of type '" "apr_off_t""'");
    } 
    arg8 = (apr_off_t)(val8);
    {
      result = (svn_error_t *)svn_diff_output_fns_invoke_output_diff_modified(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_invoke_output_diff_latest) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t arg3 ;
    apr_off_t arg4 ;
    apr_off_t arg5 ;
    apr_off_t arg6 ;
    apr_off_t arg7 ;
    apr_off_t arg8 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    long long val3 ;
    int ecode3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    long long val5 ;
    int ecode5 = 0 ;
    long long val6 ;
    int ecode6 = 0 ;
    long long val7 ;
    int ecode7 = 0 ;
    long long val8 ;
    int ecode8 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 8) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_output_fns_invoke_output_diff_latest(_obj,output_baton,original_start,original_length,modified_start,modified_length,latest_start,latest_length);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "3"" of type '" "apr_off_t""'");
    } 
    arg3 = (apr_off_t)(val3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "4"" of type '" "apr_off_t""'");
    } 
    arg4 = (apr_off_t)(val4);
    ecode5 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "5"" of type '" "apr_off_t""'");
    } 
    arg5 = (apr_off_t)(val5);
    ecode6 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "6"" of type '" "apr_off_t""'");
    } 
    arg6 = (apr_off_t)(val6);
    ecode7 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "7"" of type '" "apr_off_t""'");
    } 
    arg7 = (apr_off_t)(val7);
    ecode8 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_diff_output_fns_invoke_output_diff_latest" "', argument " "8"" of type '" "apr_off_t""'");
    } 
    arg8 = (apr_off_t)(val8);
    {
      result = (svn_error_t *)svn_diff_output_fns_invoke_output_diff_latest(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_invoke_output_diff_common) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t arg3 ;
    apr_off_t arg4 ;
    apr_off_t arg5 ;
    apr_off_t arg6 ;
    apr_off_t arg7 ;
    apr_off_t arg8 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    long long val3 ;
    int ecode3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    long long val5 ;
    int ecode5 = 0 ;
    long long val6 ;
    int ecode6 = 0 ;
    long long val7 ;
    int ecode7 = 0 ;
    long long val8 ;
    int ecode8 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 8) || (items > 8)) {
      SWIG_croak("Usage: svn_diff_output_fns_invoke_output_diff_common(_obj,output_baton,original_start,original_length,modified_start,modified_length,latest_start,latest_length);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "3"" of type '" "apr_off_t""'");
    } 
    arg3 = (apr_off_t)(val3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "4"" of type '" "apr_off_t""'");
    } 
    arg4 = (apr_off_t)(val4);
    ecode5 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "5"" of type '" "apr_off_t""'");
    } 
    arg5 = (apr_off_t)(val5);
    ecode6 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "6"" of type '" "apr_off_t""'");
    } 
    arg6 = (apr_off_t)(val6);
    ecode7 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "7"" of type '" "apr_off_t""'");
    } 
    arg7 = (apr_off_t)(val7);
    ecode8 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_diff_output_fns_invoke_output_diff_common" "', argument " "8"" of type '" "apr_off_t""'");
    } 
    arg8 = (apr_off_t)(val8);
    {
      result = (svn_error_t *)svn_diff_output_fns_invoke_output_diff_common(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_diff_output_fns_invoke_output_conflict) {
  {
    svn_diff_output_fns_t *arg1 = (svn_diff_output_fns_t *) 0 ;
    void *arg2 = (void *) 0 ;
    apr_off_t arg3 ;
    apr_off_t arg4 ;
    apr_off_t arg5 ;
    apr_off_t arg6 ;
    apr_off_t arg7 ;
    apr_off_t arg8 ;
    svn_diff_t *arg9 = (svn_diff_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    long long val3 ;
    int ecode3 = 0 ;
    long long val4 ;
    int ecode4 = 0 ;
    long long val5 ;
    int ecode5 = 0 ;
    long long val6 ;
    int ecode6 = 0 ;
    long long val7 ;
    int ecode7 = 0 ;
    long long val8 ;
    int ecode8 = 0 ;
    void *argp9 = 0 ;
    int res9 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 9) || (items > 9)) {
      SWIG_croak("Usage: svn_diff_output_fns_invoke_output_conflict(_obj,output_baton,original_start,original_length,modified_start,modified_length,latest_start,latest_length,resolved_diff);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_diff_output_fns_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "1"" of type '" "svn_diff_output_fns_t *""'"); 
    }
    arg1 = (svn_diff_output_fns_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "2"" of type '" "void *""'"); 
    }
    ecode3 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "3"" of type '" "apr_off_t""'");
    } 
    arg3 = (apr_off_t)(val3);
    ecode4 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "4"" of type '" "apr_off_t""'");
    } 
    arg4 = (apr_off_t)(val4);
    ecode5 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "5"" of type '" "apr_off_t""'");
    } 
    arg5 = (apr_off_t)(val5);
    ecode6 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "6"" of type '" "apr_off_t""'");
    } 
    arg6 = (apr_off_t)(val6);
    ecode7 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "7"" of type '" "apr_off_t""'");
    } 
    arg7 = (apr_off_t)(val7);
    ecode8 = SWIG_AsVal_long_SS_long SWIG_PERL_CALL_ARGS_2(ST(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "8"" of type '" "apr_off_t""'");
    } 
    arg8 = (apr_off_t)(val8);
    res9 = SWIG_ConvertPtr(ST(8), &argp9,SWIGTYPE_p_svn_diff_t, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "svn_diff_output_fns_invoke_output_conflict" "', argument " "9"" of type '" "svn_diff_t *""'"); 
    }
    arg9 = (svn_diff_t *)(argp9);
    {
      result = (svn_error_t *)svn_diff_output_fns_invoke_output_conflict(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    
    
    
    
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    
    
    
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_strerror) {
  {
    apr_status_t arg1 ;
    char *arg2 = (char *) 0 ;
    apr_size_t arg3 ;
    int val1 ;
    int ecode1 = 0 ;
    char temp2[128] ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      memset (temp2,0,128); /* paranoia */
      arg2 = temp2;
      arg3 = 128;
    }
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_strerror(statcode,bufsize);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_strerror" "', argument " "1"" of type '" "apr_status_t""'");
    } 
    arg1 = (apr_status_t)(val1);
    {
      result = (char *)svn_strerror(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_err_best_message) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    char *arg2 = (char *) 0 ;
    apr_size_t arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char temp2[128] ;
    int argvi = 0;
    char *result = 0 ;
    dXSARGS;
    
    {
      memset (temp2,0,128); /* paranoia */
      arg2 = temp2;
      arg3 = 128;
    }
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_err_best_message(err,bufsize);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_err_best_message" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      result = (char *)svn_err_best_message(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = SWIG_FromCharPtr((const char *)result); argvi++ ;
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_create) {
  {
    apr_status_t arg1 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    char *arg3 = (char *) 0 ;
    int val1 ;
    int ecode1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_error_create(apr_err,child,message);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error_create" "', argument " "1"" of type '" "apr_status_t""'");
    } 
    arg1 = (apr_status_t)(val1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_create" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_error_create" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    {
      result = (svn_error_t *)svn_error_create(arg1,arg2,(char const *)arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_createf) {
  {
    apr_status_t arg1 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    char *arg3 = (char *) 0 ;
    void *arg4 = 0 ;
    int val1 ;
    int ecode1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if (items < 3) {
      SWIG_croak("Usage: svn_error_createf(apr_err,child,fmt,...);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error_createf" "', argument " "1"" of type '" "apr_status_t""'");
    } 
    arg1 = (apr_status_t)(val1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_createf" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_error_createf" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    {
      result = (svn_error_t *)svn_error_createf(arg1,arg2,(char const *)arg3,arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_wrap_apr) {
  {
    apr_status_t arg1 ;
    char *arg2 = (char *) 0 ;
    void *arg3 = 0 ;
    int val1 ;
    int ecode1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if (items < 2) {
      SWIG_croak("Usage: svn_error_wrap_apr(status,fmt,...);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error_wrap_apr" "', argument " "1"" of type '" "apr_status_t""'");
    } 
    arg1 = (apr_status_t)(val1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_wrap_apr" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_error_t *)svn_error_wrap_apr(arg1,(char const *)arg2,arg3);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_quick_wrap) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_quick_wrap(child,new_msg);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_quick_wrap" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_quick_wrap" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    {
      result = (svn_error_t *)svn_error_quick_wrap(arg1,(char const *)arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_compose_create) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_compose_create(err1,err2);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_compose_create" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_compose_create" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    {
      result = (svn_error_t *)svn_error_compose_create(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_compose) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_compose(chain,new_err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_compose" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_compose" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    {
      svn_error_compose(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_root_cause) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_root_cause(err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_root_cause" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      result = (svn_error_t *)svn_error_root_cause(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_find_cause) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    apr_status_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_error_find_cause(err,apr_err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_find_cause" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_error_find_cause" "', argument " "2"" of type '" "apr_status_t""'");
    } 
    arg2 = (apr_status_t)(val2);
    {
      result = (svn_error_t *)svn_error_find_cause(arg1,arg2);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_dup) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_dup(err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_dup" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      result = (svn_error_t *)svn_error_dup(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_clear) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_clear(error);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_clear" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      svn_error_clear(arg1);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_handle_error2) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    svn_boolean_t arg3 ;
    char *arg4 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_handle_error2(error,stream,fatal,prefix);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_handle_error2" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      arg2 = PerlIO_exportFILE (IoIFP (sv_2io (ST(1))), NULL);
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_handle_error2" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_handle_error2" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      svn_handle_error2(arg1,arg2,arg3,(char const *)arg4);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_handle_error) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    svn_boolean_t arg3 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_handle_error(error,stream,fatal);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_handle_error" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      arg2 = PerlIO_exportFILE (IoIFP (sv_2io (ST(1))), NULL);
    }
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_handle_error" "', argument " "3"" of type '" "svn_boolean_t""'");
    } 
    arg3 = (svn_boolean_t)(val3);
    {
      svn_handle_error(arg1,arg2,arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    
    XSRETURN(argvi);
  fail:
    
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_handle_warning2) {
  {
    FILE *arg1 = (FILE *) 0 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    char *arg3 = (char *) 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
      SWIG_croak("Usage: svn_handle_warning2(stream,error,prefix);");
    }
    {
      arg1 = PerlIO_exportFILE (IoIFP (sv_2io (ST(0))), NULL);
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_handle_warning2" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_handle_warning2" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    {
      svn_handle_warning2(arg1,arg2,(char const *)arg3);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_handle_warning) {
  {
    FILE *arg1 = (FILE *) 0 ;
    svn_error_t *arg2 = (svn_error_t *) 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
      SWIG_croak("Usage: svn_handle_warning(stream,error);");
    }
    {
      arg1 = PerlIO_exportFILE (IoIFP (sv_2io (ST(0))), NULL);
    }
    res2 = SWIG_ConvertPtr(ST(1), &argp2,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_handle_warning" "', argument " "2"" of type '" "svn_error_t *""'"); 
    }
    arg2 = (svn_error_t *)(argp2);
    {
      svn_handle_warning(arg1,arg2);
      
      
      
    }
    ST(argvi) = sv_newmortal();
    
    
    XSRETURN(argvi);
  fail:
    
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_purge_tracing) {
  {
    svn_error_t *arg1 = (svn_error_t *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_purge_tracing(err);");
    }
    res1 = SWIG_ConvertPtr(ST(0), &argp1,SWIGTYPE_p_svn_error_t, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "svn_error_purge_tracing" "', argument " "1"" of type '" "svn_error_t *""'"); 
    }
    arg1 = (svn_error_t *)(argp1);
    {
      result = (svn_error_t *)svn_error_purge_tracing(arg1);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error__malfunction) {
  {
    svn_boolean_t arg1 ;
    char *arg2 = (char *) 0 ;
    int arg3 ;
    char *arg4 = (char *) 0 ;
    int val1 ;
    int ecode1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_error__malfunction(can_return,file,line,expr);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error__malfunction" "', argument " "1"" of type '" "svn_boolean_t""'");
    } 
    arg1 = (svn_boolean_t)(val1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error__malfunction" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_error__malfunction" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_error__malfunction" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      result = (svn_error_t *)svn_error__malfunction(arg1,(char const *)arg2,arg3,(char const *)arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_set_malfunction_handler) {
  {
    svn_error_malfunction_handler_t arg1 = (svn_error_malfunction_handler_t) 0 ;
    int argvi = 0;
    svn_error_malfunction_handler_t result;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
      SWIG_croak("Usage: svn_error_set_malfunction_handler(func);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_error_set_malfunction_handler" "', argument " "1"" of type '" "svn_error_malfunction_handler_t""'"); 
      }
    }
    {
      result = (svn_error_malfunction_handler_t)svn_error_set_malfunction_handler(arg1);
      
      
      
    }
    ST(argvi) = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t); argvi++ ;
    
    XSRETURN(argvi);
  fail:
    
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_raise_on_malfunction) {
  {
    svn_boolean_t arg1 ;
    char *arg2 = (char *) 0 ;
    int arg3 ;
    char *arg4 = (char *) 0 ;
    int val1 ;
    int ecode1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_error_raise_on_malfunction(can_return,file,line,expr);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error_raise_on_malfunction" "', argument " "1"" of type '" "svn_boolean_t""'");
    } 
    arg1 = (svn_boolean_t)(val1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_raise_on_malfunction" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_error_raise_on_malfunction" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_error_raise_on_malfunction" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      result = (svn_error_t *)svn_error_raise_on_malfunction(arg1,(char const *)arg2,arg3,(char const *)arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_abort_on_malfunction) {
  {
    svn_boolean_t arg1 ;
    char *arg2 = (char *) 0 ;
    int arg3 ;
    char *arg4 = (char *) 0 ;
    int val1 ;
    int ecode1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    int val3 ;
    int ecode3 = 0 ;
    int res4 ;
    char *buf4 = 0 ;
    int alloc4 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
      SWIG_croak("Usage: svn_error_abort_on_malfunction(can_return,file,line,expr);");
    }
    ecode1 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "svn_error_abort_on_malfunction" "', argument " "1"" of type '" "svn_boolean_t""'");
    } 
    arg1 = (svn_boolean_t)(val1);
    res2 = SWIG_AsCharPtrAndSize(ST(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "svn_error_abort_on_malfunction" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
    ecode3 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "svn_error_abort_on_malfunction" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
    res4 = SWIG_AsCharPtrAndSize(ST(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "svn_error_abort_on_malfunction" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
    {
      result = (svn_error_t *)svn_error_abort_on_malfunction(arg1,(char const *)arg2,arg3,(char const *)arg4);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    XSRETURN(argvi);
  fail:
    
    if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
    
    if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
    SWIG_croak_null();
  }
}


XS(_wrap_svn_error_invoke_malfunction_handler) {
  {
    svn_error_malfunction_handler_t arg1 = (svn_error_malfunction_handler_t) 0 ;
    svn_boolean_t arg2 ;
    char *arg3 = (char *) 0 ;
    int arg4 ;
    char *arg5 = (char *) 0 ;
    int val2 ;
    int ecode2 = 0 ;
    int res3 ;
    char *buf3 = 0 ;
    int alloc3 = 0 ;
    int val4 ;
    int ecode4 = 0 ;
    int res5 ;
    char *buf5 = 0 ;
    int alloc5 = 0 ;
    int argvi = 0;
    svn_error_t *result = 0 ;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
      SWIG_croak("Usage: svn_error_invoke_malfunction_handler(_obj,can_return,file,line,expr);");
    }
    {
      int res = SWIG_ConvertFunctionPtr(ST(0), (void**)(&arg1), SWIGTYPE_p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "svn_error_invoke_malfunction_handler" "', argument " "1"" of type '" "svn_error_malfunction_handler_t""'"); 
      }
    }
    ecode2 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "svn_error_invoke_malfunction_handler" "', argument " "2"" of type '" "svn_boolean_t""'");
    } 
    arg2 = (svn_boolean_t)(val2);
    res3 = SWIG_AsCharPtrAndSize(ST(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "svn_error_invoke_malfunction_handler" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
    ecode4 = SWIG_AsVal_int SWIG_PERL_CALL_ARGS_2(ST(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "svn_error_invoke_malfunction_handler" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
    res5 = SWIG_AsCharPtrAndSize(ST(4), &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "svn_error_invoke_malfunction_handler" "', argument " "5"" of type '" "char const *""'");
    }
    arg5 = (char *)(buf5);
    {
      result = (svn_error_t *)svn_error_invoke_malfunction_handler(arg1,arg2,(char const *)arg3,arg4,(char const *)arg5);
      
      
      
    }
    {
      if (result) {
        SV *exception_handler = perl_get_sv ("SVN::Error::handler", FALSE);
        
        if (SvOK(exception_handler)) {
          SV *callback_result;
          
          svn_swig_pl_callback_thunk (CALL_SV, exception_handler,
            &callback_result, "S", result,
            SWIGTYPE_p_svn_error_t);
        } else {
          ST(argvi) = SWIG_NewPointerObj(result, SWIGTYPE_p_svn_error_t, 0);
          argvi++;
        }
      }
    }
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    XSRETURN(argvi);
  fail:
    
    
    if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
    
    if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
    SWIG_croak_null();
  }
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_FILE = {"_p_FILE", "FILE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_allocator_t = {"_p_apr_allocator_t", "apr_allocator_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_array_header_t = {"_p_apr_array_header_t", "apr_array_header_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_dir_t = {"_p_apr_dir_t", "apr_dir_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_file_t = {"_p_apr_file_t", "apr_file_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_finfo_t = {"_p_apr_finfo_t", "apr_finfo_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_getopt_option_t = {"_p_apr_getopt_option_t", "apr_getopt_option_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_getopt_t = {"_p_apr_getopt_t", "apr_getopt_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_hash_index_t = {"_p_apr_hash_index_t", "apr_hash_index_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_hash_t = {"_p_apr_hash_t", "svn_mergeinfo_catalog_t|svn_mergeinfo_t|apr_hash_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_int32_t = {"_p_apr_int32_t", "apr_int32_t *|time_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_int64_t = {"_p_apr_int64_t", "apr_int64_t *|svn_filesize_t *|apr_time_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_off_t = {"_p_apr_off_t", "apr_off_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_pool_t = {"_p_apr_pool_t", "apr_pool_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_proc_t = {"_p_apr_proc_t", "apr_proc_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_size_t = {"_p_apr_size_t", "apr_size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_apr_uint32_t = {"_p_apr_uint32_t", "apr_uint32_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t = {"_p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t", "svn_opt_subcommand_t *|struct svn_error_t *(*)(apr_getopt_t *,void *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t = {"_p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t", "struct svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)|svn_error_t *(*)(apr_uint32_t *,void **,void *,svn_diff_datasource_e)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void = {"_p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void", "svn_auth_simple_provider_func_t|svn_auth_ssl_client_cert_pw_provider_func_t|void (*)(struct svn_auth_provider_object_t **,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t", "svn_auth_simple_prompt_func_t|struct svn_error_t *(*)(svn_auth_cred_simple_t **,void *,char const *,char const *,svn_boolean_t,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t", "svn_auth_ssl_client_cert_pw_prompt_func_t|struct svn_error_t *(*)(svn_auth_cred_ssl_client_cert_pw_t **,void *,char const *,svn_boolean_t,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t", "svn_auth_ssl_client_cert_prompt_func_t|struct svn_error_t *(*)(svn_auth_cred_ssl_client_cert_t **,void *,char const *,svn_boolean_t,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(svn_auth_cred_ssl_server_trust_t **,void *,char const *,apr_uint32_t,svn_auth_ssl_server_cert_info_t const *,svn_boolean_t,apr_pool_t *)|svn_auth_ssl_server_trust_prompt_func_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(svn_auth_cred_username_t **,void *,char const *,svn_boolean_t,apr_pool_t *)|svn_auth_username_prompt_func_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *)|svn_error_t *(*)(void **,void **,void *,apr_hash_t *,char const *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t = {"_p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t", "svn_error_t *(*)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *)|struct svn_error_t *(*)(void **,void *,void *,apr_hash_t *,char const *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_q_const__char_p_void__int = {"_p_f_p_q_const__char_p_q_const__char_p_void__int", "svn_config_enumerator_t|int (*)(char const *,char const *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int = {"_p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int", "svn_config_enumerator2_t|int (*)(char const *,char const *,void *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_void__int = {"_p_f_p_q_const__char_p_void__int", "svn_config_section_enumerator_t|int (*)(char const *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_void_p_apr_pool_t__int = {"_p_f_p_q_const__char_p_void_p_apr_pool_t__int", "int (*)(char const *,void *,apr_pool_t *)|svn_config_section_enumerator2_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t = {"_p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t", "svn_commit_callback2_t|struct svn_error_t *(*)(svn_commit_info_t const *,void *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t = {"_p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(svn_boolean_t *,char const *,void *,apr_pool_t *)|svn_auth_plaintext_prompt_func_t|svn_auth_plaintext_passphrase_prompt_func_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t = {"_p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t", "svn_error_t *(*)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *)|struct svn_error_t *(*)(svn_boolean_t *,void *,void *,apr_hash_t *,char const *,apr_pool_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t = {"_p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(svn_location_segment_t *,void *,apr_pool_t *)|svn_location_segment_receiver_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void__p_svn_error_t = {"_p_f_p_void__p_svn_error_t", "svn_cancel_func_t|svn_close_fn_t|struct svn_error_t *(*)(void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void__void = {"_p_f_p_void__void", "void (*)(void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t = {"_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t", "struct svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)|svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t = {"_p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t", "struct svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *)|svn_error_t *(*)(void *,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,svn_diff_t *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_apr_size_t__p_svn_error_t = {"_p_f_p_void_apr_size_t__p_svn_error_t", "struct svn_error_t *(*)(void *,apr_size_t)|svn_stream_skip_fn_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t = {"_p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(void *,apr_hash_t *,svn_revnum_t,char const *,char const *,char const *,apr_pool_t *)|svn_log_message_receiver_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t = {"_p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t", "svn_error_t *(*)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t)|struct svn_error_t *(*)(void *,apr_off_t *,apr_off_t *,svn_diff_datasource_e const *,apr_size_t)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_char_p_apr_size_t__p_svn_error_t = {"_p_f_p_void_p_char_p_apr_size_t__p_svn_error_t", "struct svn_error_t *(*)(void *,char *,apr_size_t *)|svn_read_fn_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(void *,svn_stream_mark_t **,apr_pool_t *)|svn_stream_mark_fn_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t = {"_p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t", "struct svn_error_t *(*)(void *,char const *,apr_size_t *)|svn_write_fn_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(void *,char const *,apr_finfo_t const *,apr_pool_t *)|svn_io_walk_func_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t = {"_p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t", "svn_stream_seek_fn_t|struct svn_error_t *(*)(void *,svn_stream_mark_t const *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t = {"_p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t", "struct svn_error_t *(*)(void *,svn_log_entry_t *,apr_pool_t *)|svn_log_entry_receiver_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_void__void = {"_p_f_p_void_p_void__void", "void (*)(void *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_void_p_void_p_int__p_svn_error_t = {"_p_f_p_void_p_void_p_void_p_int__p_svn_error_t", "svn_error_t *(*)(void *,void *,void *,int *)|struct svn_error_t *(*)(void *,void *,void *,int *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_svn_diff_datasource_e__p_svn_error_t = {"_p_f_p_void_svn_diff_datasource_e__p_svn_error_t", "struct svn_error_t *(*)(void *,svn_diff_datasource_e)|svn_error_t *(*)(void *,svn_diff_datasource_e)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t = {"_p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t", "struct svn_error_t *(*)(svn_boolean_t,char const *,int,char const *)|svn_error_malfunction_handler_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t = {"_p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t", "struct svn_error_t *(*)(svn_revnum_t,char const *,char const *,void *)|svn_commit_callback_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_void__p_svn_version_t = {"_p_f_void__p_svn_version_t", "svn_version_func_t|struct svn_version_t *(*)(void)|svn_version_t *(*)(void)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|svn_boolean_t *|apr_status_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *|svn_revnum_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_apr_array_header_t = {"_p_p_apr_array_header_t", "apr_array_header_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_apr_file_t = {"_p_p_apr_file_t", "apr_file_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_apr_hash_t = {"_p_p_apr_hash_t", "apr_hash_t **|svn_mergeinfo_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_baton_t = {"_p_p_svn_auth_baton_t", "struct svn_auth_baton_t **|svn_auth_baton_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_cred_simple_t = {"_p_p_svn_auth_cred_simple_t", "struct svn_auth_cred_simple_t **|svn_auth_cred_simple_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_cred_ssl_client_cert_pw_t = {"_p_p_svn_auth_cred_ssl_client_cert_pw_t", "struct svn_auth_cred_ssl_client_cert_pw_t **|svn_auth_cred_ssl_client_cert_pw_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_cred_ssl_client_cert_t = {"_p_p_svn_auth_cred_ssl_client_cert_t", "struct svn_auth_cred_ssl_client_cert_t **|svn_auth_cred_ssl_client_cert_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_cred_ssl_server_trust_t = {"_p_p_svn_auth_cred_ssl_server_trust_t", "struct svn_auth_cred_ssl_server_trust_t **|svn_auth_cred_ssl_server_trust_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_cred_username_t = {"_p_p_svn_auth_cred_username_t", "struct svn_auth_cred_username_t **|svn_auth_cred_username_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_iterstate_t = {"_p_p_svn_auth_iterstate_t", "struct svn_auth_iterstate_t **|svn_auth_iterstate_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_auth_provider_object_t = {"_p_p_svn_auth_provider_object_t", "struct svn_auth_provider_object_t **|svn_auth_provider_object_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_checksum_t = {"_p_p_svn_checksum_t", "svn_checksum_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_config_t = {"_p_p_svn_config_t", "struct svn_config_t **|svn_config_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_diff_t = {"_p_p_svn_diff_t", "struct svn_diff_t **|svn_diff_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_io_dirent2_t = {"_p_p_svn_io_dirent2_t", "struct svn_io_dirent2_t **|svn_io_dirent2_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_patch_file_t = {"_p_p_svn_patch_file_t", "struct svn_patch_file_t **|svn_patch_file_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_patch_t = {"_p_p_svn_patch_t", "struct svn_patch_t **|svn_patch_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_stream_mark_t = {"_p_p_svn_stream_mark_t", "struct svn_stream_mark_t **|svn_stream_mark_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_stream_t = {"_p_p_svn_stream_t", "struct svn_stream_t **|svn_stream_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_string_t = {"_p_p_svn_string_t", "struct svn_string_t **|svn_string_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_svn_stringbuf_t = {"_p_p_svn_stringbuf_t", "struct svn_stringbuf_t **|svn_stringbuf_t **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_baton_t = {"_p_svn_auth_baton_t", "struct svn_auth_baton_t *|svn_auth_baton_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_cred_simple_t = {"_p_svn_auth_cred_simple_t", "struct svn_auth_cred_simple_t *|svn_auth_cred_simple_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_cred_ssl_client_cert_pw_t = {"_p_svn_auth_cred_ssl_client_cert_pw_t", "struct svn_auth_cred_ssl_client_cert_pw_t *|svn_auth_cred_ssl_client_cert_pw_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_cred_ssl_client_cert_t = {"_p_svn_auth_cred_ssl_client_cert_t", "struct svn_auth_cred_ssl_client_cert_t *|svn_auth_cred_ssl_client_cert_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_cred_ssl_server_trust_t = {"_p_svn_auth_cred_ssl_server_trust_t", "struct svn_auth_cred_ssl_server_trust_t *|svn_auth_cred_ssl_server_trust_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_cred_username_t = {"_p_svn_auth_cred_username_t", "struct svn_auth_cred_username_t *|svn_auth_cred_username_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_iterstate_t = {"_p_svn_auth_iterstate_t", "struct svn_auth_iterstate_t *|svn_auth_iterstate_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_provider_object_t = {"_p_svn_auth_provider_object_t", "struct svn_auth_provider_object_t *|svn_auth_provider_object_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_provider_t = {"_p_svn_auth_provider_t", "struct svn_auth_provider_t *|svn_auth_provider_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_auth_ssl_server_cert_info_t = {"_p_svn_auth_ssl_server_cert_info_t", "struct svn_auth_ssl_server_cert_info_t *|svn_auth_ssl_server_cert_info_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_checksum_kind_t = {"_p_svn_checksum_kind_t", "svn_checksum_kind_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_commit_info_t = {"_p_svn_commit_info_t", "struct svn_commit_info_t *|svn_commit_info_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_config_t = {"_p_svn_config_t", "struct svn_config_t *|svn_config_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_depth_t = {"_p_svn_depth_t", "enum svn_depth_t *|svn_depth_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_conflict_display_style_t = {"_p_svn_diff_conflict_display_style_t", "enum svn_diff_conflict_display_style_t *|svn_diff_conflict_display_style_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_datasource_e = {"_p_svn_diff_datasource_e", "enum svn_diff_datasource_e *|svn_diff_datasource_e *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_file_ignore_space_t = {"_p_svn_diff_file_ignore_space_t", "enum svn_diff_file_ignore_space_t *|svn_diff_file_ignore_space_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_file_options_t = {"_p_svn_diff_file_options_t", "struct svn_diff_file_options_t *|svn_diff_file_options_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_fns2_t = {"_p_svn_diff_fns2_t", "struct svn_diff_fns2_t *|svn_diff_fns2_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_fns_t = {"_p_svn_diff_fns_t", "struct svn_diff_fns_t *|svn_diff_fns_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_hunk_t = {"_p_svn_diff_hunk_t", "struct svn_diff_hunk_t *|svn_diff_hunk_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_operation_kind_e = {"_p_svn_diff_operation_kind_e", "svn_diff_operation_kind_t *|enum svn_diff_operation_kind_e *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_output_fns_t = {"_p_svn_diff_output_fns_t", "struct svn_diff_output_fns_t *|svn_diff_output_fns_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_diff_t = {"_p_svn_diff_t", "struct svn_diff_t *|svn_diff_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_dirent_t = {"_p_svn_dirent_t", "struct svn_dirent_t *|svn_dirent_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_errno_t = {"_p_svn_errno_t", "enum svn_errno_t *|svn_errno_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_error_t = {"_p_svn_error_t", "struct svn_error_t *|svn_error_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_io_dirent2_t = {"_p_svn_io_dirent2_t", "struct svn_io_dirent2_t *|svn_io_dirent2_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_io_dirent_t = {"_p_svn_io_dirent_t", "struct svn_io_dirent_t *|svn_io_dirent_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_io_file_del_t = {"_p_svn_io_file_del_t", "enum svn_io_file_del_t *|svn_io_file_del_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_location_segment_t = {"_p_svn_location_segment_t", "struct svn_location_segment_t *|svn_location_segment_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_lock_t = {"_p_svn_lock_t", "struct svn_lock_t *|svn_lock_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_log_changed_path2_t = {"_p_svn_log_changed_path2_t", "struct svn_log_changed_path2_t *|svn_log_changed_path2_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_log_changed_path_t = {"_p_svn_log_changed_path_t", "struct svn_log_changed_path_t *|svn_log_changed_path_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_log_entry_t = {"_p_svn_log_entry_t", "struct svn_log_entry_t *|svn_log_entry_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_merge_range_t = {"_p_svn_merge_range_t", "struct svn_merge_range_t *|svn_merge_range_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_mergeinfo_inheritance_t = {"_p_svn_mergeinfo_inheritance_t", "enum svn_mergeinfo_inheritance_t *|svn_mergeinfo_inheritance_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_node_kind_t = {"_p_svn_node_kind_t", "enum svn_node_kind_t *|svn_node_kind_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_revision_range_t = {"_p_svn_opt_revision_range_t", "struct svn_opt_revision_range_t *|svn_opt_revision_range_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_revision_t = {"_p_svn_opt_revision_t", "struct svn_opt_revision_t *|svn_opt_revision_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_revision_value_t = {"_p_svn_opt_revision_value_t", "union svn_opt_revision_value_t *|svn_opt_revision_value_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_subcommand_desc2_t = {"_p_svn_opt_subcommand_desc2_t", "struct svn_opt_subcommand_desc2_t *|svn_opt_subcommand_desc2_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_subcommand_desc2_t_desc_overrides = {"_p_svn_opt_subcommand_desc2_t_desc_overrides", "svn_opt_subcommand_desc2_t_desc_overrides *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_opt_subcommand_desc_t = {"_p_svn_opt_subcommand_desc_t", "struct svn_opt_subcommand_desc_t *|svn_opt_subcommand_desc_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_patch_file_t = {"_p_svn_patch_file_t", "struct svn_patch_file_t *|svn_patch_file_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_patch_t = {"_p_svn_patch_t", "struct svn_patch_t *|svn_patch_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_prop_kind = {"_p_svn_prop_kind", "svn_prop_kind_t *|enum svn_prop_kind *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_prop_patch_t = {"_p_svn_prop_patch_t", "struct svn_prop_patch_t *|svn_prop_patch_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_prop_t = {"_p_svn_prop_t", "struct svn_prop_t *|svn_prop_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_stream_mark_t = {"_p_svn_stream_mark_t", "struct svn_stream_mark_t *|svn_stream_mark_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_stream_t = {"_p_svn_stream_t", "struct svn_stream_t *|svn_stream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_string_t = {"_p_svn_string_t", "struct svn_string_t *|svn_string_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_stringbuf_t = {"_p_svn_stringbuf_t", "struct svn_stringbuf_t *|svn_stringbuf_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_tristate_t = {"_p_svn_tristate_t", "enum svn_tristate_t *|svn_tristate_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_version_checklist_t = {"_p_svn_version_checklist_t", "struct svn_version_checklist_t *|svn_version_checklist_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_svn_version_t = {"_p_svn_version_t", "struct svn_version_t *|svn_version_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|svn_linenum_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_FILE,
  &_swigt__p_apr_allocator_t,
  &_swigt__p_apr_array_header_t,
  &_swigt__p_apr_dir_t,
  &_swigt__p_apr_file_t,
  &_swigt__p_apr_finfo_t,
  &_swigt__p_apr_getopt_option_t,
  &_swigt__p_apr_getopt_t,
  &_swigt__p_apr_hash_index_t,
  &_swigt__p_apr_hash_t,
  &_swigt__p_apr_int32_t,
  &_swigt__p_apr_int64_t,
  &_swigt__p_apr_off_t,
  &_swigt__p_apr_pool_t,
  &_swigt__p_apr_proc_t,
  &_swigt__p_apr_size_t,
  &_swigt__p_apr_uint32_t,
  &_swigt__p_char,
  &_swigt__p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t,
  &_swigt__p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void,
  &_swigt__p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_q_const__char_p_q_const__char_p_void__int,
  &_swigt__p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int,
  &_swigt__p_f_p_q_const__char_p_void__int,
  &_swigt__p_f_p_q_const__char_p_void_p_apr_pool_t__int,
  &_swigt__p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_void__p_svn_error_t,
  &_swigt__p_f_p_void__void,
  &_swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t,
  &_swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t,
  &_swigt__p_f_p_void_apr_size_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_char_p_apr_size_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t,
  &_swigt__p_f_p_void_p_void__void,
  &_swigt__p_f_p_void_p_void_p_void_p_int__p_svn_error_t,
  &_swigt__p_f_p_void_svn_diff_datasource_e__p_svn_error_t,
  &_swigt__p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t,
  &_swigt__p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t,
  &_swigt__p_f_void__p_svn_version_t,
  &_swigt__p_int,
  &_swigt__p_long,
  &_swigt__p_p_apr_array_header_t,
  &_swigt__p_p_apr_file_t,
  &_swigt__p_p_apr_hash_t,
  &_swigt__p_p_char,
  &_swigt__p_p_svn_auth_baton_t,
  &_swigt__p_p_svn_auth_cred_simple_t,
  &_swigt__p_p_svn_auth_cred_ssl_client_cert_pw_t,
  &_swigt__p_p_svn_auth_cred_ssl_client_cert_t,
  &_swigt__p_p_svn_auth_cred_ssl_server_trust_t,
  &_swigt__p_p_svn_auth_cred_username_t,
  &_swigt__p_p_svn_auth_iterstate_t,
  &_swigt__p_p_svn_auth_provider_object_t,
  &_swigt__p_p_svn_checksum_t,
  &_swigt__p_p_svn_config_t,
  &_swigt__p_p_svn_diff_t,
  &_swigt__p_p_svn_io_dirent2_t,
  &_swigt__p_p_svn_patch_file_t,
  &_swigt__p_p_svn_patch_t,
  &_swigt__p_p_svn_stream_mark_t,
  &_swigt__p_p_svn_stream_t,
  &_swigt__p_p_svn_string_t,
  &_swigt__p_p_svn_stringbuf_t,
  &_swigt__p_p_void,
  &_swigt__p_svn_auth_baton_t,
  &_swigt__p_svn_auth_cred_simple_t,
  &_swigt__p_svn_auth_cred_ssl_client_cert_pw_t,
  &_swigt__p_svn_auth_cred_ssl_client_cert_t,
  &_swigt__p_svn_auth_cred_ssl_server_trust_t,
  &_swigt__p_svn_auth_cred_username_t,
  &_swigt__p_svn_auth_iterstate_t,
  &_swigt__p_svn_auth_provider_object_t,
  &_swigt__p_svn_auth_provider_t,
  &_swigt__p_svn_auth_ssl_server_cert_info_t,
  &_swigt__p_svn_checksum_kind_t,
  &_swigt__p_svn_commit_info_t,
  &_swigt__p_svn_config_t,
  &_swigt__p_svn_depth_t,
  &_swigt__p_svn_diff_conflict_display_style_t,
  &_swigt__p_svn_diff_datasource_e,
  &_swigt__p_svn_diff_file_ignore_space_t,
  &_swigt__p_svn_diff_file_options_t,
  &_swigt__p_svn_diff_fns2_t,
  &_swigt__p_svn_diff_fns_t,
  &_swigt__p_svn_diff_hunk_t,
  &_swigt__p_svn_diff_operation_kind_e,
  &_swigt__p_svn_diff_output_fns_t,
  &_swigt__p_svn_diff_t,
  &_swigt__p_svn_dirent_t,
  &_swigt__p_svn_errno_t,
  &_swigt__p_svn_error_t,
  &_swigt__p_svn_io_dirent2_t,
  &_swigt__p_svn_io_dirent_t,
  &_swigt__p_svn_io_file_del_t,
  &_swigt__p_svn_location_segment_t,
  &_swigt__p_svn_lock_t,
  &_swigt__p_svn_log_changed_path2_t,
  &_swigt__p_svn_log_changed_path_t,
  &_swigt__p_svn_log_entry_t,
  &_swigt__p_svn_merge_range_t,
  &_swigt__p_svn_mergeinfo_inheritance_t,
  &_swigt__p_svn_node_kind_t,
  &_swigt__p_svn_opt_revision_range_t,
  &_swigt__p_svn_opt_revision_t,
  &_swigt__p_svn_opt_revision_value_t,
  &_swigt__p_svn_opt_subcommand_desc2_t,
  &_swigt__p_svn_opt_subcommand_desc2_t_desc_overrides,
  &_swigt__p_svn_opt_subcommand_desc_t,
  &_swigt__p_svn_patch_file_t,
  &_swigt__p_svn_patch_t,
  &_swigt__p_svn_prop_kind,
  &_swigt__p_svn_prop_patch_t,
  &_swigt__p_svn_prop_t,
  &_swigt__p_svn_stream_mark_t,
  &_swigt__p_svn_stream_t,
  &_swigt__p_svn_string_t,
  &_swigt__p_svn_stringbuf_t,
  &_swigt__p_svn_tristate_t,
  &_swigt__p_svn_version_checklist_t,
  &_swigt__p_svn_version_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_long,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_FILE[] = {  {&_swigt__p_FILE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_allocator_t[] = {  {&_swigt__p_apr_allocator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_array_header_t[] = {  {&_swigt__p_apr_array_header_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_dir_t[] = {  {&_swigt__p_apr_dir_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_file_t[] = {  {&_swigt__p_apr_file_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_finfo_t[] = {  {&_swigt__p_apr_finfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_getopt_option_t[] = {  {&_swigt__p_apr_getopt_option_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_getopt_t[] = {  {&_swigt__p_apr_getopt_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_hash_index_t[] = {  {&_swigt__p_apr_hash_index_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_hash_t[] = {  {&_swigt__p_apr_hash_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_int32_t[] = {  {&_swigt__p_apr_int32_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_int64_t[] = {  {&_swigt__p_apr_int64_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_off_t[] = {  {&_swigt__p_apr_off_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_pool_t[] = {  {&_swigt__p_apr_pool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_proc_t[] = {  {&_swigt__p_apr_proc_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_size_t[] = {  {&_swigt__p_apr_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_apr_uint32_t[] = {  {&_swigt__p_apr_uint32_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t[] = {  {&_swigt__p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void[] = {  {&_swigt__p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_q_const__char_p_void__int[] = {  {&_swigt__p_f_p_q_const__char_p_q_const__char_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int[] = {  {&_swigt__p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_void__int[] = {  {&_swigt__p_f_p_q_const__char_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_void_p_apr_pool_t__int[] = {  {&_swigt__p_f_p_q_const__char_p_void_p_apr_pool_t__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void__p_svn_error_t[] = {  {&_swigt__p_f_p_void__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void__void[] = {  {&_swigt__p_f_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_apr_size_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_apr_size_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_char_p_apr_size_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_char_p_apr_size_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_void__void[] = {  {&_swigt__p_f_p_void_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_void_p_void_p_int__p_svn_error_t[] = {  {&_swigt__p_f_p_void_p_void_p_void_p_int__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_svn_diff_datasource_e__p_svn_error_t[] = {  {&_swigt__p_f_p_void_svn_diff_datasource_e__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t[] = {  {&_swigt__p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t[] = {  {&_swigt__p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_void__p_svn_version_t[] = {  {&_swigt__p_f_void__p_svn_version_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_apr_array_header_t[] = {  {&_swigt__p_p_apr_array_header_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_apr_file_t[] = {  {&_swigt__p_p_apr_file_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_apr_hash_t[] = {  {&_swigt__p_p_apr_hash_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_baton_t[] = {  {&_swigt__p_p_svn_auth_baton_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_cred_simple_t[] = {  {&_swigt__p_p_svn_auth_cred_simple_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_cred_ssl_client_cert_pw_t[] = {  {&_swigt__p_p_svn_auth_cred_ssl_client_cert_pw_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_cred_ssl_client_cert_t[] = {  {&_swigt__p_p_svn_auth_cred_ssl_client_cert_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_cred_ssl_server_trust_t[] = {  {&_swigt__p_p_svn_auth_cred_ssl_server_trust_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_cred_username_t[] = {  {&_swigt__p_p_svn_auth_cred_username_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_iterstate_t[] = {  {&_swigt__p_p_svn_auth_iterstate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_auth_provider_object_t[] = {  {&_swigt__p_p_svn_auth_provider_object_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_checksum_t[] = {  {&_swigt__p_p_svn_checksum_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_config_t[] = {  {&_swigt__p_p_svn_config_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_diff_t[] = {  {&_swigt__p_p_svn_diff_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_io_dirent2_t[] = {  {&_swigt__p_p_svn_io_dirent2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_patch_file_t[] = {  {&_swigt__p_p_svn_patch_file_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_patch_t[] = {  {&_swigt__p_p_svn_patch_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_stream_mark_t[] = {  {&_swigt__p_p_svn_stream_mark_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_stream_t[] = {  {&_swigt__p_p_svn_stream_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_string_t[] = {  {&_swigt__p_p_svn_string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_svn_stringbuf_t[] = {  {&_swigt__p_p_svn_stringbuf_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_baton_t[] = {  {&_swigt__p_svn_auth_baton_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_cred_simple_t[] = {  {&_swigt__p_svn_auth_cred_simple_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_cred_ssl_client_cert_pw_t[] = {  {&_swigt__p_svn_auth_cred_ssl_client_cert_pw_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_cred_ssl_client_cert_t[] = {  {&_swigt__p_svn_auth_cred_ssl_client_cert_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_cred_ssl_server_trust_t[] = {  {&_swigt__p_svn_auth_cred_ssl_server_trust_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_cred_username_t[] = {  {&_swigt__p_svn_auth_cred_username_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_iterstate_t[] = {  {&_swigt__p_svn_auth_iterstate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_provider_object_t[] = {  {&_swigt__p_svn_auth_provider_object_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_provider_t[] = {  {&_swigt__p_svn_auth_provider_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_auth_ssl_server_cert_info_t[] = {  {&_swigt__p_svn_auth_ssl_server_cert_info_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_checksum_kind_t[] = {  {&_swigt__p_svn_checksum_kind_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_commit_info_t[] = {  {&_swigt__p_svn_commit_info_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_config_t[] = {  {&_swigt__p_svn_config_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_depth_t[] = {  {&_swigt__p_svn_depth_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_conflict_display_style_t[] = {  {&_swigt__p_svn_diff_conflict_display_style_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_datasource_e[] = {  {&_swigt__p_svn_diff_datasource_e, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_file_ignore_space_t[] = {  {&_swigt__p_svn_diff_file_ignore_space_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_file_options_t[] = {  {&_swigt__p_svn_diff_file_options_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_fns2_t[] = {  {&_swigt__p_svn_diff_fns2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_fns_t[] = {  {&_swigt__p_svn_diff_fns_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_hunk_t[] = {  {&_swigt__p_svn_diff_hunk_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_operation_kind_e[] = {  {&_swigt__p_svn_diff_operation_kind_e, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_output_fns_t[] = {  {&_swigt__p_svn_diff_output_fns_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_diff_t[] = {  {&_swigt__p_svn_diff_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_dirent_t[] = {  {&_swigt__p_svn_dirent_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_errno_t[] = {  {&_swigt__p_svn_errno_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_error_t[] = {  {&_swigt__p_svn_error_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_io_dirent2_t[] = {  {&_swigt__p_svn_io_dirent2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_io_dirent_t[] = {  {&_swigt__p_svn_io_dirent_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_io_file_del_t[] = {  {&_swigt__p_svn_io_file_del_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_location_segment_t[] = {  {&_swigt__p_svn_location_segment_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_lock_t[] = {  {&_swigt__p_svn_lock_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_log_changed_path2_t[] = {  {&_swigt__p_svn_log_changed_path2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_log_changed_path_t[] = {  {&_swigt__p_svn_log_changed_path_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_log_entry_t[] = {  {&_swigt__p_svn_log_entry_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_merge_range_t[] = {  {&_swigt__p_svn_merge_range_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_mergeinfo_inheritance_t[] = {  {&_swigt__p_svn_mergeinfo_inheritance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_node_kind_t[] = {  {&_swigt__p_svn_node_kind_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_revision_range_t[] = {  {&_swigt__p_svn_opt_revision_range_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_revision_t[] = {  {&_swigt__p_svn_opt_revision_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_revision_value_t[] = {  {&_swigt__p_svn_opt_revision_value_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_subcommand_desc2_t[] = {  {&_swigt__p_svn_opt_subcommand_desc2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_subcommand_desc2_t_desc_overrides[] = {  {&_swigt__p_svn_opt_subcommand_desc2_t_desc_overrides, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_opt_subcommand_desc_t[] = {  {&_swigt__p_svn_opt_subcommand_desc_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_patch_file_t[] = {  {&_swigt__p_svn_patch_file_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_patch_t[] = {  {&_swigt__p_svn_patch_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_prop_kind[] = {  {&_swigt__p_svn_prop_kind, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_prop_patch_t[] = {  {&_swigt__p_svn_prop_patch_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_prop_t[] = {  {&_swigt__p_svn_prop_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_stream_mark_t[] = {  {&_swigt__p_svn_stream_mark_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_stream_t[] = {  {&_swigt__p_svn_stream_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_string_t[] = {  {&_swigt__p_svn_string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_stringbuf_t[] = {  {&_swigt__p_svn_stringbuf_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_tristate_t[] = {  {&_swigt__p_svn_tristate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_version_checklist_t[] = {  {&_swigt__p_svn_version_checklist_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_svn_version_t[] = {  {&_swigt__p_svn_version_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_FILE,
  _swigc__p_apr_allocator_t,
  _swigc__p_apr_array_header_t,
  _swigc__p_apr_dir_t,
  _swigc__p_apr_file_t,
  _swigc__p_apr_finfo_t,
  _swigc__p_apr_getopt_option_t,
  _swigc__p_apr_getopt_t,
  _swigc__p_apr_hash_index_t,
  _swigc__p_apr_hash_t,
  _swigc__p_apr_int32_t,
  _swigc__p_apr_int64_t,
  _swigc__p_apr_off_t,
  _swigc__p_apr_pool_t,
  _swigc__p_apr_proc_t,
  _swigc__p_apr_size_t,
  _swigc__p_apr_uint32_t,
  _swigc__p_char,
  _swigc__p_f_p_apr_getopt_t_p_void_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_apr_uint32_t_p_p_void_p_void_svn_diff_datasource_e__p_svn_error_t,
  _swigc__p_f_p_p_struct_svn_auth_provider_object_t_p_apr_pool_t__void,
  _swigc__p_f_p_p_svn_auth_cred_simple_t_p_void_p_q_const__char_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_svn_auth_cred_ssl_client_cert_pw_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_svn_auth_cred_ssl_client_cert_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_svn_auth_cred_ssl_server_trust_t_p_void_p_q_const__char_apr_uint32_t_p_q_const__svn_auth_ssl_server_cert_info_t_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_svn_auth_cred_username_t_p_void_p_q_const__char_svn_boolean_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_void_p_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_p_void_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_q_const__char_p_q_const__char_p_void__int,
  _swigc__p_f_p_q_const__char_p_q_const__char_p_void_p_apr_pool_t__int,
  _swigc__p_f_p_q_const__char_p_void__int,
  _swigc__p_f_p_q_const__char_p_void_p_apr_pool_t__int,
  _swigc__p_f_p_q_const__svn_commit_info_t_p_void_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_svn_boolean_t_p_q_const__char_p_void_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_svn_boolean_t_p_void_p_void_p_apr_hash_t_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_svn_location_segment_t_p_void_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_void__p_svn_error_t,
  _swigc__p_f_p_void__void,
  _swigc__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t__p_svn_error_t,
  _swigc__p_f_p_void_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_apr_off_t_p_svn_diff_t__p_svn_error_t,
  _swigc__p_f_p_void_apr_size_t__p_svn_error_t,
  _swigc__p_f_p_void_p_apr_hash_t_svn_revnum_t_p_q_const__char_p_q_const__char_p_q_const__char_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_void_p_apr_off_t_p_apr_off_t_p_q_const__svn_diff_datasource_e_apr_size_t__p_svn_error_t,
  _swigc__p_f_p_void_p_char_p_apr_size_t__p_svn_error_t,
  _swigc__p_f_p_void_p_p_svn_stream_mark_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_void_p_q_const__char_p_apr_size_t__p_svn_error_t,
  _swigc__p_f_p_void_p_q_const__char_p_q_const__apr_finfo_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_void_p_q_const__svn_stream_mark_t__p_svn_error_t,
  _swigc__p_f_p_void_p_svn_log_entry_t_p_apr_pool_t__p_svn_error_t,
  _swigc__p_f_p_void_p_void__void,
  _swigc__p_f_p_void_p_void_p_void_p_int__p_svn_error_t,
  _swigc__p_f_p_void_svn_diff_datasource_e__p_svn_error_t,
  _swigc__p_f_svn_boolean_t_p_q_const__char_int_p_q_const__char__p_svn_error_t,
  _swigc__p_f_svn_revnum_t_p_q_const__char_p_q_const__char_p_void__p_svn_error_t,
  _swigc__p_f_void__p_svn_version_t,
  _swigc__p_int,
  _swigc__p_long,
  _swigc__p_p_apr_array_header_t,
  _swigc__p_p_apr_file_t,
  _swigc__p_p_apr_hash_t,
  _swigc__p_p_char,
  _swigc__p_p_svn_auth_baton_t,
  _swigc__p_p_svn_auth_cred_simple_t,
  _swigc__p_p_svn_auth_cred_ssl_client_cert_pw_t,
  _swigc__p_p_svn_auth_cred_ssl_client_cert_t,
  _swigc__p_p_svn_auth_cred_ssl_server_trust_t,
  _swigc__p_p_svn_auth_cred_username_t,
  _swigc__p_p_svn_auth_iterstate_t,
  _swigc__p_p_svn_auth_provider_object_t,
  _swigc__p_p_svn_checksum_t,
  _swigc__p_p_svn_config_t,
  _swigc__p_p_svn_diff_t,
  _swigc__p_p_svn_io_dirent2_t,
  _swigc__p_p_svn_patch_file_t,
  _swigc__p_p_svn_patch_t,
  _swigc__p_p_svn_stream_mark_t,
  _swigc__p_p_svn_stream_t,
  _swigc__p_p_svn_string_t,
  _swigc__p_p_svn_stringbuf_t,
  _swigc__p_p_void,
  _swigc__p_svn_auth_baton_t,
  _swigc__p_svn_auth_cred_simple_t,
  _swigc__p_svn_auth_cred_ssl_client_cert_pw_t,
  _swigc__p_svn_auth_cred_ssl_client_cert_t,
  _swigc__p_svn_auth_cred_ssl_server_trust_t,
  _swigc__p_svn_auth_cred_username_t,
  _swigc__p_svn_auth_iterstate_t,
  _swigc__p_svn_auth_provider_object_t,
  _swigc__p_svn_auth_provider_t,
  _swigc__p_svn_auth_ssl_server_cert_info_t,
  _swigc__p_svn_checksum_kind_t,
  _swigc__p_svn_commit_info_t,
  _swigc__p_svn_config_t,
  _swigc__p_svn_depth_t,
  _swigc__p_svn_diff_conflict_display_style_t,
  _swigc__p_svn_diff_datasource_e,
  _swigc__p_svn_diff_file_ignore_space_t,
  _swigc__p_svn_diff_file_options_t,
  _swigc__p_svn_diff_fns2_t,
  _swigc__p_svn_diff_fns_t,
  _swigc__p_svn_diff_hunk_t,
  _swigc__p_svn_diff_operation_kind_e,
  _swigc__p_svn_diff_output_fns_t,
  _swigc__p_svn_diff_t,
  _swigc__p_svn_dirent_t,
  _swigc__p_svn_errno_t,
  _swigc__p_svn_error_t,
  _swigc__p_svn_io_dirent2_t,
  _swigc__p_svn_io_dirent_t,
  _swigc__p_svn_io_file_del_t,
  _swigc__p_svn_location_segment_t,
  _swigc__p_svn_lock_t,
  _swigc__p_svn_log_changed_path2_t,
  _swigc__p_svn_log_changed_path_t,
  _swigc__p_svn_log_entry_t,
  _swigc__p_svn_merge_range_t,
  _swigc__p_svn_mergeinfo_inheritance_t,
  _swigc__p_svn_node_kind_t,
  _swigc__p_svn_opt_revision_range_t,
  _swigc__p_svn_opt_revision_t,
  _swigc__p_svn_opt_revision_value_t,
  _swigc__p_svn_opt_subcommand_desc2_t,
  _swigc__p_svn_opt_subcommand_desc2_t_desc_overrides,
  _swigc__p_svn_opt_subcommand_desc_t,
  _swigc__p_svn_patch_file_t,
  _swigc__p_svn_patch_t,
  _swigc__p_svn_prop_kind,
  _swigc__p_svn_prop_patch_t,
  _swigc__p_svn_prop_t,
  _swigc__p_svn_stream_mark_t,
  _swigc__p_svn_stream_t,
  _swigc__p_svn_string_t,
  _swigc__p_svn_stringbuf_t,
  _swigc__p_svn_tristate_t,
  _swigc__p_svn_version_checklist_t,
  _swigc__p_svn_version_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_long,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{0,0,0,0,0,0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
    { "SVN::_Core::current_pool", MAGIC_CLASS _wrap_current_pool_set, MAGIC_CLASS _wrap_current_pool_get,&SWIGTYPE_p_apr_pool_t },
{0,0,0,0}
};
static swig_command_info swig_commands[] = {
{"SVN::_Core::apr_initialize", _wrap_apr_initialize},
{"SVN::_Core::apr_terminate", _wrap_apr_terminate},
{"SVN::_Core::apr_time_ansi_put", _wrap_apr_time_ansi_put},
{"SVN::_Core::apr_pool_destroy", _wrap_apr_pool_destroy},
{"SVN::_Core::apr_pool_clear", _wrap_apr_pool_clear},
{"SVN::_Core::apr_file_open_stdout", _wrap_apr_file_open_stdout},
{"SVN::_Core::apr_file_open_stderr", _wrap_apr_file_open_stderr},
{"SVN::_Core::svn_time_to_cstring", _wrap_svn_time_to_cstring},
{"SVN::_Core::svn_time_from_cstring", _wrap_svn_time_from_cstring},
{"SVN::_Core::svn_time_to_human_cstring", _wrap_svn_time_to_human_cstring},
{"SVN::_Core::svn_parse_date", _wrap_svn_parse_date},
{"SVN::_Core::svn_sleep_for_timestamps", _wrap_svn_sleep_for_timestamps},
{"SVN::_Core::svn_error_t_apr_err_set", _wrap_svn_error_t_apr_err_set},
{"SVN::_Core::svn_error_t_apr_err_get", _wrap_svn_error_t_apr_err_get},
{"SVN::_Core::svn_error_t_message_get", _wrap_svn_error_t_message_get},
{"SVN::_Core::svn_error_t_child_set", _wrap_svn_error_t_child_set},
{"SVN::_Core::svn_error_t_child_get", _wrap_svn_error_t_child_get},
{"SVN::_Core::svn_error_t_pool_set", _wrap_svn_error_t_pool_set},
{"SVN::_Core::svn_error_t_pool_get", _wrap_svn_error_t_pool_get},
{"SVN::_Core::svn_error_t_file_get", _wrap_svn_error_t_file_get},
{"SVN::_Core::svn_error_t_line_set", _wrap_svn_error_t_line_set},
{"SVN::_Core::svn_error_t_line_get", _wrap_svn_error_t_line_get},
{"SVN::_Core::new_svn_error_t", _wrap_new_svn_error_t},
{"SVN::_Core::delete_svn_error_t", _wrap_delete_svn_error_t},
{"SVN::_Core::svn__apr_hash_index_key", _wrap_svn__apr_hash_index_key},
{"SVN::_Core::svn__apr_hash_index_klen", _wrap_svn__apr_hash_index_klen},
{"SVN::_Core::svn__apr_hash_index_val", _wrap_svn__apr_hash_index_val},
{"SVN::_Core::svn_node_kind_to_word", _wrap_svn_node_kind_to_word},
{"SVN::_Core::svn_node_kind_from_word", _wrap_svn_node_kind_from_word},
{"SVN::_Core::svn_tristate__to_word", _wrap_svn_tristate__to_word},
{"SVN::_Core::svn_tristate__from_word", _wrap_svn_tristate__from_word},
{"SVN::_Core::svn_revnum_parse", _wrap_svn_revnum_parse},
{"SVN::_Core::svn_depth_to_word", _wrap_svn_depth_to_word},
{"SVN::_Core::svn_depth_from_word", _wrap_svn_depth_from_word},
{"SVN::_Core::svn_dirent_t_kind_set", _wrap_svn_dirent_t_kind_set},
{"SVN::_Core::svn_dirent_t_kind_get", _wrap_svn_dirent_t_kind_get},
{"SVN::_Core::svn_dirent_t_size_set", _wrap_svn_dirent_t_size_set},
{"SVN::_Core::svn_dirent_t_size_get", _wrap_svn_dirent_t_size_get},
{"SVN::_Core::svn_dirent_t_has_props_set", _wrap_svn_dirent_t_has_props_set},
{"SVN::_Core::svn_dirent_t_has_props_get", _wrap_svn_dirent_t_has_props_get},
{"SVN::_Core::svn_dirent_t_created_rev_set", _wrap_svn_dirent_t_created_rev_set},
{"SVN::_Core::svn_dirent_t_created_rev_get", _wrap_svn_dirent_t_created_rev_get},
{"SVN::_Core::svn_dirent_t_time_set", _wrap_svn_dirent_t_time_set},
{"SVN::_Core::svn_dirent_t_time_get", _wrap_svn_dirent_t_time_get},
{"SVN::_Core::svn_dirent_t_last_author_get", _wrap_svn_dirent_t_last_author_get},
{"SVN::_Core::new_svn_dirent_t", _wrap_new_svn_dirent_t},
{"SVN::_Core::delete_svn_dirent_t", _wrap_delete_svn_dirent_t},
{"SVN::_Core::svn_dirent_dup", _wrap_svn_dirent_dup},
{"SVN::_Core::svn_commit_info_t_revision_set", _wrap_svn_commit_info_t_revision_set},
{"SVN::_Core::svn_commit_info_t_revision_get", _wrap_svn_commit_info_t_revision_get},
{"SVN::_Core::svn_commit_info_t_date_set", _wrap_svn_commit_info_t_date_set},
{"SVN::_Core::svn_commit_info_t_date_get", _wrap_svn_commit_info_t_date_get},
{"SVN::_Core::svn_commit_info_t_author_set", _wrap_svn_commit_info_t_author_set},
{"SVN::_Core::svn_commit_info_t_author_get", _wrap_svn_commit_info_t_author_get},
{"SVN::_Core::svn_commit_info_t_post_commit_err_set", _wrap_svn_commit_info_t_post_commit_err_set},
{"SVN::_Core::svn_commit_info_t_post_commit_err_get", _wrap_svn_commit_info_t_post_commit_err_get},
{"SVN::_Core::svn_commit_info_t_repos_root_set", _wrap_svn_commit_info_t_repos_root_set},
{"SVN::_Core::svn_commit_info_t_repos_root_get", _wrap_svn_commit_info_t_repos_root_get},
{"SVN::_Core::new_svn_commit_info_t", _wrap_new_svn_commit_info_t},
{"SVN::_Core::delete_svn_commit_info_t", _wrap_delete_svn_commit_info_t},
{"SVN::_Core::svn_create_commit_info", _wrap_svn_create_commit_info},
{"SVN::_Core::svn_commit_info_dup", _wrap_svn_commit_info_dup},
{"SVN::_Core::svn_log_changed_path2_t_action_set", _wrap_svn_log_changed_path2_t_action_set},
{"SVN::_Core::svn_log_changed_path2_t_action_get", _wrap_svn_log_changed_path2_t_action_get},
{"SVN::_Core::svn_log_changed_path2_t_copyfrom_path_set", _wrap_svn_log_changed_path2_t_copyfrom_path_set},
{"SVN::_Core::svn_log_changed_path2_t_copyfrom_path_get", _wrap_svn_log_changed_path2_t_copyfrom_path_get},
{"SVN::_Core::svn_log_changed_path2_t_copyfrom_rev_set", _wrap_svn_log_changed_path2_t_copyfrom_rev_set},
{"SVN::_Core::svn_log_changed_path2_t_copyfrom_rev_get", _wrap_svn_log_changed_path2_t_copyfrom_rev_get},
{"SVN::_Core::svn_log_changed_path2_t_node_kind_set", _wrap_svn_log_changed_path2_t_node_kind_set},
{"SVN::_Core::svn_log_changed_path2_t_node_kind_get", _wrap_svn_log_changed_path2_t_node_kind_get},
{"SVN::_Core::svn_log_changed_path2_t_text_modified_set", _wrap_svn_log_changed_path2_t_text_modified_set},
{"SVN::_Core::svn_log_changed_path2_t_text_modified_get", _wrap_svn_log_changed_path2_t_text_modified_get},
{"SVN::_Core::svn_log_changed_path2_t_props_modified_set", _wrap_svn_log_changed_path2_t_props_modified_set},
{"SVN::_Core::svn_log_changed_path2_t_props_modified_get", _wrap_svn_log_changed_path2_t_props_modified_get},
{"SVN::_Core::new_svn_log_changed_path2_t", _wrap_new_svn_log_changed_path2_t},
{"SVN::_Core::delete_svn_log_changed_path2_t", _wrap_delete_svn_log_changed_path2_t},
{"SVN::_Core::svn_log_changed_path2_create", _wrap_svn_log_changed_path2_create},
{"SVN::_Core::svn_log_changed_path2_dup", _wrap_svn_log_changed_path2_dup},
{"SVN::_Core::svn_log_changed_path_t_action_set", _wrap_svn_log_changed_path_t_action_set},
{"SVN::_Core::svn_log_changed_path_t_action_get", _wrap_svn_log_changed_path_t_action_get},
{"SVN::_Core::svn_log_changed_path_t_copyfrom_path_get", _wrap_svn_log_changed_path_t_copyfrom_path_get},
{"SVN::_Core::svn_log_changed_path_t_copyfrom_rev_set", _wrap_svn_log_changed_path_t_copyfrom_rev_set},
{"SVN::_Core::svn_log_changed_path_t_copyfrom_rev_get", _wrap_svn_log_changed_path_t_copyfrom_rev_get},
{"SVN::_Core::new_svn_log_changed_path_t", _wrap_new_svn_log_changed_path_t},
{"SVN::_Core::delete_svn_log_changed_path_t", _wrap_delete_svn_log_changed_path_t},
{"SVN::_Core::svn_log_changed_path_dup", _wrap_svn_log_changed_path_dup},
{"SVN::_Core::svn_log_entry_t_changed_paths_set", _wrap_svn_log_entry_t_changed_paths_set},
{"SVN::_Core::svn_log_entry_t_changed_paths_get", _wrap_svn_log_entry_t_changed_paths_get},
{"SVN::_Core::svn_log_entry_t_revision_set", _wrap_svn_log_entry_t_revision_set},
{"SVN::_Core::svn_log_entry_t_revision_get", _wrap_svn_log_entry_t_revision_get},
{"SVN::_Core::svn_log_entry_t_revprops_set", _wrap_svn_log_entry_t_revprops_set},
{"SVN::_Core::svn_log_entry_t_revprops_get", _wrap_svn_log_entry_t_revprops_get},
{"SVN::_Core::svn_log_entry_t_has_children_set", _wrap_svn_log_entry_t_has_children_set},
{"SVN::_Core::svn_log_entry_t_has_children_get", _wrap_svn_log_entry_t_has_children_get},
{"SVN::_Core::svn_log_entry_t_changed_paths2_set", _wrap_svn_log_entry_t_changed_paths2_set},
{"SVN::_Core::svn_log_entry_t_changed_paths2_get", _wrap_svn_log_entry_t_changed_paths2_get},
{"SVN::_Core::svn_log_entry_t_non_inheritable_set", _wrap_svn_log_entry_t_non_inheritable_set},
{"SVN::_Core::svn_log_entry_t_non_inheritable_get", _wrap_svn_log_entry_t_non_inheritable_get},
{"SVN::_Core::svn_log_entry_t_subtractive_merge_set", _wrap_svn_log_entry_t_subtractive_merge_set},
{"SVN::_Core::svn_log_entry_t_subtractive_merge_get", _wrap_svn_log_entry_t_subtractive_merge_get},
{"SVN::_Core::new_svn_log_entry_t", _wrap_new_svn_log_entry_t},
{"SVN::_Core::delete_svn_log_entry_t", _wrap_delete_svn_log_entry_t},
{"SVN::_Core::svn_log_entry_create", _wrap_svn_log_entry_create},
{"SVN::_Core::svn_log_entry_dup", _wrap_svn_log_entry_dup},
{"SVN::_Core::svn_mime_type_validate", _wrap_svn_mime_type_validate},
{"SVN::_Core::svn_mime_type_is_binary", _wrap_svn_mime_type_is_binary},
{"SVN::_Core::svn_lock_t_path_set", _wrap_svn_lock_t_path_set},
{"SVN::_Core::svn_lock_t_path_get", _wrap_svn_lock_t_path_get},
{"SVN::_Core::svn_lock_t_token_set", _wrap_svn_lock_t_token_set},
{"SVN::_Core::svn_lock_t_token_get", _wrap_svn_lock_t_token_get},
{"SVN::_Core::svn_lock_t_owner_set", _wrap_svn_lock_t_owner_set},
{"SVN::_Core::svn_lock_t_owner_get", _wrap_svn_lock_t_owner_get},
{"SVN::_Core::svn_lock_t_comment_set", _wrap_svn_lock_t_comment_set},
{"SVN::_Core::svn_lock_t_comment_get", _wrap_svn_lock_t_comment_get},
{"SVN::_Core::svn_lock_t_is_dav_comment_set", _wrap_svn_lock_t_is_dav_comment_set},
{"SVN::_Core::svn_lock_t_is_dav_comment_get", _wrap_svn_lock_t_is_dav_comment_get},
{"SVN::_Core::svn_lock_t_creation_date_set", _wrap_svn_lock_t_creation_date_set},
{"SVN::_Core::svn_lock_t_creation_date_get", _wrap_svn_lock_t_creation_date_get},
{"SVN::_Core::svn_lock_t_expiration_date_set", _wrap_svn_lock_t_expiration_date_set},
{"SVN::_Core::svn_lock_t_expiration_date_get", _wrap_svn_lock_t_expiration_date_get},
{"SVN::_Core::new_svn_lock_t", _wrap_new_svn_lock_t},
{"SVN::_Core::delete_svn_lock_t", _wrap_delete_svn_lock_t},
{"SVN::_Core::svn_lock_create", _wrap_svn_lock_create},
{"SVN::_Core::svn_lock_dup", _wrap_svn_lock_dup},
{"SVN::_Core::svn_uuid_generate", _wrap_svn_uuid_generate},
{"SVN::_Core::svn_merge_range_t_start_set", _wrap_svn_merge_range_t_start_set},
{"SVN::_Core::svn_merge_range_t_start_get", _wrap_svn_merge_range_t_start_get},
{"SVN::_Core::svn_merge_range_t_end_set", _wrap_svn_merge_range_t_end_set},
{"SVN::_Core::svn_merge_range_t_end_get", _wrap_svn_merge_range_t_end_get},
{"SVN::_Core::svn_merge_range_t_inheritable_set", _wrap_svn_merge_range_t_inheritable_set},
{"SVN::_Core::svn_merge_range_t_inheritable_get", _wrap_svn_merge_range_t_inheritable_get},
{"SVN::_Core::new_svn_merge_range_t", _wrap_new_svn_merge_range_t},
{"SVN::_Core::delete_svn_merge_range_t", _wrap_delete_svn_merge_range_t},
{"SVN::_Core::svn_merge_range_dup", _wrap_svn_merge_range_dup},
{"SVN::_Core::svn_merge_range_contains_rev", _wrap_svn_merge_range_contains_rev},
{"SVN::_Core::svn_location_segment_t_range_start_set", _wrap_svn_location_segment_t_range_start_set},
{"SVN::_Core::svn_location_segment_t_range_start_get", _wrap_svn_location_segment_t_range_start_get},
{"SVN::_Core::svn_location_segment_t_range_end_set", _wrap_svn_location_segment_t_range_end_set},
{"SVN::_Core::svn_location_segment_t_range_end_get", _wrap_svn_location_segment_t_range_end_get},
{"SVN::_Core::svn_location_segment_t_path_set", _wrap_svn_location_segment_t_path_set},
{"SVN::_Core::svn_location_segment_t_path_get", _wrap_svn_location_segment_t_path_get},
{"SVN::_Core::new_svn_location_segment_t", _wrap_new_svn_location_segment_t},
{"SVN::_Core::delete_svn_location_segment_t", _wrap_delete_svn_location_segment_t},
{"SVN::_Core::svn_location_segment_dup", _wrap_svn_location_segment_dup},
{"SVN::_Core::svn_log_invoke_entry_receiver", _wrap_svn_log_invoke_entry_receiver},
{"SVN::_Core::svn_log_invoke_message_receiver", _wrap_svn_log_invoke_message_receiver},
{"SVN::_Core::svn_commit_invoke_callback2", _wrap_svn_commit_invoke_callback2},
{"SVN::_Core::svn_commit_invoke_callback", _wrap_svn_commit_invoke_callback},
{"SVN::_Core::svn_cancel_invoke_func", _wrap_svn_cancel_invoke_func},
{"SVN::_Core::svn_location_invoke_segment_receiver", _wrap_svn_location_invoke_segment_receiver},
{"SVN::_Core::svn_pool_create", _wrap_svn_pool_create},
{"SVN::_Core::svn_version_t_major_set", _wrap_svn_version_t_major_set},
{"SVN::_Core::svn_version_t_major_get", _wrap_svn_version_t_major_get},
{"SVN::_Core::svn_version_t_minor_set", _wrap_svn_version_t_minor_set},
{"SVN::_Core::svn_version_t_minor_get", _wrap_svn_version_t_minor_get},
{"SVN::_Core::svn_version_t_patch_set", _wrap_svn_version_t_patch_set},
{"SVN::_Core::svn_version_t_patch_get", _wrap_svn_version_t_patch_get},
{"SVN::_Core::svn_version_t_tag_set", _wrap_svn_version_t_tag_set},
{"SVN::_Core::svn_version_t_tag_get", _wrap_svn_version_t_tag_get},
{"SVN::_Core::new_svn_version_t", _wrap_new_svn_version_t},
{"SVN::_Core::delete_svn_version_t", _wrap_delete_svn_version_t},
{"SVN::_Core::svn_ver_compatible", _wrap_svn_ver_compatible},
{"SVN::_Core::svn_ver_equal", _wrap_svn_ver_equal},
{"SVN::_Core::svn_version_checklist_t_label_set", _wrap_svn_version_checklist_t_label_set},
{"SVN::_Core::svn_version_checklist_t_label_get", _wrap_svn_version_checklist_t_label_get},
{"SVN::_Core::svn_version_checklist_t_version_query_set", _wrap_svn_version_checklist_t_version_query_set},
{"SVN::_Core::svn_version_checklist_t_version_query_get", _wrap_svn_version_checklist_t_version_query_get},
{"SVN::_Core::new_svn_version_checklist_t", _wrap_new_svn_version_checklist_t},
{"SVN::_Core::delete_svn_version_checklist_t", _wrap_delete_svn_version_checklist_t},
{"SVN::_Core::svn_ver_check_list", _wrap_svn_ver_check_list},
{"SVN::_Core::svn_subr_version", _wrap_svn_subr_version},
{"SVN::_Core::svn_version_checklist_invoke_version_query", _wrap_svn_version_checklist_invoke_version_query},
{"SVN::_Core::svn_version_invoke_func", _wrap_svn_version_invoke_func},
{"SVN::_Core::svn_prop_dup", _wrap_svn_prop_dup},
{"SVN::_Core::svn_prop_array_dup", _wrap_svn_prop_array_dup},
{"SVN::_Core::svn_prop_hash_to_array", _wrap_svn_prop_hash_to_array},
{"SVN::_Core::svn_prop_array_to_hash", _wrap_svn_prop_array_to_hash},
{"SVN::_Core::svn_prop_hash_dup", _wrap_svn_prop_hash_dup},
{"SVN::_Core::svn_prop_get_value", _wrap_svn_prop_get_value},
{"SVN::_Core::svn_property_kind", _wrap_svn_property_kind},
{"SVN::_Core::svn_prop_is_svn_prop", _wrap_svn_prop_is_svn_prop},
{"SVN::_Core::svn_prop_has_svn_prop", _wrap_svn_prop_has_svn_prop},
{"SVN::_Core::svn_prop_is_boolean", _wrap_svn_prop_is_boolean},
{"SVN::_Core::svn_prop_needs_translation", _wrap_svn_prop_needs_translation},
{"SVN::_Core::svn_categorize_props", _wrap_svn_categorize_props},
{"SVN::_Core::svn_prop_diffs", _wrap_svn_prop_diffs},
{"SVN::_Core::svn_prop_name_is_valid", _wrap_svn_prop_name_is_valid},
{"SVN::_Core::svn_opt_subcommand_desc2_t_name_set", _wrap_svn_opt_subcommand_desc2_t_name_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_name_get", _wrap_svn_opt_subcommand_desc2_t_name_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_cmd_func_set", _wrap_svn_opt_subcommand_desc2_t_cmd_func_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_cmd_func_get", _wrap_svn_opt_subcommand_desc2_t_cmd_func_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_aliases_set", _wrap_svn_opt_subcommand_desc2_t_aliases_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_aliases_get", _wrap_svn_opt_subcommand_desc2_t_aliases_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_help_set", _wrap_svn_opt_subcommand_desc2_t_help_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_help_get", _wrap_svn_opt_subcommand_desc2_t_help_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_valid_options_set", _wrap_svn_opt_subcommand_desc2_t_valid_options_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_valid_options_get", _wrap_svn_opt_subcommand_desc2_t_valid_options_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_desc_overrides_get", _wrap_svn_opt_subcommand_desc2_t_desc_overrides_get},
{"SVN::_Core::new_svn_opt_subcommand_desc2_t", _wrap_new_svn_opt_subcommand_desc2_t},
{"SVN::_Core::delete_svn_opt_subcommand_desc2_t", _wrap_delete_svn_opt_subcommand_desc2_t},
{"SVN::_Core::svn_opt_subcommand_desc2_t_desc_overrides_optch_set", _wrap_svn_opt_subcommand_desc2_t_desc_overrides_optch_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_desc_overrides_optch_get", _wrap_svn_opt_subcommand_desc2_t_desc_overrides_optch_get},
{"SVN::_Core::svn_opt_subcommand_desc2_t_desc_overrides_desc_set", _wrap_svn_opt_subcommand_desc2_t_desc_overrides_desc_set},
{"SVN::_Core::svn_opt_subcommand_desc2_t_desc_overrides_desc_get", _wrap_svn_opt_subcommand_desc2_t_desc_overrides_desc_get},
{"SVN::_Core::new_svn_opt_subcommand_desc2_t_desc_overrides", _wrap_new_svn_opt_subcommand_desc2_t_desc_overrides},
{"SVN::_Core::delete_svn_opt_subcommand_desc2_t_desc_overrides", _wrap_delete_svn_opt_subcommand_desc2_t_desc_overrides},
{"SVN::_Core::svn_opt_subcommand_desc_t_name_set", _wrap_svn_opt_subcommand_desc_t_name_set},
{"SVN::_Core::svn_opt_subcommand_desc_t_name_get", _wrap_svn_opt_subcommand_desc_t_name_get},
{"SVN::_Core::svn_opt_subcommand_desc_t_cmd_func_set", _wrap_svn_opt_subcommand_desc_t_cmd_func_set},
{"SVN::_Core::svn_opt_subcommand_desc_t_cmd_func_get", _wrap_svn_opt_subcommand_desc_t_cmd_func_get},
{"SVN::_Core::svn_opt_subcommand_desc_t_aliases_set", _wrap_svn_opt_subcommand_desc_t_aliases_set},
{"SVN::_Core::svn_opt_subcommand_desc_t_aliases_get", _wrap_svn_opt_subcommand_desc_t_aliases_get},
{"SVN::_Core::svn_opt_subcommand_desc_t_help_set", _wrap_svn_opt_subcommand_desc_t_help_set},
{"SVN::_Core::svn_opt_subcommand_desc_t_help_get", _wrap_svn_opt_subcommand_desc_t_help_get},
{"SVN::_Core::svn_opt_subcommand_desc_t_valid_options_set", _wrap_svn_opt_subcommand_desc_t_valid_options_set},
{"SVN::_Core::svn_opt_subcommand_desc_t_valid_options_get", _wrap_svn_opt_subcommand_desc_t_valid_options_get},
{"SVN::_Core::new_svn_opt_subcommand_desc_t", _wrap_new_svn_opt_subcommand_desc_t},
{"SVN::_Core::delete_svn_opt_subcommand_desc_t", _wrap_delete_svn_opt_subcommand_desc_t},
{"SVN::_Core::svn_opt_get_canonical_subcommand2", _wrap_svn_opt_get_canonical_subcommand2},
{"SVN::_Core::svn_opt_get_canonical_subcommand", _wrap_svn_opt_get_canonical_subcommand},
{"SVN::_Core::svn_opt_get_option_from_code2", _wrap_svn_opt_get_option_from_code2},
{"SVN::_Core::svn_opt_get_option_from_code", _wrap_svn_opt_get_option_from_code},
{"SVN::_Core::svn_opt_subcommand_takes_option3", _wrap_svn_opt_subcommand_takes_option3},
{"SVN::_Core::svn_opt_subcommand_takes_option2", _wrap_svn_opt_subcommand_takes_option2},
{"SVN::_Core::svn_opt_subcommand_takes_option", _wrap_svn_opt_subcommand_takes_option},
{"SVN::_Core::svn_opt_print_generic_help2", _wrap_svn_opt_print_generic_help2},
{"SVN::_Core::svn_opt_format_option", _wrap_svn_opt_format_option},
{"SVN::_Core::svn_opt_subcommand_help3", _wrap_svn_opt_subcommand_help3},
{"SVN::_Core::svn_opt_subcommand_help2", _wrap_svn_opt_subcommand_help2},
{"SVN::_Core::svn_opt_subcommand_help", _wrap_svn_opt_subcommand_help},
{"SVN::_Core::svn_opt_revision_value_t_number_set", _wrap_svn_opt_revision_value_t_number_set},
{"SVN::_Core::svn_opt_revision_value_t_number_get", _wrap_svn_opt_revision_value_t_number_get},
{"SVN::_Core::svn_opt_revision_value_t_date_set", _wrap_svn_opt_revision_value_t_date_set},
{"SVN::_Core::svn_opt_revision_value_t_date_get", _wrap_svn_opt_revision_value_t_date_get},
{"SVN::_Core::new_svn_opt_revision_value_t", _wrap_new_svn_opt_revision_value_t},
{"SVN::_Core::delete_svn_opt_revision_value_t", _wrap_delete_svn_opt_revision_value_t},
{"SVN::_Core::svn_opt_revision_t_kind_set", _wrap_svn_opt_revision_t_kind_set},
{"SVN::_Core::svn_opt_revision_t_kind_get", _wrap_svn_opt_revision_t_kind_get},
{"SVN::_Core::svn_opt_revision_t_value_set", _wrap_svn_opt_revision_t_value_set},
{"SVN::_Core::svn_opt_revision_t_value_get", _wrap_svn_opt_revision_t_value_get},
{"SVN::_Core::new_svn_opt_revision_t", _wrap_new_svn_opt_revision_t},
{"SVN::_Core::delete_svn_opt_revision_t", _wrap_delete_svn_opt_revision_t},
{"SVN::_Core::svn_opt_revision_range_t_start_set", _wrap_svn_opt_revision_range_t_start_set},
{"SVN::_Core::svn_opt_revision_range_t_start_get", _wrap_svn_opt_revision_range_t_start_get},
{"SVN::_Core::svn_opt_revision_range_t_end_set", _wrap_svn_opt_revision_range_t_end_set},
{"SVN::_Core::svn_opt_revision_range_t_end_get", _wrap_svn_opt_revision_range_t_end_get},
{"SVN::_Core::new_svn_opt_revision_range_t", _wrap_new_svn_opt_revision_range_t},
{"SVN::_Core::delete_svn_opt_revision_range_t", _wrap_delete_svn_opt_revision_range_t},
{"SVN::_Core::svn_opt_parse_revision", _wrap_svn_opt_parse_revision},
{"SVN::_Core::svn_opt_parse_revision_to_range", _wrap_svn_opt_parse_revision_to_range},
{"SVN::_Core::svn_opt_resolve_revisions", _wrap_svn_opt_resolve_revisions},
{"SVN::_Core::svn_opt_args_to_target_array3", _wrap_svn_opt_args_to_target_array3},
{"SVN::_Core::svn_opt_args_to_target_array2", _wrap_svn_opt_args_to_target_array2},
{"SVN::_Core::svn_opt_parse_revprop", _wrap_svn_opt_parse_revprop},
{"SVN::_Core::svn_opt_push_implicit_dot_target", _wrap_svn_opt_push_implicit_dot_target},
{"SVN::_Core::svn_opt_parse_num_args", _wrap_svn_opt_parse_num_args},
{"SVN::_Core::svn_opt_parse_all_args", _wrap_svn_opt_parse_all_args},
{"SVN::_Core::svn_opt_parse_path", _wrap_svn_opt_parse_path},
{"SVN::_Core::svn_opt_print_help3", _wrap_svn_opt_print_help3},
{"SVN::_Core::svn_opt_print_help2", _wrap_svn_opt_print_help2},
{"SVN::_Core::svn_opt_print_help", _wrap_svn_opt_print_help},
{"SVN::_Core::svn_auth_provider_t_cred_kind_set", _wrap_svn_auth_provider_t_cred_kind_set},
{"SVN::_Core::svn_auth_provider_t_cred_kind_get", _wrap_svn_auth_provider_t_cred_kind_get},
{"SVN::_Core::svn_auth_provider_t_first_credentials_set", _wrap_svn_auth_provider_t_first_credentials_set},
{"SVN::_Core::svn_auth_provider_t_first_credentials_get", _wrap_svn_auth_provider_t_first_credentials_get},
{"SVN::_Core::svn_auth_provider_t_next_credentials_set", _wrap_svn_auth_provider_t_next_credentials_set},
{"SVN::_Core::svn_auth_provider_t_next_credentials_get", _wrap_svn_auth_provider_t_next_credentials_get},
{"SVN::_Core::svn_auth_provider_t_save_credentials_set", _wrap_svn_auth_provider_t_save_credentials_set},
{"SVN::_Core::svn_auth_provider_t_save_credentials_get", _wrap_svn_auth_provider_t_save_credentials_get},
{"SVN::_Core::new_svn_auth_provider_t", _wrap_new_svn_auth_provider_t},
{"SVN::_Core::delete_svn_auth_provider_t", _wrap_delete_svn_auth_provider_t},
{"SVN::_Core::svn_auth_provider_object_t_vtable_set", _wrap_svn_auth_provider_object_t_vtable_set},
{"SVN::_Core::svn_auth_provider_object_t_vtable_get", _wrap_svn_auth_provider_object_t_vtable_get},
{"SVN::_Core::svn_auth_provider_object_t_provider_baton_set", _wrap_svn_auth_provider_object_t_provider_baton_set},
{"SVN::_Core::svn_auth_provider_object_t_provider_baton_get", _wrap_svn_auth_provider_object_t_provider_baton_get},
{"SVN::_Core::new_svn_auth_provider_object_t", _wrap_new_svn_auth_provider_object_t},
{"SVN::_Core::delete_svn_auth_provider_object_t", _wrap_delete_svn_auth_provider_object_t},
{"SVN::_Core::svn_auth_cred_simple_t_username_set", _wrap_svn_auth_cred_simple_t_username_set},
{"SVN::_Core::svn_auth_cred_simple_t_username_get", _wrap_svn_auth_cred_simple_t_username_get},
{"SVN::_Core::svn_auth_cred_simple_t_password_set", _wrap_svn_auth_cred_simple_t_password_set},
{"SVN::_Core::svn_auth_cred_simple_t_password_get", _wrap_svn_auth_cred_simple_t_password_get},
{"SVN::_Core::svn_auth_cred_simple_t_may_save_set", _wrap_svn_auth_cred_simple_t_may_save_set},
{"SVN::_Core::svn_auth_cred_simple_t_may_save_get", _wrap_svn_auth_cred_simple_t_may_save_get},
{"SVN::_Core::new_svn_auth_cred_simple_t", _wrap_new_svn_auth_cred_simple_t},
{"SVN::_Core::delete_svn_auth_cred_simple_t", _wrap_delete_svn_auth_cred_simple_t},
{"SVN::_Core::svn_auth_cred_username_t_username_set", _wrap_svn_auth_cred_username_t_username_set},
{"SVN::_Core::svn_auth_cred_username_t_username_get", _wrap_svn_auth_cred_username_t_username_get},
{"SVN::_Core::svn_auth_cred_username_t_may_save_set", _wrap_svn_auth_cred_username_t_may_save_set},
{"SVN::_Core::svn_auth_cred_username_t_may_save_get", _wrap_svn_auth_cred_username_t_may_save_get},
{"SVN::_Core::new_svn_auth_cred_username_t", _wrap_new_svn_auth_cred_username_t},
{"SVN::_Core::delete_svn_auth_cred_username_t", _wrap_delete_svn_auth_cred_username_t},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_t_cert_file_set", _wrap_svn_auth_cred_ssl_client_cert_t_cert_file_set},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_t_cert_file_get", _wrap_svn_auth_cred_ssl_client_cert_t_cert_file_get},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_t_may_save_set", _wrap_svn_auth_cred_ssl_client_cert_t_may_save_set},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_t_may_save_get", _wrap_svn_auth_cred_ssl_client_cert_t_may_save_get},
{"SVN::_Core::new_svn_auth_cred_ssl_client_cert_t", _wrap_new_svn_auth_cred_ssl_client_cert_t},
{"SVN::_Core::delete_svn_auth_cred_ssl_client_cert_t", _wrap_delete_svn_auth_cred_ssl_client_cert_t},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_pw_t_password_set", _wrap_svn_auth_cred_ssl_client_cert_pw_t_password_set},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_pw_t_password_get", _wrap_svn_auth_cred_ssl_client_cert_pw_t_password_get},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_pw_t_may_save_set", _wrap_svn_auth_cred_ssl_client_cert_pw_t_may_save_set},
{"SVN::_Core::svn_auth_cred_ssl_client_cert_pw_t_may_save_get", _wrap_svn_auth_cred_ssl_client_cert_pw_t_may_save_get},
{"SVN::_Core::new_svn_auth_cred_ssl_client_cert_pw_t", _wrap_new_svn_auth_cred_ssl_client_cert_pw_t},
{"SVN::_Core::delete_svn_auth_cred_ssl_client_cert_pw_t", _wrap_delete_svn_auth_cred_ssl_client_cert_pw_t},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_hostname_set", _wrap_svn_auth_ssl_server_cert_info_t_hostname_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_hostname_get", _wrap_svn_auth_ssl_server_cert_info_t_hostname_get},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_fingerprint_set", _wrap_svn_auth_ssl_server_cert_info_t_fingerprint_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_fingerprint_get", _wrap_svn_auth_ssl_server_cert_info_t_fingerprint_get},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_valid_from_set", _wrap_svn_auth_ssl_server_cert_info_t_valid_from_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_valid_from_get", _wrap_svn_auth_ssl_server_cert_info_t_valid_from_get},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_valid_until_set", _wrap_svn_auth_ssl_server_cert_info_t_valid_until_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_valid_until_get", _wrap_svn_auth_ssl_server_cert_info_t_valid_until_get},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_issuer_dname_set", _wrap_svn_auth_ssl_server_cert_info_t_issuer_dname_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_issuer_dname_get", _wrap_svn_auth_ssl_server_cert_info_t_issuer_dname_get},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_ascii_cert_set", _wrap_svn_auth_ssl_server_cert_info_t_ascii_cert_set},
{"SVN::_Core::svn_auth_ssl_server_cert_info_t_ascii_cert_get", _wrap_svn_auth_ssl_server_cert_info_t_ascii_cert_get},
{"SVN::_Core::new_svn_auth_ssl_server_cert_info_t", _wrap_new_svn_auth_ssl_server_cert_info_t},
{"SVN::_Core::delete_svn_auth_ssl_server_cert_info_t", _wrap_delete_svn_auth_ssl_server_cert_info_t},
{"SVN::_Core::svn_auth_ssl_server_cert_info_dup", _wrap_svn_auth_ssl_server_cert_info_dup},
{"SVN::_Core::svn_auth_cred_ssl_server_trust_t_may_save_set", _wrap_svn_auth_cred_ssl_server_trust_t_may_save_set},
{"SVN::_Core::svn_auth_cred_ssl_server_trust_t_may_save_get", _wrap_svn_auth_cred_ssl_server_trust_t_may_save_get},
{"SVN::_Core::svn_auth_cred_ssl_server_trust_t_accepted_failures_set", _wrap_svn_auth_cred_ssl_server_trust_t_accepted_failures_set},
{"SVN::_Core::svn_auth_cred_ssl_server_trust_t_accepted_failures_get", _wrap_svn_auth_cred_ssl_server_trust_t_accepted_failures_get},
{"SVN::_Core::new_svn_auth_cred_ssl_server_trust_t", _wrap_new_svn_auth_cred_ssl_server_trust_t},
{"SVN::_Core::delete_svn_auth_cred_ssl_server_trust_t", _wrap_delete_svn_auth_cred_ssl_server_trust_t},
{"SVN::_Core::svn_auth_open", _wrap_svn_auth_open},
{"SVN::_Core::svn_auth_set_parameter", _wrap_svn_auth_set_parameter},
{"SVN::_Core::svn_auth_first_credentials", _wrap_svn_auth_first_credentials},
{"SVN::_Core::svn_auth_next_credentials", _wrap_svn_auth_next_credentials},
{"SVN::_Core::svn_auth_save_credentials", _wrap_svn_auth_save_credentials},
{"SVN::_Core::svn_auth_get_simple_prompt_provider", _wrap_svn_auth_get_simple_prompt_provider},
{"SVN::_Core::svn_auth_get_username_prompt_provider", _wrap_svn_auth_get_username_prompt_provider},
{"SVN::_Core::svn_auth_get_simple_provider2", _wrap_svn_auth_get_simple_provider2},
{"SVN::_Core::svn_auth_get_simple_provider", _wrap_svn_auth_get_simple_provider},
{"SVN::_Core::svn_auth_get_platform_specific_provider", _wrap_svn_auth_get_platform_specific_provider},
{"SVN::_Core::svn_auth_get_platform_specific_client_providers", _wrap_svn_auth_get_platform_specific_client_providers},
{"SVN::_Core::svn_auth_get_username_provider", _wrap_svn_auth_get_username_provider},
{"SVN::_Core::svn_auth_get_ssl_server_trust_file_provider", _wrap_svn_auth_get_ssl_server_trust_file_provider},
{"SVN::_Core::svn_auth_get_ssl_client_cert_file_provider", _wrap_svn_auth_get_ssl_client_cert_file_provider},
{"SVN::_Core::svn_auth_get_ssl_client_cert_pw_file_provider2", _wrap_svn_auth_get_ssl_client_cert_pw_file_provider2},
{"SVN::_Core::svn_auth_get_ssl_client_cert_pw_file_provider", _wrap_svn_auth_get_ssl_client_cert_pw_file_provider},
{"SVN::_Core::svn_auth_get_ssl_server_trust_prompt_provider", _wrap_svn_auth_get_ssl_server_trust_prompt_provider},
{"SVN::_Core::svn_auth_get_ssl_client_cert_prompt_provider", _wrap_svn_auth_get_ssl_client_cert_prompt_provider},
{"SVN::_Core::svn_auth_get_ssl_client_cert_pw_prompt_provider", _wrap_svn_auth_get_ssl_client_cert_pw_prompt_provider},
{"SVN::_Core::svn_auth_provider_invoke_first_credentials", _wrap_svn_auth_provider_invoke_first_credentials},
{"SVN::_Core::svn_auth_provider_invoke_next_credentials", _wrap_svn_auth_provider_invoke_next_credentials},
{"SVN::_Core::svn_auth_provider_invoke_save_credentials", _wrap_svn_auth_provider_invoke_save_credentials},
{"SVN::_Core::svn_auth_invoke_simple_provider_func", _wrap_svn_auth_invoke_simple_provider_func},
{"SVN::_Core::svn_auth_invoke_ssl_client_cert_pw_provider_func", _wrap_svn_auth_invoke_ssl_client_cert_pw_provider_func},
{"SVN::_Core::svn_auth_invoke_simple_prompt_func", _wrap_svn_auth_invoke_simple_prompt_func},
{"SVN::_Core::svn_auth_invoke_username_prompt_func", _wrap_svn_auth_invoke_username_prompt_func},
{"SVN::_Core::svn_auth_invoke_ssl_server_trust_prompt_func", _wrap_svn_auth_invoke_ssl_server_trust_prompt_func},
{"SVN::_Core::svn_auth_invoke_ssl_client_cert_prompt_func", _wrap_svn_auth_invoke_ssl_client_cert_prompt_func},
{"SVN::_Core::svn_auth_invoke_ssl_client_cert_pw_prompt_func", _wrap_svn_auth_invoke_ssl_client_cert_pw_prompt_func},
{"SVN::_Core::svn_auth_invoke_plaintext_prompt_func", _wrap_svn_auth_invoke_plaintext_prompt_func},
{"SVN::_Core::svn_auth_invoke_plaintext_passphrase_prompt_func", _wrap_svn_auth_invoke_plaintext_passphrase_prompt_func},
{"SVN::_Core::svn_config_get_config", _wrap_svn_config_get_config},
{"SVN::_Core::svn_config_create", _wrap_svn_config_create},
{"SVN::_Core::svn_config_read2", _wrap_svn_config_read2},
{"SVN::_Core::svn_config_read", _wrap_svn_config_read},
{"SVN::_Core::svn_config_merge", _wrap_svn_config_merge},
{"SVN::_Core::svn_config_get", _wrap_svn_config_get},
{"SVN::_Core::svn_config_set", _wrap_svn_config_set},
{"SVN::_Core::svn_config_get_bool", _wrap_svn_config_get_bool},
{"SVN::_Core::svn_config_set_bool", _wrap_svn_config_set_bool},
{"SVN::_Core::svn_config_get_yes_no_ask", _wrap_svn_config_get_yes_no_ask},
{"SVN::_Core::svn_config_enumerate_sections", _wrap_svn_config_enumerate_sections},
{"SVN::_Core::svn_config_enumerate_sections2", _wrap_svn_config_enumerate_sections2},
{"SVN::_Core::svn_config_enumerate", _wrap_svn_config_enumerate},
{"SVN::_Core::svn_config_enumerate2", _wrap_svn_config_enumerate2},
{"SVN::_Core::svn_config_has_section", _wrap_svn_config_has_section},
{"SVN::_Core::svn_config_find_group", _wrap_svn_config_find_group},
{"SVN::_Core::svn_config_get_server_setting", _wrap_svn_config_get_server_setting},
{"SVN::_Core::svn_config_get_server_setting_int", _wrap_svn_config_get_server_setting_int},
{"SVN::_Core::svn_config_get_server_setting_bool", _wrap_svn_config_get_server_setting_bool},
{"SVN::_Core::svn_config_ensure", _wrap_svn_config_ensure},
{"SVN::_Core::svn_config_read_auth_data", _wrap_svn_config_read_auth_data},
{"SVN::_Core::svn_config_write_auth_data", _wrap_svn_config_write_auth_data},
{"SVN::_Core::svn_config_get_user_config_path", _wrap_svn_config_get_user_config_path},
{"SVN::_Core::svn_config_invoke_section_enumerator", _wrap_svn_config_invoke_section_enumerator},
{"SVN::_Core::svn_config_invoke_section_enumerator2", _wrap_svn_config_invoke_section_enumerator2},
{"SVN::_Core::svn_config_invoke_enumerator", _wrap_svn_config_invoke_enumerator},
{"SVN::_Core::svn_config_invoke_enumerator2", _wrap_svn_config_invoke_enumerator2},
{"SVN::_Core::svn_utf_initialize", _wrap_svn_utf_initialize},
{"SVN::_Core::svn_utf_stringbuf_to_utf8", _wrap_svn_utf_stringbuf_to_utf8},
{"SVN::_Core::svn_utf_string_to_utf8", _wrap_svn_utf_string_to_utf8},
{"SVN::_Core::svn_utf_cstring_to_utf8", _wrap_svn_utf_cstring_to_utf8},
{"SVN::_Core::svn_utf_cstring_to_utf8_ex2", _wrap_svn_utf_cstring_to_utf8_ex2},
{"SVN::_Core::svn_utf_cstring_to_utf8_ex", _wrap_svn_utf_cstring_to_utf8_ex},
{"SVN::_Core::svn_utf_stringbuf_from_utf8", _wrap_svn_utf_stringbuf_from_utf8},
{"SVN::_Core::svn_utf_string_from_utf8", _wrap_svn_utf_string_from_utf8},
{"SVN::_Core::svn_utf_cstring_from_utf8", _wrap_svn_utf_cstring_from_utf8},
{"SVN::_Core::svn_utf_cstring_from_utf8_ex2", _wrap_svn_utf_cstring_from_utf8_ex2},
{"SVN::_Core::svn_utf_cstring_from_utf8_ex", _wrap_svn_utf_cstring_from_utf8_ex},
{"SVN::_Core::svn_utf_cstring_from_utf8_fuzzy", _wrap_svn_utf_cstring_from_utf8_fuzzy},
{"SVN::_Core::svn_utf_cstring_from_utf8_stringbuf", _wrap_svn_utf_cstring_from_utf8_stringbuf},
{"SVN::_Core::svn_utf_cstring_from_utf8_string", _wrap_svn_utf_cstring_from_utf8_string},
{"SVN::_Core::svn_nls_init", _wrap_svn_nls_init},
{"SVN::_Core::svn_path_internal_style", _wrap_svn_path_internal_style},
{"SVN::_Core::svn_path_local_style", _wrap_svn_path_local_style},
{"SVN::_Core::svn_path_splitext", _wrap_svn_path_splitext},
{"SVN::_Core::svn_path_is_empty", _wrap_svn_path_is_empty},
{"SVN::_Core::svn_dirent_is_root", _wrap_svn_dirent_is_root},
{"SVN::_Core::svn_path_canonicalize", _wrap_svn_path_canonicalize},
{"SVN::_Core::svn_path_is_canonical", _wrap_svn_path_is_canonical},
{"SVN::_Core::svn_path_compare_paths", _wrap_svn_path_compare_paths},
{"SVN::_Core::svn_path_get_longest_ancestor", _wrap_svn_path_get_longest_ancestor},
{"SVN::_Core::svn_path_is_dotpath_present", _wrap_svn_path_is_dotpath_present},
{"SVN::_Core::svn_path_is_url", _wrap_svn_path_is_url},
{"SVN::_Core::svn_path_is_uri_safe", _wrap_svn_path_is_uri_safe},
{"SVN::_Core::svn_path_url_add_component2", _wrap_svn_path_url_add_component2},
{"SVN::_Core::svn_dirent_internal_style", _wrap_svn_dirent_internal_style},
{"SVN::_Core::svn_dirent_local_style", _wrap_svn_dirent_local_style},
{"SVN::_Core::svn_relpath__internal_style", _wrap_svn_relpath__internal_style},
{"SVN::_Core::svn_dirent_join", _wrap_svn_dirent_join},
{"SVN::_Core::svn_relpath_join", _wrap_svn_relpath_join},
{"SVN::_Core::svn_dirent_basename", _wrap_svn_dirent_basename},
{"SVN::_Core::svn_dirent_dirname", _wrap_svn_dirent_dirname},
{"SVN::_Core::svn_dirent_split", _wrap_svn_dirent_split},
{"SVN::_Core::svn_relpath_split", _wrap_svn_relpath_split},
{"SVN::_Core::svn_relpath_basename", _wrap_svn_relpath_basename},
{"SVN::_Core::svn_relpath_dirname", _wrap_svn_relpath_dirname},
{"SVN::_Core::svn_uri_split", _wrap_svn_uri_split},
{"SVN::_Core::svn_uri_basename", _wrap_svn_uri_basename},
{"SVN::_Core::svn_uri_dirname", _wrap_svn_uri_dirname},
{"SVN::_Core::svn_dirent_is_absolute", _wrap_svn_dirent_is_absolute},
{"SVN::_Core::svn_uri_is_root", _wrap_svn_uri_is_root},
{"SVN::_Core::svn_dirent_canonicalize", _wrap_svn_dirent_canonicalize},
{"SVN::_Core::svn_relpath_canonicalize", _wrap_svn_relpath_canonicalize},
{"SVN::_Core::svn_uri_canonicalize", _wrap_svn_uri_canonicalize},
{"SVN::_Core::svn_dirent_is_canonical", _wrap_svn_dirent_is_canonical},
{"SVN::_Core::svn_relpath_is_canonical", _wrap_svn_relpath_is_canonical},
{"SVN::_Core::svn_uri_is_canonical", _wrap_svn_uri_is_canonical},
{"SVN::_Core::svn_dirent_get_longest_ancestor", _wrap_svn_dirent_get_longest_ancestor},
{"SVN::_Core::svn_relpath_get_longest_ancestor", _wrap_svn_relpath_get_longest_ancestor},
{"SVN::_Core::svn_uri_get_longest_ancestor", _wrap_svn_uri_get_longest_ancestor},
{"SVN::_Core::svn_dirent_get_absolute", _wrap_svn_dirent_get_absolute},
{"SVN::_Core::svn_uri__is_child", _wrap_svn_uri__is_child},
{"SVN::_Core::svn_dirent_is_child", _wrap_svn_dirent_is_child},
{"SVN::_Core::svn_relpath__is_child", _wrap_svn_relpath__is_child},
{"SVN::_Core::svn_dirent_is_ancestor", _wrap_svn_dirent_is_ancestor},
{"SVN::_Core::svn_relpath__is_ancestor", _wrap_svn_relpath__is_ancestor},
{"SVN::_Core::svn_uri__is_ancestor", _wrap_svn_uri__is_ancestor},
{"SVN::_Core::svn_dirent_skip_ancestor", _wrap_svn_dirent_skip_ancestor},
{"SVN::_Core::svn_relpath_skip_ancestor", _wrap_svn_relpath_skip_ancestor},
{"SVN::_Core::svn_uri_skip_ancestor", _wrap_svn_uri_skip_ancestor},
{"SVN::_Core::svn_uri_get_dirent_from_file_url", _wrap_svn_uri_get_dirent_from_file_url},
{"SVN::_Core::svn_uri_get_file_url_from_dirent", _wrap_svn_uri_get_file_url_from_dirent},
{"SVN::_Core::svn_mergeinfo_parse", _wrap_svn_mergeinfo_parse},
{"SVN::_Core::svn_mergeinfo_diff", _wrap_svn_mergeinfo_diff},
{"SVN::_Core::svn_mergeinfo_catalog_merge", _wrap_svn_mergeinfo_catalog_merge},
{"SVN::_Core::svn_mergeinfo_remove", _wrap_svn_mergeinfo_remove},
{"SVN::_Core::svn_mergeinfo_remove2", _wrap_svn_mergeinfo_remove2},
{"SVN::_Core::svn_rangelist_diff", _wrap_svn_rangelist_diff},
{"SVN::_Core::svn_rangelist_remove", _wrap_svn_rangelist_remove},
{"SVN::_Core::svn_mergeinfo_intersect2", _wrap_svn_mergeinfo_intersect2},
{"SVN::_Core::svn_mergeinfo_intersect", _wrap_svn_mergeinfo_intersect},
{"SVN::_Core::svn_rangelist_intersect", _wrap_svn_rangelist_intersect},
{"SVN::_Core::svn_rangelist_to_string", _wrap_svn_rangelist_to_string},
{"SVN::_Core::svn_rangelist_inheritable2", _wrap_svn_rangelist_inheritable2},
{"SVN::_Core::svn_rangelist_inheritable", _wrap_svn_rangelist_inheritable},
{"SVN::_Core::svn_mergeinfo_inheritable2", _wrap_svn_mergeinfo_inheritable2},
{"SVN::_Core::svn_mergeinfo_inheritable", _wrap_svn_mergeinfo_inheritable},
{"SVN::_Core::svn_mergeinfo_to_string", _wrap_svn_mergeinfo_to_string},
{"SVN::_Core::svn_mergeinfo_catalog_dup", _wrap_svn_mergeinfo_catalog_dup},
{"SVN::_Core::svn_mergeinfo_dup", _wrap_svn_mergeinfo_dup},
{"SVN::_Core::svn_rangelist_dup", _wrap_svn_rangelist_dup},
{"SVN::_Core::svn_inheritance_to_word", _wrap_svn_inheritance_to_word},
{"SVN::_Core::svn_inheritance_from_word", _wrap_svn_inheritance_from_word},
{"SVN::_Core::svn_io_dirent2_t_kind_set", _wrap_svn_io_dirent2_t_kind_set},
{"SVN::_Core::svn_io_dirent2_t_kind_get", _wrap_svn_io_dirent2_t_kind_get},
{"SVN::_Core::svn_io_dirent2_t_special_set", _wrap_svn_io_dirent2_t_special_set},
{"SVN::_Core::svn_io_dirent2_t_special_get", _wrap_svn_io_dirent2_t_special_get},
{"SVN::_Core::svn_io_dirent2_t_filesize_set", _wrap_svn_io_dirent2_t_filesize_set},
{"SVN::_Core::svn_io_dirent2_t_filesize_get", _wrap_svn_io_dirent2_t_filesize_get},
{"SVN::_Core::svn_io_dirent2_t_mtime_set", _wrap_svn_io_dirent2_t_mtime_set},
{"SVN::_Core::svn_io_dirent2_t_mtime_get", _wrap_svn_io_dirent2_t_mtime_get},
{"SVN::_Core::new_svn_io_dirent2_t", _wrap_new_svn_io_dirent2_t},
{"SVN::_Core::delete_svn_io_dirent2_t", _wrap_delete_svn_io_dirent2_t},
{"SVN::_Core::svn_io_dirent2_create", _wrap_svn_io_dirent2_create},
{"SVN::_Core::svn_io_dirent2_dup", _wrap_svn_io_dirent2_dup},
{"SVN::_Core::svn_io_dirent_t_kind_set", _wrap_svn_io_dirent_t_kind_set},
{"SVN::_Core::svn_io_dirent_t_kind_get", _wrap_svn_io_dirent_t_kind_get},
{"SVN::_Core::svn_io_dirent_t_special_set", _wrap_svn_io_dirent_t_special_set},
{"SVN::_Core::svn_io_dirent_t_special_get", _wrap_svn_io_dirent_t_special_get},
{"SVN::_Core::new_svn_io_dirent_t", _wrap_new_svn_io_dirent_t},
{"SVN::_Core::delete_svn_io_dirent_t", _wrap_delete_svn_io_dirent_t},
{"SVN::_Core::svn_io_open_uniquely_named", _wrap_svn_io_open_uniquely_named},
{"SVN::_Core::svn_io_open_unique_file3", _wrap_svn_io_open_unique_file3},
{"SVN::_Core::svn_io_open_unique_file2", _wrap_svn_io_open_unique_file2},
{"SVN::_Core::svn_io_open_unique_file", _wrap_svn_io_open_unique_file},
{"SVN::_Core::svn_io_copy_perms", _wrap_svn_io_copy_perms},
{"SVN::_Core::svn_io_sleep_for_timestamps", _wrap_svn_io_sleep_for_timestamps},
{"SVN::_Core::svn_io_file_checksum2", _wrap_svn_io_file_checksum2},
{"SVN::_Core::svn_io_file_checksum", _wrap_svn_io_file_checksum},
{"SVN::_Core::svn_io_files_contents_same_p", _wrap_svn_io_files_contents_same_p},
{"SVN::_Core::svn_stream_set_skip", _wrap_svn_stream_set_skip},
{"SVN::_Core::svn_stream_set_mark", _wrap_svn_stream_set_mark},
{"SVN::_Core::svn_stream_set_seek", _wrap_svn_stream_set_seek},
{"SVN::_Core::svn_stream_empty", _wrap_svn_stream_empty},
{"SVN::_Core::svn_stream_disown", _wrap_svn_stream_disown},
{"SVN::_Core::svn_stream_open_readonly", _wrap_svn_stream_open_readonly},
{"SVN::_Core::svn_stream_open_writable", _wrap_svn_stream_open_writable},
{"SVN::_Core::svn_stream_open_unique", _wrap_svn_stream_open_unique},
{"SVN::_Core::svn_stream_from_aprfile2", _wrap_svn_stream_from_aprfile2},
{"SVN::_Core::svn_stream_from_aprfile", _wrap_svn_stream_from_aprfile},
{"SVN::_Core::svn_stream_for_stdin", _wrap_svn_stream_for_stdin},
{"SVN::_Core::svn_stream_for_stderr", _wrap_svn_stream_for_stderr},
{"SVN::_Core::svn_stream_for_stdout", _wrap_svn_stream_for_stdout},
{"SVN::_Core::svn_stream_from_stringbuf", _wrap_svn_stream_from_stringbuf},
{"SVN::_Core::svn_stream_from_string", _wrap_svn_stream_from_string},
{"SVN::_Core::svn_stream_compressed", _wrap_svn_stream_compressed},
{"SVN::_Core::svn_stream_checksummed2", _wrap_svn_stream_checksummed2},
{"SVN::_Core::svn_stream_read", _wrap_svn_stream_read},
{"SVN::_Core::svn_stream_skip", _wrap_svn_stream_skip},
{"SVN::_Core::svn_stream_write", _wrap_svn_stream_write},
{"SVN::_Core::svn_stream_close", _wrap_svn_stream_close},
{"SVN::_Core::svn_stream_reset", _wrap_svn_stream_reset},
{"SVN::_Core::svn_stream_supports_mark", _wrap_svn_stream_supports_mark},
{"SVN::_Core::svn_stream_mark", _wrap_svn_stream_mark},
{"SVN::_Core::svn_stream_seek", _wrap_svn_stream_seek},
{"SVN::_Core::svn_stream_tee", _wrap_svn_stream_tee},
{"SVN::_Core::svn_stream_readline", _wrap_svn_stream_readline},
{"SVN::_Core::svn_stream_copy3", _wrap_svn_stream_copy3},
{"SVN::_Core::svn_stream_copy2", _wrap_svn_stream_copy2},
{"SVN::_Core::svn_stream_copy", _wrap_svn_stream_copy},
{"SVN::_Core::svn_stream_contents_same2", _wrap_svn_stream_contents_same2},
{"SVN::_Core::svn_stream_contents_same", _wrap_svn_stream_contents_same},
{"SVN::_Core::svn_string_from_stream", _wrap_svn_string_from_stream},
{"SVN::_Core::svn_stringbuf_from_file2", _wrap_svn_stringbuf_from_file2},
{"SVN::_Core::svn_stringbuf_from_file", _wrap_svn_stringbuf_from_file},
{"SVN::_Core::svn_stringbuf_from_aprfile", _wrap_svn_stringbuf_from_aprfile},
{"SVN::_Core::svn_io_remove_file2", _wrap_svn_io_remove_file2},
{"SVN::_Core::svn_io_remove_dir2", _wrap_svn_io_remove_dir2},
{"SVN::_Core::svn_io_get_dirents3", _wrap_svn_io_get_dirents3},
{"SVN::_Core::svn_io_stat_dirent", _wrap_svn_io_stat_dirent},
{"SVN::_Core::svn_io_dir_walk2", _wrap_svn_io_dir_walk2},
{"SVN::_Core::svn_io_start_cmd2", _wrap_svn_io_start_cmd2},
{"SVN::_Core::svn_io_run_diff2", _wrap_svn_io_run_diff2},
{"SVN::_Core::svn_io_run_diff3_3", _wrap_svn_io_run_diff3_3},
{"SVN::_Core::svn_io_parse_mimetypes_file", _wrap_svn_io_parse_mimetypes_file},
{"SVN::_Core::svn_io_detect_mimetype2", _wrap_svn_io_detect_mimetype2},
{"SVN::_Core::svn_io_detect_mimetype", _wrap_svn_io_detect_mimetype},
{"SVN::_Core::svn_io_is_binary_data", _wrap_svn_io_is_binary_data},
{"SVN::_Core::svn_io_file_putc", _wrap_svn_io_file_putc},
{"SVN::_Core::svn_io_file_read_full2", _wrap_svn_io_file_read_full2},
{"SVN::_Core::svn_io_write_unique", _wrap_svn_io_write_unique},
{"SVN::_Core::svn_io_file_trunc", _wrap_svn_io_file_trunc},
{"SVN::_Core::svn_io_dir_close", _wrap_svn_io_dir_close},
{"SVN::_Core::svn_io_file_name_get", _wrap_svn_io_file_name_get},
{"SVN::_Core::svn_read_invoke_fn", _wrap_svn_read_invoke_fn},
{"SVN::_Core::svn_stream_invoke_skip_fn", _wrap_svn_stream_invoke_skip_fn},
{"SVN::_Core::svn_write_invoke_fn", _wrap_svn_write_invoke_fn},
{"SVN::_Core::svn_close_invoke_fn", _wrap_svn_close_invoke_fn},
{"SVN::_Core::svn_stream_invoke_mark_fn", _wrap_svn_stream_invoke_mark_fn},
{"SVN::_Core::svn_stream_invoke_seek_fn", _wrap_svn_stream_invoke_seek_fn},
{"SVN::_Core::svn_io_invoke_walk_func", _wrap_svn_io_invoke_walk_func},
{"SVN::_Core::svn_md5_empty_string_digest", _wrap_svn_md5_empty_string_digest},
{"SVN::_Core::svn_md5_digest_to_cstring_display", _wrap_svn_md5_digest_to_cstring_display},
{"SVN::_Core::svn_md5_digest_to_cstring", _wrap_svn_md5_digest_to_cstring},
{"SVN::_Core::svn_md5_digests_match", _wrap_svn_md5_digests_match},
{"SVN::_Core::svn_diff_version", _wrap_svn_diff_version},
{"SVN::_Core::svn_diff_fns2_t_datasources_open_set", _wrap_svn_diff_fns2_t_datasources_open_set},
{"SVN::_Core::svn_diff_fns2_t_datasources_open_get", _wrap_svn_diff_fns2_t_datasources_open_get},
{"SVN::_Core::svn_diff_fns2_t_datasource_close_set", _wrap_svn_diff_fns2_t_datasource_close_set},
{"SVN::_Core::svn_diff_fns2_t_datasource_close_get", _wrap_svn_diff_fns2_t_datasource_close_get},
{"SVN::_Core::svn_diff_fns2_t_datasource_get_next_token_set", _wrap_svn_diff_fns2_t_datasource_get_next_token_set},
{"SVN::_Core::svn_diff_fns2_t_datasource_get_next_token_get", _wrap_svn_diff_fns2_t_datasource_get_next_token_get},
{"SVN::_Core::svn_diff_fns2_t_token_compare_set", _wrap_svn_diff_fns2_t_token_compare_set},
{"SVN::_Core::svn_diff_fns2_t_token_compare_get", _wrap_svn_diff_fns2_t_token_compare_get},
{"SVN::_Core::svn_diff_fns2_t_token_discard_set", _wrap_svn_diff_fns2_t_token_discard_set},
{"SVN::_Core::svn_diff_fns2_t_token_discard_get", _wrap_svn_diff_fns2_t_token_discard_get},
{"SVN::_Core::svn_diff_fns2_t_token_discard_all_set", _wrap_svn_diff_fns2_t_token_discard_all_set},
{"SVN::_Core::svn_diff_fns2_t_token_discard_all_get", _wrap_svn_diff_fns2_t_token_discard_all_get},
{"SVN::_Core::new_svn_diff_fns2_t", _wrap_new_svn_diff_fns2_t},
{"SVN::_Core::delete_svn_diff_fns2_t", _wrap_delete_svn_diff_fns2_t},
{"SVN::_Core::svn_diff_fns_t_datasource_open_set", _wrap_svn_diff_fns_t_datasource_open_set},
{"SVN::_Core::svn_diff_fns_t_datasource_open_get", _wrap_svn_diff_fns_t_datasource_open_get},
{"SVN::_Core::svn_diff_fns_t_datasource_close_set", _wrap_svn_diff_fns_t_datasource_close_set},
{"SVN::_Core::svn_diff_fns_t_datasource_close_get", _wrap_svn_diff_fns_t_datasource_close_get},
{"SVN::_Core::svn_diff_fns_t_datasource_get_next_token_set", _wrap_svn_diff_fns_t_datasource_get_next_token_set},
{"SVN::_Core::svn_diff_fns_t_datasource_get_next_token_get", _wrap_svn_diff_fns_t_datasource_get_next_token_get},
{"SVN::_Core::svn_diff_fns_t_token_compare_set", _wrap_svn_diff_fns_t_token_compare_set},
{"SVN::_Core::svn_diff_fns_t_token_compare_get", _wrap_svn_diff_fns_t_token_compare_get},
{"SVN::_Core::svn_diff_fns_t_token_discard_set", _wrap_svn_diff_fns_t_token_discard_set},
{"SVN::_Core::svn_diff_fns_t_token_discard_get", _wrap_svn_diff_fns_t_token_discard_get},
{"SVN::_Core::svn_diff_fns_t_token_discard_all_set", _wrap_svn_diff_fns_t_token_discard_all_set},
{"SVN::_Core::svn_diff_fns_t_token_discard_all_get", _wrap_svn_diff_fns_t_token_discard_all_get},
{"SVN::_Core::new_svn_diff_fns_t", _wrap_new_svn_diff_fns_t},
{"SVN::_Core::delete_svn_diff_fns_t", _wrap_delete_svn_diff_fns_t},
{"SVN::_Core::svn_diff_diff_2", _wrap_svn_diff_diff_2},
{"SVN::_Core::svn_diff_diff", _wrap_svn_diff_diff},
{"SVN::_Core::svn_diff_diff3_2", _wrap_svn_diff_diff3_2},
{"SVN::_Core::svn_diff_diff3", _wrap_svn_diff_diff3},
{"SVN::_Core::svn_diff_diff4_2", _wrap_svn_diff_diff4_2},
{"SVN::_Core::svn_diff_diff4", _wrap_svn_diff_diff4},
{"SVN::_Core::svn_diff_contains_conflicts", _wrap_svn_diff_contains_conflicts},
{"SVN::_Core::svn_diff_contains_diffs", _wrap_svn_diff_contains_diffs},
{"SVN::_Core::svn_diff_output_fns_t_output_common_set", _wrap_svn_diff_output_fns_t_output_common_set},
{"SVN::_Core::svn_diff_output_fns_t_output_common_get", _wrap_svn_diff_output_fns_t_output_common_get},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_modified_set", _wrap_svn_diff_output_fns_t_output_diff_modified_set},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_modified_get", _wrap_svn_diff_output_fns_t_output_diff_modified_get},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_latest_set", _wrap_svn_diff_output_fns_t_output_diff_latest_set},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_latest_get", _wrap_svn_diff_output_fns_t_output_diff_latest_get},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_common_set", _wrap_svn_diff_output_fns_t_output_diff_common_set},
{"SVN::_Core::svn_diff_output_fns_t_output_diff_common_get", _wrap_svn_diff_output_fns_t_output_diff_common_get},
{"SVN::_Core::svn_diff_output_fns_t_output_conflict_set", _wrap_svn_diff_output_fns_t_output_conflict_set},
{"SVN::_Core::svn_diff_output_fns_t_output_conflict_get", _wrap_svn_diff_output_fns_t_output_conflict_get},
{"SVN::_Core::new_svn_diff_output_fns_t", _wrap_new_svn_diff_output_fns_t},
{"SVN::_Core::delete_svn_diff_output_fns_t", _wrap_delete_svn_diff_output_fns_t},
{"SVN::_Core::svn_diff_output", _wrap_svn_diff_output},
{"SVN::_Core::svn_diff_file_options_t_ignore_space_set", _wrap_svn_diff_file_options_t_ignore_space_set},
{"SVN::_Core::svn_diff_file_options_t_ignore_space_get", _wrap_svn_diff_file_options_t_ignore_space_get},
{"SVN::_Core::svn_diff_file_options_t_ignore_eol_style_set", _wrap_svn_diff_file_options_t_ignore_eol_style_set},
{"SVN::_Core::svn_diff_file_options_t_ignore_eol_style_get", _wrap_svn_diff_file_options_t_ignore_eol_style_get},
{"SVN::_Core::svn_diff_file_options_t_show_c_function_set", _wrap_svn_diff_file_options_t_show_c_function_set},
{"SVN::_Core::svn_diff_file_options_t_show_c_function_get", _wrap_svn_diff_file_options_t_show_c_function_get},
{"SVN::_Core::new_svn_diff_file_options_t", _wrap_new_svn_diff_file_options_t},
{"SVN::_Core::delete_svn_diff_file_options_t", _wrap_delete_svn_diff_file_options_t},
{"SVN::_Core::svn_diff_file_options_create", _wrap_svn_diff_file_options_create},
{"SVN::_Core::svn_diff_file_options_parse", _wrap_svn_diff_file_options_parse},
{"SVN::_Core::svn_diff_file_diff_2", _wrap_svn_diff_file_diff_2},
{"SVN::_Core::svn_diff_file_diff", _wrap_svn_diff_file_diff},
{"SVN::_Core::svn_diff_file_diff3_2", _wrap_svn_diff_file_diff3_2},
{"SVN::_Core::svn_diff_file_diff3", _wrap_svn_diff_file_diff3},
{"SVN::_Core::svn_diff_file_diff4_2", _wrap_svn_diff_file_diff4_2},
{"SVN::_Core::svn_diff_file_diff4", _wrap_svn_diff_file_diff4},
{"SVN::_Core::svn_diff_file_output_unified3", _wrap_svn_diff_file_output_unified3},
{"SVN::_Core::svn_diff_file_output_unified2", _wrap_svn_diff_file_output_unified2},
{"SVN::_Core::svn_diff_file_output_unified", _wrap_svn_diff_file_output_unified},
{"SVN::_Core::svn_diff_file_output_merge2", _wrap_svn_diff_file_output_merge2},
{"SVN::_Core::svn_diff_file_output_merge", _wrap_svn_diff_file_output_merge},
{"SVN::_Core::svn_diff_mem_string_diff", _wrap_svn_diff_mem_string_diff},
{"SVN::_Core::svn_diff_mem_string_diff3", _wrap_svn_diff_mem_string_diff3},
{"SVN::_Core::svn_diff_mem_string_diff4", _wrap_svn_diff_mem_string_diff4},
{"SVN::_Core::svn_diff_mem_string_output_unified2", _wrap_svn_diff_mem_string_output_unified2},
{"SVN::_Core::svn_diff_mem_string_output_unified", _wrap_svn_diff_mem_string_output_unified},
{"SVN::_Core::svn_diff_mem_string_output_merge2", _wrap_svn_diff_mem_string_output_merge2},
{"SVN::_Core::svn_diff_mem_string_output_merge", _wrap_svn_diff_mem_string_output_merge},
{"SVN::_Core::svn_diff_hunk_readline_diff_text", _wrap_svn_diff_hunk_readline_diff_text},
{"SVN::_Core::svn_diff_hunk_readline_original_text", _wrap_svn_diff_hunk_readline_original_text},
{"SVN::_Core::svn_diff_hunk_readline_modified_text", _wrap_svn_diff_hunk_readline_modified_text},
{"SVN::_Core::svn_diff_hunk_reset_diff_text", _wrap_svn_diff_hunk_reset_diff_text},
{"SVN::_Core::svn_diff_hunk_reset_original_text", _wrap_svn_diff_hunk_reset_original_text},
{"SVN::_Core::svn_diff_hunk_reset_modified_text", _wrap_svn_diff_hunk_reset_modified_text},
{"SVN::_Core::svn_diff_hunk_get_original_start", _wrap_svn_diff_hunk_get_original_start},
{"SVN::_Core::svn_diff_hunk_get_original_length", _wrap_svn_diff_hunk_get_original_length},
{"SVN::_Core::svn_diff_hunk_get_modified_start", _wrap_svn_diff_hunk_get_modified_start},
{"SVN::_Core::svn_diff_hunk_get_modified_length", _wrap_svn_diff_hunk_get_modified_length},
{"SVN::_Core::svn_diff_hunk_get_leading_context", _wrap_svn_diff_hunk_get_leading_context},
{"SVN::_Core::svn_diff_hunk_get_trailing_context", _wrap_svn_diff_hunk_get_trailing_context},
{"SVN::_Core::svn_prop_patch_t_name_set", _wrap_svn_prop_patch_t_name_set},
{"SVN::_Core::svn_prop_patch_t_name_get", _wrap_svn_prop_patch_t_name_get},
{"SVN::_Core::svn_prop_patch_t_operation_set", _wrap_svn_prop_patch_t_operation_set},
{"SVN::_Core::svn_prop_patch_t_operation_get", _wrap_svn_prop_patch_t_operation_get},
{"SVN::_Core::svn_prop_patch_t_hunks_set", _wrap_svn_prop_patch_t_hunks_set},
{"SVN::_Core::svn_prop_patch_t_hunks_get", _wrap_svn_prop_patch_t_hunks_get},
{"SVN::_Core::new_svn_prop_patch_t", _wrap_new_svn_prop_patch_t},
{"SVN::_Core::delete_svn_prop_patch_t", _wrap_delete_svn_prop_patch_t},
{"SVN::_Core::svn_patch_t_old_filename_set", _wrap_svn_patch_t_old_filename_set},
{"SVN::_Core::svn_patch_t_old_filename_get", _wrap_svn_patch_t_old_filename_get},
{"SVN::_Core::svn_patch_t_new_filename_set", _wrap_svn_patch_t_new_filename_set},
{"SVN::_Core::svn_patch_t_new_filename_get", _wrap_svn_patch_t_new_filename_get},
{"SVN::_Core::svn_patch_t_hunks_set", _wrap_svn_patch_t_hunks_set},
{"SVN::_Core::svn_patch_t_hunks_get", _wrap_svn_patch_t_hunks_get},
{"SVN::_Core::svn_patch_t_prop_patches_set", _wrap_svn_patch_t_prop_patches_set},
{"SVN::_Core::svn_patch_t_prop_patches_get", _wrap_svn_patch_t_prop_patches_get},
{"SVN::_Core::svn_patch_t_operation_set", _wrap_svn_patch_t_operation_set},
{"SVN::_Core::svn_patch_t_operation_get", _wrap_svn_patch_t_operation_get},
{"SVN::_Core::svn_patch_t_reverse_set", _wrap_svn_patch_t_reverse_set},
{"SVN::_Core::svn_patch_t_reverse_get", _wrap_svn_patch_t_reverse_get},
{"SVN::_Core::new_svn_patch_t", _wrap_new_svn_patch_t},
{"SVN::_Core::delete_svn_patch_t", _wrap_delete_svn_patch_t},
{"SVN::_Core::svn_diff_open_patch_file", _wrap_svn_diff_open_patch_file},
{"SVN::_Core::svn_diff_parse_next_patch", _wrap_svn_diff_parse_next_patch},
{"SVN::_Core::svn_diff_close_patch_file", _wrap_svn_diff_close_patch_file},
{"SVN::_Core::svn_diff_fns2_invoke_datasources_open", _wrap_svn_diff_fns2_invoke_datasources_open},
{"SVN::_Core::svn_diff_fns2_invoke_datasource_close", _wrap_svn_diff_fns2_invoke_datasource_close},
{"SVN::_Core::svn_diff_fns2_invoke_datasource_get_next_token", _wrap_svn_diff_fns2_invoke_datasource_get_next_token},
{"SVN::_Core::svn_diff_fns2_invoke_token_compare", _wrap_svn_diff_fns2_invoke_token_compare},
{"SVN::_Core::svn_diff_fns2_invoke_token_discard", _wrap_svn_diff_fns2_invoke_token_discard},
{"SVN::_Core::svn_diff_fns2_invoke_token_discard_all", _wrap_svn_diff_fns2_invoke_token_discard_all},
{"SVN::_Core::svn_diff_fns_invoke_datasource_open", _wrap_svn_diff_fns_invoke_datasource_open},
{"SVN::_Core::svn_diff_fns_invoke_datasource_close", _wrap_svn_diff_fns_invoke_datasource_close},
{"SVN::_Core::svn_diff_fns_invoke_datasource_get_next_token", _wrap_svn_diff_fns_invoke_datasource_get_next_token},
{"SVN::_Core::svn_diff_fns_invoke_token_compare", _wrap_svn_diff_fns_invoke_token_compare},
{"SVN::_Core::svn_diff_fns_invoke_token_discard", _wrap_svn_diff_fns_invoke_token_discard},
{"SVN::_Core::svn_diff_fns_invoke_token_discard_all", _wrap_svn_diff_fns_invoke_token_discard_all},
{"SVN::_Core::svn_diff_output_fns_invoke_output_common", _wrap_svn_diff_output_fns_invoke_output_common},
{"SVN::_Core::svn_diff_output_fns_invoke_output_diff_modified", _wrap_svn_diff_output_fns_invoke_output_diff_modified},
{"SVN::_Core::svn_diff_output_fns_invoke_output_diff_latest", _wrap_svn_diff_output_fns_invoke_output_diff_latest},
{"SVN::_Core::svn_diff_output_fns_invoke_output_diff_common", _wrap_svn_diff_output_fns_invoke_output_diff_common},
{"SVN::_Core::svn_diff_output_fns_invoke_output_conflict", _wrap_svn_diff_output_fns_invoke_output_conflict},
{"SVN::_Core::svn_strerror", _wrap_svn_strerror},
{"SVN::_Core::svn_err_best_message", _wrap_svn_err_best_message},
{"SVN::_Core::svn_error_create", _wrap_svn_error_create},
{"SVN::_Core::svn_error_createf", _wrap_svn_error_createf},
{"SVN::_Core::svn_error_wrap_apr", _wrap_svn_error_wrap_apr},
{"SVN::_Core::svn_error_quick_wrap", _wrap_svn_error_quick_wrap},
{"SVN::_Core::svn_error_compose_create", _wrap_svn_error_compose_create},
{"SVN::_Core::svn_error_compose", _wrap_svn_error_compose},
{"SVN::_Core::svn_error_root_cause", _wrap_svn_error_root_cause},
{"SVN::_Core::svn_error_find_cause", _wrap_svn_error_find_cause},
{"SVN::_Core::svn_error_dup", _wrap_svn_error_dup},
{"SVN::_Core::svn_error_clear", _wrap_svn_error_clear},
{"SVN::_Core::svn_handle_error2", _wrap_svn_handle_error2},
{"SVN::_Core::svn_handle_error", _wrap_svn_handle_error},
{"SVN::_Core::svn_handle_warning2", _wrap_svn_handle_warning2},
{"SVN::_Core::svn_handle_warning", _wrap_svn_handle_warning},
{"SVN::_Core::svn_error_purge_tracing", _wrap_svn_error_purge_tracing},
{"SVN::_Core::svn_error__malfunction", _wrap_svn_error__malfunction},
{"SVN::_Core::svn_error_set_malfunction_handler", _wrap_svn_error_set_malfunction_handler},
{"SVN::_Core::svn_error_raise_on_malfunction", _wrap_svn_error_raise_on_malfunction},
{"SVN::_Core::svn_error_abort_on_malfunction", _wrap_svn_error_abort_on_malfunction},
{"SVN::_Core::svn_error_invoke_malfunction_handler", _wrap_svn_error_invoke_malfunction_handler},
{0,0}
};
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;
  
  clientdata = clientdata;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpeters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
  dXSARGS;
  int i;
  
  SWIG_InitializeModule(0);
  
  /* Install commands */
  for (i = 0; swig_commands[i].name; i++) {
    newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
  }
  
  /* Install variables */
  for (i = 0; swig_variables[i].name; i++) {
    SV *sv;
    sv = get_sv((char*) swig_variables[i].name, TRUE | 0x2 | GV_ADDMULTI);
    if (swig_variables[i].type) {
      SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
    } else {
      sv_setiv(sv,(IV) 0);
    }
    swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
  }
  
  /* Install constant */
  for (i = 0; swig_constants[i].type; i++) {
    SV *sv;
    sv = get_sv((char*)swig_constants[i].name, TRUE | 0x2 | GV_ADDMULTI);
    switch(swig_constants[i].type) {
    case SWIG_INT:
      sv_setiv(sv, (IV) swig_constants[i].lvalue);
      break;
    case SWIG_FLOAT:
      sv_setnv(sv, (double) swig_constants[i].dvalue);
      break;
    case SWIG_STRING:
      sv_setpv(sv, (char *) swig_constants[i].pvalue);
      break;
    case SWIG_POINTER:
      SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
      break;
    case SWIG_BINARY:
      SWIG_MakePackedObj(sv, swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype));
      break;
    default:
      break;
    }
    SvREADONLY_on(sv);
  }
  
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SWIG_SVN_INVALID_REVNUM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(-1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SWIG_SVN_IGNORED_REVNUM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_long  SWIG_PERL_CALL_ARGS_1((long)(-1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CATEGORY_SIZE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(5000)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_WARNING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_WARNING)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_CONTAINING_POOL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_CONTAINING_POOL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_FILENAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_FILENAME)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_URL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_URL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_DATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_MIME_TYPE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_MIME_TYPE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_PROPERTY_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_PROPERTY_VALUE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_VERSION_FILE_FORMAT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_VERSION_FILE_FORMAT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_RELATIVE_PATH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_RELATIVE_PATH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_UUID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_UUID)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_CONFIG_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_CONFIG_VALUE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_SERVER_SPECIFICATION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_SERVER_SPECIFICATION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_CHECKSUM_KIND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_CHECKSUM_KIND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_CHECKSUM_PARSE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_CHECKSUM_PARSE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_TOKEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_CHANGELIST_NAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_CHANGELIST_NAME)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_XML_ATTRIB_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_XML_ATTRIB_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_XML_MISSING_ANCESTRY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_XML_MISSING_ANCESTRY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_XML_UNKNOWN_ENCODING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_XML_UNKNOWN_ENCODING)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_XML_MALFORMED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_XML_MALFORMED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_XML_UNESCAPABLE_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_XML_UNESCAPABLE_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_INCONSISTENT_EOL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_INCONSISTENT_EOL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_UNKNOWN_EOL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_UNKNOWN_EOL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_CORRUPT_EOL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_CORRUPT_EOL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_PIPE_FRAME_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_PIPE_FRAME_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_PIPE_READ_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_PIPE_READ_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_WRITE_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_WRITE_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_IO_PIPE_WRITE_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_IO_PIPE_WRITE_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_STREAM_UNEXPECTED_EOF", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_STREAM_UNEXPECTED_EOF)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_STREAM_MALFORMED_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_STREAM_MALFORMED_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_STREAM_UNRECOGNIZED_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_STREAM_UNRECOGNIZED_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_STREAM_SEEK_NOT_SUPPORTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_STREAM_SEEK_NOT_SUPPORTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_NODE_UNKNOWN_KIND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_NODE_UNKNOWN_KIND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_NODE_UNEXPECTED_KIND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_NODE_UNEXPECTED_KIND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_EXISTS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_EXISTS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_MISSING_REVISION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_MISSING_REVISION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_MISSING_URL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_MISSING_URL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_ATTRIBUTE_INVALID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_ATTRIBUTE_INVALID)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ENTRY_FORBIDDEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ENTRY_FORBIDDEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_OBSTRUCTED_UPDATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_OBSTRUCTED_UPDATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_UNWIND_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_UNWIND_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_UNWIND_EMPTY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_UNWIND_EMPTY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_UNWIND_NOT_EMPTY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_UNWIND_NOT_EMPTY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_LOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_LOCK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_WORKING_COPY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_WORKING_COPY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_DIRECTORY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_DIRECTORY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_FILE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_BAD_ADM_LOG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_BAD_ADM_LOG)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_PATH_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_PATH_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_UP_TO_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_UP_TO_DATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_LEFT_LOCAL_MOD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_LEFT_LOCAL_MOD)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_SCHEDULE_CONFLICT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_SCHEDULE_CONFLICT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_PATH_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_PATH_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_FOUND_CONFLICT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_FOUND_CONFLICT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CORRUPT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CORRUPT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CORRUPT_TEXT_BASE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CORRUPT_TEXT_BASE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NODE_KIND_CHANGE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NODE_KIND_CHANGE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_OP_ON_CWD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_OP_ON_CWD)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_BAD_ADM_LOG_START", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_BAD_ADM_LOG_START)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_UNSUPPORTED_FORMAT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_UNSUPPORTED_FORMAT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_BAD_PATH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_BAD_PATH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_SCHEDULE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_SCHEDULE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_RELOCATION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_RELOCATION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_SWITCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_SWITCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_MISMATCHED_CHANGELIST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_MISMATCHED_CHANGELIST)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CHANGELIST_MOVE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CHANGELIST_MOVE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_DB_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_DB_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_MISSING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_MISSING)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_NOT_SYMLINK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_NOT_SYMLINK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_PATH_UNEXPECTED_STATUS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_PATH_UNEXPECTED_STATUS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_UPGRADE_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_UPGRADE_REQUIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_CLEANUP_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_CLEANUP_REQUIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_INVALID_OPERATION_DEPTH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_INVALID_OPERATION_DEPTH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_WC_PATH_ACCESS_DENIED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_WC_PATH_ACCESS_DENIED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_GENERAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_GENERAL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_CLEANUP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_CLEANUP)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_ALREADY_OPEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_ALREADY_OPEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_OPEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_OPEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_CORRUPT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_CORRUPT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_PATH_SYNTAX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_PATH_SYNTAX)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_REVISION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_REVISION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_TRANSACTION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_TRANSACTION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_ENTRY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_ENTRY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_REPRESENTATION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_REPRESENTATION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_STRING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_STRING)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_COPY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_COPY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_TRANSACTION_NOT_MUTABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_TRANSACTION_NOT_MUTABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_ID_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_ID_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_ID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_ID)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_DIRECTORY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_DIRECTORY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_FILE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_MUTABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_MUTABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_ALREADY_EXISTS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_ALREADY_EXISTS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_ROOT_DIR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_ROOT_DIR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_TXN_ROOT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_TXN_ROOT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NOT_REVISION_ROOT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NOT_REVISION_ROOT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_CONFLICT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_CONFLICT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_REP_CHANGED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_REP_CHANGED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_REP_NOT_MUTABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_REP_NOT_MUTABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_MALFORMED_SKEL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_MALFORMED_SKEL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_TXN_OUT_OF_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_TXN_OUT_OF_DATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_BERKELEY_DB", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_BERKELEY_DB)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_BERKELEY_DB_DEADLOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_BERKELEY_DB_DEADLOCK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_TRANSACTION_DEAD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_TRANSACTION_DEAD)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_TRANSACTION_NOT_DEAD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_TRANSACTION_NOT_DEAD)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_UNKNOWN_FS_TYPE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_UNKNOWN_FS_TYPE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_USER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_USER)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_PATH_ALREADY_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_PATH_ALREADY_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_PATH_NOT_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_PATH_NOT_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_BAD_LOCK_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_BAD_LOCK_TOKEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_LOCK_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_LOCK_TOKEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_LOCK_OWNER_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_LOCK_OWNER_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_LOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_LOCK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_LOCK_EXPIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_LOCK_EXPIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_OUT_OF_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_OUT_OF_DATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_UNSUPPORTED_FORMAT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_UNSUPPORTED_FORMAT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_REP_BEING_WRITTEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_REP_BEING_WRITTEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_TXN_NAME_TOO_LONG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_TXN_NAME_TOO_LONG)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_NODE_ORIGIN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_NODE_ORIGIN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_UNSUPPORTED_UPGRADE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_UNSUPPORTED_UPGRADE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_NO_SUCH_CHECKSUM_REP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_NO_SUCH_CHECKSUM_REP)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_FS_PROP_BASEVALUE_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_FS_PROP_BASEVALUE_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_HOOK_FAILURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_HOOK_FAILURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_BAD_ARGS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_BAD_ARGS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_NO_DATA_FOR_REPORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_NO_DATA_FOR_REPORT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_BAD_REVISION_REPORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_BAD_REVISION_REPORT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_UNSUPPORTED_VERSION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_UNSUPPORTED_VERSION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_DISABLED_FEATURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_DISABLED_FEATURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REPOS_UNSUPPORTED_UPGRADE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REPOS_UNSUPPORTED_UPGRADE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_ILLEGAL_URL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_ILLEGAL_URL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_NOT_AUTHORIZED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_NOT_AUTHORIZED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_UNKNOWN_AUTH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_UNKNOWN_AUTH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_NOT_IMPLEMENTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_NOT_IMPLEMENTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_OUT_OF_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_OUT_OF_DATE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_NO_REPOS_UUID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_NO_REPOS_UUID)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_UNSUPPORTED_ABI_VERSION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_UNSUPPORTED_ABI_VERSION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_NOT_LOCKED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_NOT_LOCKED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_UUID_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_UUID_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SESSION_URL_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SESSION_URL_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_SOCK_INIT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_SOCK_INIT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_CREATING_REQUEST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_CREATING_REQUEST)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_REQUEST_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_REQUEST_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_PROPS_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_PROPS_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_ALREADY_EXISTS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_ALREADY_EXISTS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_PATH_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_PATH_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_PROPPATCH_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_PROPPATCH_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_MALFORMED_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_MALFORMED_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_RELOCATED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_RELOCATED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_CONN_TIMEOUT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_CONN_TIMEOUT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_DAV_FORBIDDEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_DAV_FORBIDDEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_CMD_ERR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_CMD_ERR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_UNKNOWN_CMD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_UNKNOWN_CMD)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_CONNECTION_CLOSED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_CONNECTION_CLOSED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_IO_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_IO_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_MALFORMED_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_MALFORMED_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_REPOS_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_REPOS_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_BAD_VERSION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_BAD_VERSION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_NO_MECHANISMS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_NO_MECHANISMS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SVN_EDIT_ABORTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SVN_EDIT_ABORTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RA_SERF_WRAPPED_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RA_SERF_WRAPPED_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHN_CREDS_UNAVAILABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHN_CREDS_UNAVAILABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHN_NO_PROVIDER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHN_NO_PROVIDER)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHN_CREDS_NOT_SAVED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHN_CREDS_NOT_SAVED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHN_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHN_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHZ_ROOT_UNREADABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHZ_ROOT_UNREADABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHZ_UNREADABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHZ_UNREADABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHZ_PARTIALLY_READABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHZ_PARTIALLY_READABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHZ_INVALID_CONFIG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHZ_INVALID_CONFIG)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_AUTHZ_UNWRITABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_AUTHZ_UNWRITABLE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_INVALID_HEADER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_INVALID_HEADER)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_CORRUPT_WINDOW", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_CORRUPT_WINDOW)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_BACKWARD_VIEW", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_BACKWARD_VIEW)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_INVALID_OPS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_INVALID_OPS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_UNEXPECTED_END", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_UNEXPECTED_END)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_DIFF_DATASOURCE_MODIFIED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_DIFF_DATASOURCE_MODIFIED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_APMOD_MISSING_PATH_TO_FS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_APMOD_MISSING_PATH_TO_FS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_APMOD_MALFORMED_URI", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_APMOD_MALFORMED_URI)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_APMOD_ACTIVITY_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_APMOD_ACTIVITY_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_APMOD_BAD_BASELINE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_APMOD_BAD_BASELINE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_APMOD_CONNECTION_ABORTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_APMOD_CONNECTION_ABORTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_RA_ACCESS_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_RA_ACCESS_REQUIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_BAD_REVISION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_BAD_REVISION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_IS_BINARY_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_IS_BINARY_FILE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_MODIFIED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_MODIFIED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_IS_DIRECTORY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_IS_DIRECTORY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_REVISION_RANGE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_REVISION_RANGE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_INVALID_RELOCATION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_INVALID_RELOCATION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_PROPERTY_NAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_PROPERTY_NAME)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_UNRELATED_RESOURCES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_UNRELATED_RESOURCES)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_MISSING_LOCK_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_MISSING_LOCK_TOKEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_NO_VERSIONED_PARENT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_NO_VERSIONED_PARENT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_NOT_READY_TO_MERGE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_NOT_READY_TO_MERGE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_CYCLE_DETECTED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_CYCLE_DETECTED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_NO_LOCK_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_NO_LOCK_TOKEN)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BASE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BASE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_PLUGIN_LOAD_FAILURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_PLUGIN_LOAD_FAILURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_MALFORMED_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_MALFORMED_FILE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_INCOMPLETE_DATA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_INCOMPLETE_DATA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_INCORRECT_PARAMS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_INCORRECT_PARAMS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_UNVERSIONED_RESOURCE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_UNVERSIONED_RESOURCE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_TEST_FAILED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_TEST_FAILED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_UNSUPPORTED_FEATURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_UNSUPPORTED_FEATURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_BAD_PROP_KIND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_BAD_PROP_KIND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ILLEGAL_TARGET", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ILLEGAL_TARGET)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_DIR_NOT_EMPTY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_DIR_NOT_EMPTY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_EXTERNAL_PROGRAM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_EXTERNAL_PROGRAM)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SWIG_PY_EXCEPTION_SET", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SWIG_PY_EXCEPTION_SET)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CHECKSUM_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CHECKSUM_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CANCELLED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CANCELLED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_INVALID_DIFF_OPTION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_INVALID_DIFF_OPTION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_PROPERTY_NOT_FOUND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_PROPERTY_NOT_FOUND)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_NO_AUTH_FILE_PATH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_NO_AUTH_FILE_PATH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_VERSION_MISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_VERSION_MISMATCH)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_MERGEINFO_PARSE_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_MERGEINFO_PARSE_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CEASE_INVOCATION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CEASE_INVOCATION)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_REVNUM_PARSE_FAILURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_REVNUM_PARSE_FAILURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ITER_BREAK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ITER_BREAK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_UNKNOWN_CHANGELIST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_UNKNOWN_CHANGELIST)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_RESERVED_FILENAME_SPECIFIED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_RESERVED_FILENAME_SPECIFIED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_UNKNOWN_CAPABILITY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_UNKNOWN_CAPABILITY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_TEST_SKIPPED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_TEST_SKIPPED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_NO_APR_MEMCACHE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_NO_APR_MEMCACHE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ATOMIC_INIT_FAILURE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ATOMIC_INIT_FAILURE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_READONLY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_READONLY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_BUSY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_BUSY)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_SQLITE_CONSTRAINT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_SQLITE_CONSTRAINT)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_ARG_PARSING_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_ARG_PARSING_ERROR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_INSUFFICIENT_ARGS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_INSUFFICIENT_ARGS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_ADM_DIR_RESERVED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_ADM_DIR_RESERVED)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_COMMIT_IN_ADDED_DIR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_COMMIT_IN_ADDED_DIR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_NO_EXTERNAL_EDITOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_NO_EXTERNAL_EDITOR)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_BAD_LOG_MESSAGE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_BAD_LOG_MESSAGE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ASSERTION_FAIL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ASSERTION_FAIL)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_ASSERTION_ONLY_TRACING_LINKS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_ASSERTION_ONLY_TRACING_LINKS)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ERR_LAST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(SVN_ERR_LAST)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_UNALIGNED_ACCESS_IS_OK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_node_none", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_node_none)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_node_file", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_node_file)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_node_dir", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_node_dir)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_node_unknown", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_node_unknown)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_tristate_false", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_tristate_false)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_tristate_true", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_tristate_true)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_tristate_unknown", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_tristate_unknown)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_REVNUM_T_FMT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ld"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "TRUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "FALSE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_nonrecursive", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_nonrecursive)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_recursive", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_recursive)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_unknown", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_unknown)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_exclude", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_exclude)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_empty", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_empty)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_files", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_files)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_immediates", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_immediates)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_depth_infinity", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_depth_infinity)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_KIND", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00001)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_SIZE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00002)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_HAS_PROPS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00004)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_CREATED_REV", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00008)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_TIME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00010)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_DIRENT_LAST_AUTHOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00020)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_MAX_LEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(255)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_REVISION_LONG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("LastChangedRevision"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_REVISION_SHORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Rev"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_REVISION_MEDIUM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Revision"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_DATE_LONG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("LastChangedDate"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_DATE_SHORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Date"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_AUTHOR_LONG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("LastChangedBy"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_AUTHOR_SHORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Author"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_URL_LONG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("HeadURL"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_URL_SHORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("URL"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_ID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Id"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_KEYWORD_HEADER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("Header"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_STREAM_CHUNK_SIZE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(102400)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN__STREAM_CHUNK_SIZE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(16384)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_ALLOCATOR_RECOMMENDED_MAX_FREE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)((4096*1024))));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_MAJOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_MINOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(7)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_PATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(13)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_MICRO", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(13)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_LIBRARY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_TAG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr(" (r1516569)"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_NUMTAG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr(""));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_REVISION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1516569)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_NUM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("1.7.13"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VER_NUMBER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("1.7.13"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_VERSION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("1.7.13 (r1516569)"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_prop_entry_kind", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_prop_entry_kind)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_prop_wc_kind", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_prop_wc_kind)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_prop_regular_kind", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_prop_regular_kind)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_BOOLEAN_TRUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_MIME_TYPE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:mime-type"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_IGNORE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:ignore"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_EOL_STYLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:eol-style"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_KEYWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:keywords"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_EXECUTABLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:executable"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_EXECUTABLE_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_NEEDS_LOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:needs-lock"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_NEEDS_LOCK_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_SPECIAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:special"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_SPECIAL_VALUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_EXTERNALS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:externals"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_MERGEINFO", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:mergeinfo"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_TEXT_TIME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:text-time"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_OWNER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:owner"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_GROUP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:group"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_UNIX_MODE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:unix-mode"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_WC_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:wc:"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_COMMITTED_REV", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:committed-rev"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_COMMITTED_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:committed-date"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_LAST_AUTHOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:last-author"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_UUID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:uuid"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_ENTRY_LOCK_TOKEN", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:entry:lock-token"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_CUSTOM_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:custom:"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_REVISION_AUTHOR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:author"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_REVISION_LOG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:log"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_REVISION_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:date"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_REVISION_ORIG_DATE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:original-date"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_PROP_REVISION_AUTOVERSIONED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:autoversioned"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_LOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-lock"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_FROM_URL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-from-url"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_FROM_UUID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-from-uuid"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_LAST_MERGED_REV", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-last-merged-rev"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVNSYNC_PROP_CURRENTLY_COPYING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:sync-currently-copying"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_OPT_MAX_ALIASES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(3)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_OPT_MAX_OPTIONS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(50)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_OPT_FIRST_LONGOPT_ID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(256)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_unspecified", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_unspecified)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_number", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_number)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_date", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_date)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_committed", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_committed)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_previous", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_previous)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_base", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_base)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_working", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_working)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_opt_revision_head", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_opt_revision_head)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_CRED_SIMPLE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn.simple"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_CRED_USERNAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn.username"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_CRED_SSL_CLIENT_CERT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn.ssl.client-cert"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_CRED_SSL_CLIENT_CERT_PW", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn.ssl.client-passphrase"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_CRED_SSL_SERVER_TRUST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn.ssl.server"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_SSL_NOTYETVALID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00000001)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_SSL_EXPIRED", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00000002)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_SSL_CNMISMATCH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00000004)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_SSL_UNKNOWNCA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x00000008)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_SSL_OTHER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0x40000000)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_PREFIX", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_DEFAULT_USERNAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:username"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_DEFAULT_PASSWORD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:password"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_NON_INTERACTIVE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:non-interactive"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_DONT_STORE_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:dont-store-passwords"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_STORE_PLAINTEXT_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:store-plaintext-passwords"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_DONT_STORE_SSL_CLIENT_CERT_PP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:dont-store-ssl-client-cert-pp"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:store-ssl-client-cert-pp-plaintext"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_NO_AUTH_CACHE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:no-auth-cache"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_SSL_SERVER_FAILURES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:ssl:failures"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:ssl:cert-info"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:config-category-config"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:config-category-servers"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_CONFIG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:config-category-servers"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_SERVER_GROUP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:server-group"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_CONFIG_DIR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:auth:config-dir"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("gnome-keyring-unlock-prompt-func"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_BATON", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("gnome-keyring-unlock-prompt-baton"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_CATEGORY_SERVERS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("servers"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_GROUPS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("groups"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_GLOBAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("global"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_PROXY_HOST", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-proxy-host"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_PROXY_PORT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-proxy-port"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-proxy-username"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-proxy-password"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-proxy-exceptions"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_TIMEOUT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-timeout"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_COMPRESSION", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-compression"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_NEON_DEBUG_MASK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("neon-debug-mask"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_AUTH_TYPES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-auth-types"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ssl-authority-files"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ssl-trust-default-ca"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ssl-client-cert-file"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_SSL_CLIENT_CERT_PASSWORD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ssl-client-cert-password"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_SSL_PKCS11_PROVIDER", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ssl-pkcs11-provider"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_HTTP_LIBRARY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("http-library"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_STORE_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("store-passwords"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_STORE_PLAINTEXT_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("store-plaintext-passwords"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_STORE_AUTH_CREDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("store-auth-creds"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("store-ssl-client-cert-pp"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("store-ssl-client-cert-pp-plaintext"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_USERNAME", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("username"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_CATEGORY_CONFIG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("config"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_AUTH", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("auth"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_PASSWORD_STORES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("password-stores"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_KWALLET_WALLET", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("kwallet-wallet"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_KWALLET_SVN_APPLICATION_NAME_WITH_PID", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("kwallet-svn-application-name-with-pid"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_HELPERS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("helpers"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_EDITOR_CMD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("editor-cmd"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_DIFF_CMD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("diff-cmd"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_DIFF_EXTENSIONS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("diff-extensions"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_DIFF3_CMD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("diff3-cmd"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("diff3-has-program-arg"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_MERGE_TOOL_CMD", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("merge-tool-cmd"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_MISCELLANY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("miscellany"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_GLOBAL_IGNORES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("global-ignores"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_LOG_ENCODING", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("log-encoding"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_USE_COMMIT_TIMES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("use-commit-times"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_TEMPLATE_ROOT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("template-root"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("enable-auto-props"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_NO_UNLOCK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("no-unlock"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_MIMETYPES_FILE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("mime-types-file"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_PRESERVED_CF_EXTS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("preserved-conflict-file-exts"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("interactive-conflicts"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("memory-cache-size"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_TUNNELS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("tunnels"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_AUTO_PROPS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("auto-props"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_GENERAL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("general"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_ANON_ACCESS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("anon-access"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_AUTH_ACCESS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("auth-access"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_PASSWORD_DB", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("password-db"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_REALM", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("realm"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_AUTHZ_DB", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("authz-db"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_FORCE_USERNAME_CASE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("force-username-case"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_SASL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("sasl"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_USE_SASL", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("use-sasl"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_MIN_SSF", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("min-encryption"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_OPTION_MAX_SSF", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("max-encryption"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_SECTION_USERS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("users"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_1", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_2", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*.rej *~ #*# .#* .*.swp .DS_Store"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_GLOBAL_IGNORES", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo *.rej *~ #*# .#* .*.swp .DS_Store"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_TRUE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("TRUE"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_FALSE", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("FALSE"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_ASK", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ASK"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_OPTION_STORE_PLAINTEXT_PASSWORDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ASK"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(1)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("ASK"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_CONFIG_REALMSTRING_KEY", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("svn:realmstring"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_MERGEINFO_NONINHERITABLE_STR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_FromCharPtr("*"));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_mergeinfo_explicit", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_mergeinfo_explicit)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_mergeinfo_inherited", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_mergeinfo_inherited)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_mergeinfo_nearest_ancestor", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_mergeinfo_nearest_ancestor)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_io_file_del_none", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_io_file_del_none)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_io_file_del_on_close", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_io_file_del_on_close)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_io_file_del_on_pool_cleanup", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_io_file_del_on_pool_cleanup)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_datasource_original", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_datasource_original)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_datasource_modified", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_datasource_modified)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_datasource_latest", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_datasource_latest)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_datasource_ancestor", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_datasource_ancestor)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_modified_latest", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_modified_latest)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_resolved_modified_latest", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_resolved_modified_latest)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_modified_original_latest", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_modified_original_latest)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_modified", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_modified)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_latest", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_latest)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_conflict_display_only_conflicts", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_conflict_display_only_conflicts)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_file_ignore_space_none", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_file_ignore_space_none)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_file_ignore_space_change", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_file_ignore_space_change)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_file_ignore_space_all", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_file_ignore_space_all)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_unchanged", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_unchanged)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_added", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_added)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_deleted", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_deleted)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_copied", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_copied)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_moved", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_moved)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "svn_diff_op_modified", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(svn_diff_op_modified)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  /*@SWIG:/home/breser/wandisco/svnrm-1.7.13/prefix/share/swig/2.0.4/perl5/perltypemaps.swg,65,%set_constant@*/ do {
    SV *sv = get_sv((char*) SWIG_prefix "SVN_NO_ERROR", TRUE | 0x2 | GV_ADDMULTI);
    sv_setsv(sv, SWIG_From_int  SWIG_PERL_CALL_ARGS_1((int)(0)));
    SvREADONLY_on(sv);
  } while(0) /*@SWIG@*/;
  
#if defined(SVN_AVOID_CIRCULAR_LINKAGE_AT_ALL_COSTS_HACK)
  svn_swig_pl_bind_current_pool_fns (&svn_swig_pl_get_current_pool,
    &svn_swig_pl_set_current_pool);
#endif
  
  ST(0) = &PL_sv_yes;
  XSRETURN(1);
}

