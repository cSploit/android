/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;

import android.content.Context;
import android.content.Intent;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;
import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Vulnerability;
import it.evilsocket.dsploit.net.Target.Exploit;

public class ExploitFinder extends Plugin
{
  private final static String  TAG = "EXPLOITFINDER";

  private ToggleButton       mSearchToggleButton = null,
    mExploitAllToggleButton = null;
  private ProgressBar	       mSearchProgress     = null;
  private ListView 		   mListView		   = null;
  private boolean	           mRunning			   = false;
  private Thread			   mThread			   = null;
  private ArrayList<Exploit> results = new ArrayList<Exploit>();
  private ExploitAdapter mAdapter = null;

  public class ExploitAdapter extends ArrayAdapter<Exploit>
  {
    class ExploitHolder
    {
      ImageView  itemImage;
      TextView   itemTitle;
      TextView   itemDescription;
    }

    public ExploitAdapter(  ) {
      super( ExploitFinder.this, R.layout.plugin_exploit_finder_item  );
    }

    @Override
    public int getCount(){
      return System.getCurrentExploits().size();
    }

    @Override
    public View getView( int position, View convertView, ViewGroup parent ) {
      View 		 row    = convertView;
      ExploitHolder holder = null;

      if( row == null )
      {
        LayoutInflater inflater = ( LayoutInflater )ExploitFinder.this.getSystemService( Context.LAYOUT_INFLATER_SERVICE );
        row = inflater.inflate( R.layout.plugin_exploit_finder_item , parent, false );

        holder = new ExploitHolder();

        holder.itemImage  	   = ( ImageView )row.findViewById( R.id.itemIcon );
        holder.itemTitle  	   = ( TextView )row.findViewById( R.id.itemTitle );
        holder.itemDescription = ( TextView )row.findViewById( R.id.itemDescription );

        row.setTag(holder);
      }
      else
      {
        holder = ( ExploitHolder )row.getTag();
      }

      Exploit exploit = System.getCurrentExploits().get(position);

      if( exploit.msf_name != null)
      {
        holder.itemTitle.setText
                           (
                             Html.fromHtml
                                    (
                                      "<b>" + exploit.msf_name + "</b>"
                                    )
                           );
      }
      else
        holder.itemTitle.setText( exploit.name );

      holder.itemTitle.setTypeface( null, Typeface.NORMAL );
      holder.itemImage.setImageResource( exploit.getDrawableResourceId() );
      holder.itemDescription.setText( exploit.getDescription() );

      return row;
    }
  }


  public ExploitFinder() {
    super
    (

      R.string.exploit_finder,
      R.string.exploit_finder_desc,

      new Target.Type[]{ Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_exploit_finder,
      R.drawable.action_exploit_finder
    );
  }

  private void setStartedState( ) {
    mSearchProgress.setVisibility( View.VISIBLE );
    mRunning = true;

    mThread = new Thread( new Runnable()
    {
      @Override
      public void run()
      {
        boolean msf_only = System.getSettings().getBoolean("SEARCH_MSF_ONLY", false);
        boolean found_something = false;

        for ( final Vulnerability vuln : System.getCurrentTarget().getVulnerabilities())
        {
          if( !mRunning ) return;
          Exploit ex = null;

          results.clear();

          if(vuln.osvdb_id!=0)
          {
            if(vuln.has_msf_exploit)
              ex = MSFDatabase.search_by_osvdb(vuln.osvdb_id);
            if(ex!=null)
              results.add(ex);
            else if(!msf_only)
              results.addAll(EXDatabase.search_by_osvdb(vuln.osvdb_id));
          }
          if(vuln.cve_id!=null)
          {
            // substring remove "CVE-"
            ex = MSFDatabase.search_by_cve(vuln.cve_id.substring(4));
            if(ex != null)
              results.add(ex);
            else if(!msf_only)
              results.addAll(EXDatabase.search_by_cveid(vuln.cve_id.substring(4)));
          }
          if(!found_something && !results.isEmpty())
            found_something = true;
          for(final Exploit exp : results)
          {
            System.addExploit(vuln, exp);

            ExploitFinder.this.runOnUiThread( new Runnable() {
              @Override
              public void run()
              {
                mAdapter.add(exp);
              }
            });
          }
        }
        if( !found_something )
        {

          ExploitFinder.this.runOnUiThread( new Runnable() {
            @Override
            public void run()
            {
              new FinishDialog( "Warning", "No exploits found.", ExploitFinder.this ).show();
            }
          });
        }
        ExploitFinder.this.runOnUiThread( new Runnable() {
          @Override
          public void run()
          {
            setStoppedState();
          }
        });
      }
    });

    mThread.start();
  }

  private void setStoppedState( ) {
    try
    {
      if( mThread != null )
      {
        mThread.interrupt();
        mThread.stop();
      }
    }
    catch( Exception e )
    {

    }

    mRunning = false;
    mSearchToggleButton.setChecked( false );
    mSearchProgress.setVisibility( View.GONE );
  }

  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    if( System.getCurrentTarget().hasOpenPorts() == false )
      new FinishDialog( "Warning", "No open ports detected on current target, run the service inspector first.", this ).show();

    else if( System.getCurrentTarget().hasOpenPortsWithService() == false )
      new FinishDialog( "Warning", "No specific informations about services running on target machine, run the service inspector first.", this ).show();

    else if( System.getCurrentTarget().hasVulnerabilities() == false)
      new FinishDialog( "Warning", "No vulnerabilities found about this target. run the Vulnerability Finder first.", this ).show();
    mSearchToggleButton = ( ToggleButton )findViewById( R.id.searchToggleButton );
    mExploitAllToggleButton = (ToggleButton)findViewById(R.id.exploitToggleButton);
    mSearchProgress	   = ( ProgressBar )findViewById( R.id.searchActivity );
    mListView		   = ( ListView )findViewById( android.R.id.list );
    mAdapter		   = new ExploitAdapter();


    mListView.setAdapter( mAdapter );


    mListView.setOnItemClickListener( new OnItemClickListener(){
      public void onItemClick( AdapterView<?> parent, View v, int position, long id ) {
        //TODO: edit exploit options
        Exploit exp = ( Exploit )mAdapter.getItem(position);

        if(exp!=null && exp.url != null && !exp.url.isEmpty())
          startActivity(new Intent( Intent.ACTION_VIEW, Uri.parse(exp.url)));
      }}
    );

    mSearchToggleButton.setOnClickListener( new OnClickListener(){
      @Override
      public void onClick(View ex) {
        if( mRunning )
        {
          setStoppedState();
        }
        else
        {
          setStartedState();
        }
      }}
    );

    mExploitAllToggleButton.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View ex) {
        for(Exploit exp : System.getCurrentExploits())
        {
          if(exp.started)
            continue;
          //TODO: start exploit though msfrpc
          exp.started =  true;
        }
      }
    });
  }

  @Override
  public void onBackPressed() {
    setStoppedState();
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
  }
}