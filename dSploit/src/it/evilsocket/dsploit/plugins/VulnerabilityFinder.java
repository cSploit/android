/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import android.content.Context;
import android.content.Intent;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.SettingsActivity;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Databases.NationalVulnerability;
import it.evilsocket.dsploit.net.Databases.OpenSourcedVulnerability;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Port;
import it.evilsocket.dsploit.net.Target.Vulnerability;

public class VulnerabilityFinder extends Plugin
{
  private final static String  TAG = "VULNERABILITYFINDER";
  private final static int SEARCH_OSV = 1;
  private final static int SEARCH_CVE = 2;

  private ToggleButton       mSearchToggleButton = null;
  private ProgressBar	       mSearchProgress     = null;
  private ExpandableListView mListView		   = null;
  private ListViewAdapter	   mAdapter			   = null;
  private Thread			   mThread			   = null;
  private Thread[]		   mPool			   = null;
  private boolean             mVersionMatching = true;

  private static Comparator<Vulnerability> sort_by_score = new Comparator<Vulnerability>() {
    @Override
    public int compare(Vulnerability o1, Vulnerability o2) {
      if( o1.severity > o2.severity )
        return -1;

      else if( o1.severity < o2.severity )
        return 1;

      else
        return 0;
    }
  };

  public class ListViewAdapter extends BaseExpandableListAdapter
  {
    private HashMap< String, ArrayList<Vulnerability> > mGroups  = null;
    private Context							 		    mContext = null;

    public ListViewAdapter( Context context ) {
      mGroups  = new HashMap< String, ArrayList<Vulnerability> >();
      mContext = context;
    }

    public void clear(){
      Object[] keys = mGroups.keySet().toArray();

      for( Object key : keys )
      {
        mGroups.get(key).clear();
      }

      notifyDataSetChanged();
    }

    public boolean hasGroup( String name ) {
      return mGroups.containsKey(name);
    }

    public void addGroup( String name ) {
      mGroups.put( name, new ArrayList<Vulnerability>() );
      notifyDataSetChanged();
    }

    public void addChild( String group, Vulnerability child ) {
      if( !hasGroup( group ) )
        addGroup( group );

      mGroups.get( group ).add( child );
      Collections.sort(mGroups.get( group ), sort_by_score);

      notifyDataSetChanged();
    }

    private ArrayList<Vulnerability> getGroupAt( int position ){
      return mGroups.get( mGroups.keySet().toArray()[ position ] );
    }

    @Override
    public Object getChild( int groupPosition, int childPosition ) {
      return getGroupAt( groupPosition ).get( childPosition );
    }

    @Override
    public long getChildId( int groupPosition, int childPosition ) {
      return ( groupPosition * 10 ) + childPosition;
    }

    @Override
    public int getChildrenCount( int groupPosition ) {
      return getGroupAt( groupPosition ).size();
    }

    @Override
    public Object getGroup( int groupPosition ) {
      return mGroups.keySet().toArray()[ groupPosition ];
    }

    @Override
    public int getGroupCount() {
      return mGroups.size();
    }

    @Override
    public long getGroupId(int groupPosition) {
      return groupPosition;
    }

    @Override
    public View getGroupView( int groupPosition, boolean isExpanded, View convertView, ViewGroup parent ) {
      TextView row = (TextView)convertView;
      if( row == null )
        row = new TextView( mContext);

      row.setText( getGroup( groupPosition ).toString() );
      row.setTextSize( 15 );
      row.setTypeface( Typeface.DEFAULT_BOLD );
      row.setPadding( 50, 0, 0, 0 );

      return row;
    }

    @Override
    public View getChildView( int groupPosition, int childPosition, boolean isLastChild, View convertView, ViewGroup parent ) {
      TextView row = (TextView)convertView;
      if( row == null )
        row = new TextView( mContext );

      Vulnerability cve = (Vulnerability)getChild( groupPosition, childPosition );

      if( cve == null )
        row.setText( Html.fromHtml( getString(R.string.nothing_found) ) );
      else
        row.setText
        (
          Html.fromHtml
          (
            "<font color=\"" + cve.getHtmlColor() + "\"><b>" + cve.getIdentifier() + "</b></font> : <small>" + cve.summary + "</small>"
          )
        );

      row.setPadding( 30, 0, 0, 0 );

      return row;
    }

    @Override
    public boolean hasStableIds() {
      return true;
    }

    @Override
    public boolean isChildSelectable(int groupPosition, int childPosition) {
      return true;
    }
  }

  public VulnerabilityFinder() {
    super
    (
      R.string.vulnerability_finder,
      R.string.vulnerability_finder_desc,

      new Target.Type[]{ Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_vulerability_finder,
      R.drawable.action_exploit
    );
  }

  private int getSeachMask() {
    String  pref = System.getSettings().getString("SEARCH_OSVDB","BOTH");
    if(pref.equals("OSVDB"))
      return SEARCH_OSV;
    else if(pref.equals("CVE"))
      return SEARCH_CVE;
    else
      return SEARCH_OSV|SEARCH_CVE;
  }

  private void setStartedState( ) {
    mSearchProgress.setVisibility( View.VISIBLE );
    int i;
    ArrayList<String> searched = new ArrayList<String>();

    mAdapter.clear();
    for(Port p : System.getCurrentTarget().getOpenPorts())
      for(Vulnerability vuln : p.getVulnerabilities())
              mAdapter.addChild(p.service,vuln);

    final int search_mask = getSeachMask();


    mPool = new Thread[System.getCurrentTarget().getOpenPorts().size()];

    i=0;
    for( final Port port : System.getCurrentTarget().getOpenPorts() )
    {
      if( port.service != null && port.service.isEmpty() == false )
      {

        final String query = (mVersionMatching ? port.getServiceQueryWithVersion() : port.getServiceQuery());
        if(searched.contains(query))
          continue;
        searched.add(query);

        mPool[i] = new Thread( new Runnable() {

          @Override
          public void run() {
            try {
              ArrayList<Vulnerability> local_results = new ArrayList<Vulnerability>();
              if((search_mask & SEARCH_OSV) != 0)
                local_results.addAll(OpenSourcedVulnerability.search(query));
              if((search_mask & SEARCH_CVE) != 0)
                local_results.addAll(NationalVulnerability.search(query));
              if(local_results.isEmpty())
                return;
              final ArrayList<Vulnerability> UI_food = local_results;
              for( Vulnerability vuln : local_results )
                System.addVulnerability( port, vuln );

              VulnerabilityFinder.this.runOnUiThread( new Runnable() {
                @Override
                public void run()
                {
                  for(Vulnerability vuln : UI_food)
                    mAdapter.addChild( port.service, vuln );
                  mAdapter.notifyDataSetChanged();
                }
              });
            } catch (InterruptedException e) {
              Logger.info("interrupted");
              // quit!
            }
          }
        });
        mPool[i++].start();
      }
    }
    final int j = i; // integer bridge
    mThread = new Thread( new Runnable() {

      @Override
      public void run() {
        int i = j;
        try
        {
          for(i--;i>=0;i--)
            mPool[i].join();
        }
        catch ( InterruptedException ie)
        {
          for(;i>=0;i--)
            mPool[i].interrupt();
        }
        mPool = null;
        VulnerabilityFinder.this.runOnUiThread( new Runnable() {
          @Override
          public void run()
          {
            mSearchToggleButton.setChecked( false );
            mSearchProgress.setVisibility( View.GONE );
          }
        });
      }
    });
    mThread.start();
  }

  private void setStoppedState( ) {
    try
    {
      if( mThread != null )
      {
        mThread.interrupt();
        mThread.join();
      }
    }
    catch( Exception e )
    {

    }

    VulnerabilityFinder.this.runOnUiThread( new Runnable() {
      @Override
      public void run()
      {
        mSearchToggleButton.setChecked( false );
        mSearchProgress.setVisibility( View.GONE );
      }
    });
  }

  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    if( System.getCurrentTarget().hasOpenPorts() == false )
      new FinishDialog( getString(R.string.warning), getString(R.string.no_open_ports), this ).show();

    else if( System.getCurrentTarget().hasOpenPortsWithService() == false )
      new FinishDialog( getString(R.string.warning), getString(R.string.no_infos_on_target), this ).show();

    mSearchToggleButton = ( ToggleButton )findViewById( R.id.searchToggleButton );
    mSearchProgress	   = ( ProgressBar )findViewById( R.id.searchActivity );
    mListView		   = ( ExpandableListView )findViewById( R.id.searchListView );
    mAdapter		   = new ListViewAdapter( this );

    for( Port port : System.getCurrentTarget().getOpenPorts() )
    {
      if( port.service != null && port.service.isEmpty() == false )
      {
        mAdapter.addGroup( port.service );
        for(Vulnerability vuln : port.getVulnerabilities())
          mAdapter.addChild(port.service, vuln);
      }
    }

    mListView.setAdapter( mAdapter );
    mListView.setOnChildClickListener( new OnChildClickListener(){
      @Override
      public boolean onChildClick( ExpandableListView parent, View v, int groupPosition, int childPosition, long id ) {
        Vulnerability vuln = ( Vulnerability )mAdapter.getChild(groupPosition, childPosition);

        if( vuln != null )
        {
          String uri = ((vuln.osvdb_id>0) ? "http://osvdb.org/show/osvdb/" :  "http://web.nvd.nist.gov/view/vuln/detail?vulnId=") + vuln.getIdentifier();
          Intent browser = new Intent( Intent.ACTION_VIEW, Uri.parse( uri ) );

          startActivity( browser );
        }

        return true;
      }}
    );

    for( int i = 0; i < mAdapter.getGroupCount(); i++ )
    {
      mListView.expandGroup( i );
    }

    mSearchToggleButton.setOnClickListener( new OnClickListener(){
      @Override
      public void onClick(View v) {
        if(((ToggleButton)v).isChecked())
          setStartedState();
        else
          setStoppedState();
      }}
    );
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getSupportMenuInflater();
    inflater.inflate(R.menu.vulnerability_finder, menu);
    return super.onCreateOptionsMenu(menu);
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
      case R.id.search_exact_version:
        if(item.isChecked()) {
          item.setChecked(false);
          mVersionMatching=false;
        } else {
          item.setChecked(true);
          mVersionMatching=true;
        }
        return true;
      case R.id.vulnerability_search_performance:
        startActivity(new Intent(VulnerabilityFinder.this, SettingsActivity.class));
        return true;
      default:
        return super.onOptionsItemSelected(item);
    }
  }

  @Override
  public void onBackPressed() {
    setStoppedState();
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
  }
}