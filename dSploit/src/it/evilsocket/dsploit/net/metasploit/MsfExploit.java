package it.evilsocket.dsploit.net.metasploit;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.net.Target;

/**
 * this class store MSF Exploit
 */
public class MsfExploit extends Target.Exploit
{
  private Option[] mOptions = null;
  private Payload[] mPayloads = null;
  private String mFullDescription = null;
  private int mRank = 0;
  private String[] mTargets = null;
  private int mCurrentTarget = 0;
  private int mCurrentPayload = 0;
  private int mVersion = 0;

  public MsfExploit(String name, String url) {
    super(name,url);
    try {
      if(System.getMsfRpc()!=null) {
        retrieveInfos();
        retrieveOptions();
        retrievePayloads();
      }
    } catch ( IOException e) {
      Logger.error(e.getMessage());
    } catch (RPCClient.MSFException e) {
      Logger.error(e.getMessage());
    } finally {
      if(mOptions==null)
        mOptions = new Option[0];
      if(mPayloads==null)
        mPayloads = new Payload[0];
      if(mTargets==null)
        mTargets = new String[0];
    }
  }

  @SuppressWarnings("unchecked")
  private void retrieveOptions() throws IOException, RPCClient.MSFException {
    int i = 0;
    HashMap<String,HashMap<String, Object>> map =  (HashMap<String,HashMap<String, Object>>) System.getMsfRpc().call("module.options", "exploit", mName);
    Iterator<Map.Entry<String,HashMap<String, Object>>> it = map.entrySet().iterator();
    mOptions = new Option[map.size()];
    while(it.hasNext()) {
      Map.Entry<String,HashMap<String,Object>> item = it.next();
      String name = item.getKey();
      mOptions[i] = new Option(name,item.getValue());
      if(name.equals("RHOST"))
        mOptions[i].setValue(System.getCurrentTarget().getAddress().getHostAddress());
      i++;
    }
  }

  @SuppressWarnings("unchecked")
  private void retrieveInfos() throws IOException, RPCClient.MSFException {
    HashMap<String,Object> map = (HashMap<String,Object>) System.getMsfRpc().call("module.info", "exploit", mName);
    Iterator targetIterator = null;
    // use the name as description, mDescription should be quite short
    mDescription=(String)map.get("name");
    // store the real description in the mFullDescription string.
    mFullDescription=(String)map.get("description");
    // remove all newlines and tab chars, android UI will show it in the best way possible.
    mFullDescription = mFullDescription.replace("\n"," ");
    mFullDescription = mFullDescription.replace("\t","");
    // get rank
    mRank = (Integer)map.get("rank");
    //get version
    mVersion = Integer.parseInt((String)map.get("version"));
    // should we take references too ?
    // get targets
    Set<Map.Entry<Integer,String>> targetsSet = ((Map<Integer,String>) map.get("targets")).entrySet();
    targetIterator = targetsSet.iterator();
    mTargets = new String[targetsSet.size()];
    while(targetIterator.hasNext()) {
      Map.Entry<Integer,String> pair = (Map.Entry<Integer, String>) targetIterator.next();
      mTargets[pair.getKey()] = pair.getValue();
      targetIterator.remove();
    }
    mCurrentTarget = (Integer)map.get("default_target");
  }

  @SuppressWarnings("unchecked")
  private void retrievePayloads() throws IOException, RPCClient.MSFException {
    HashMap<String,ArrayList<String>> map = (HashMap<String,ArrayList<String>>) System.getMsfRpc().call("module.compatible_payloads",mName);
    ArrayList<String> payloads = map.get("payloads");
    int i = 0;
    if(payloads==null)
      mPayloads = new Payload[0];
    else {
      mPayloads = new Payload[payloads.size()];
      for(String pName : payloads) {
        mPayloads[i++] = new Payload(pName);
      }
    }
  }

  public String[] getTargets() {
    return mTargets;
  }

  public String getCurrentTarget() {
    return mTargets[mCurrentTarget];
  }

  public int getCurrentTargetIndex() {
    return mCurrentTarget;
  }

  public String getFullDescription() {
    return mFullDescription;
  }

  public int getRank() {
    return mRank;
  }

  public int getVersion() {
    return mVersion;
  }

  @Override
  public String toString() {
    return mName.substring(mName.lastIndexOf('/')+1);
  }

  @Override
  public int getDrawableResourceId() {
    return R.drawable.exploit_msf;
  }

  public Option[] getOptions() {
    return mOptions;
  }

  public Payload[] getPayloads() {
    return mPayloads;
  }

  public Payload getCurrentPayload() {
    if( mCurrentPayload < mPayloads.length) {
      return mPayloads[mCurrentPayload];
    }else {
      return null;
    }
  }
}
