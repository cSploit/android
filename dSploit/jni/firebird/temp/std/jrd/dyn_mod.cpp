/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/*********** Preprocessed module -- do not edit ***************/
/***************** gpre version LI-V2.5.2.26540 Firebird 2.5 **********************/
/*
 *	PROGRAM:	JRD Data Definition Utility
 *	MODULE:		dyn_mod.epp
 *	DESCRIPTION:	Dynamic data definition - DYN_modify_<x>
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * 2001.5.20: Claudio Valderrama: when changing a domain's name,
 *	if it has dimensions, rdb$field_dimensions should be updated, too.
 * 2001.5.23: Claudio Valderrama: Forbid zero length identifiers,
 *	they are not ANSI SQL compliant.
 * 2001.5.27 Claudio Valderrama: Prevent rdb$field_length from going
 *	out of sync when toggling between char and varchar data types.
 *	This caused check_update_fld_type() to lose ability to detect potentially
 *	dangerous changes. For example, you could alter a field or a domain and
 *	be able to change char(10) to varchar(8).
 *	Unfortunately, Borland chose to have DYN_modify_global_field() and add to the
 *	party DYN_modify_sql_field(); therefore bug fixes should be done twice.
 * 2001.10.08 Claudio Valderrama: put a comment with suggested code to hide
 *	special non-system triggers from user manipulation.
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002.08.10 Dmitry Yemanov: ALTER VIEW
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>

#include "../jrd/common.h"
#include "../jrd/jrd.h"
#include "../jrd/tra.h"
#include "../jrd/scl.h"
#include "../jrd/drq.h"
#include "../jrd/flags.h"
#include "../jrd/ibase.h"
#include "../jrd/lls.h"
#include "../jrd/met.h"
#include "../jrd/btr.h"
#include "../jrd/ini.h"
#include "../jrd/intl.h"
#include "../jrd/dyn.h"
#include "../jrd/ods.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dyn_proto.h"
#include "../jrd/dyn_df_proto.h"
#include "../jrd/dyn_md_proto.h"
#include "../jrd/dyn_ut_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/gds_proto.h"
#include "../jrd/inf_proto.h"
#include "../jrd/intl_proto.h"
#include "../jrd/isc_f_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../jrd/dsc_proto.h"
#include "../common/utils_proto.h"
#include "../dsql/DdlNodes.h"
#include "../dsql/metd_proto.h"

using MsgFormat::SafeArg;

using namespace Jrd;
using namespace Firebird;


/*DATABASE DB = STATIC "ODS.RDB";*/
static const UCHAR	jrd_0 [185] =
   {	// blr string 

4,2,4,1,12,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',2,0,0,'G',47,24,0,0,0,
25,0,0,0,255,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,24,0,22,0,41,
1,2,0,1,0,1,24,0,23,0,25,1,3,0,1,24,0,24,0,25,1,4,0,1,24,0,27,
0,25,1,5,0,1,24,0,25,0,25,1,6,0,1,24,0,26,0,25,1,7,0,1,24,0,11,
0,25,1,8,0,1,24,0,8,0,25,1,9,0,1,24,0,9,0,25,1,10,0,1,24,0,10,
0,25,1,11,0,255,14,1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_16 [121] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
0,12,0,2,7,'C',1,'K',31,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,
1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,24,0,3,0,25,1,1,0,255,17,0,9,
13,12,3,18,0,12,2,10,0,1,2,1,25,2,0,0,24,1,3,0,255,255,255,14,
1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_26 [459] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,24,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,
1,25,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,
32,0,12,0,2,7,'C',1,'K',2,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,
14,1,2,1,24,0,5,0,41,1,0,0,5,0,1,24,0,4,0,41,1,1,0,6,0,1,24,0,
6,0,41,1,2,0,7,0,1,24,0,7,0,41,1,3,0,8,0,1,21,8,0,1,0,0,0,25,
1,4,0,1,24,0,8,0,41,1,10,0,9,0,1,24,0,25,0,41,1,12,0,11,0,1,24,
0,26,0,41,1,14,0,13,0,1,24,0,24,0,41,1,16,0,15,0,1,24,0,11,0,
41,1,18,0,17,0,1,24,0,27,0,41,1,20,0,19,0,1,24,0,9,0,41,1,22,
0,21,0,1,24,0,10,0,41,1,24,0,23,0,255,17,0,9,13,12,3,18,0,12,
2,10,0,1,2,1,41,2,3,0,23,0,24,1,5,0,1,41,2,2,0,22,0,24,1,4,0,
1,41,2,1,0,21,0,24,1,6,0,1,41,2,0,0,20,0,24,1,7,0,1,41,2,19,0,
18,0,24,1,8,0,1,41,2,17,0,16,0,24,1,25,0,1,41,2,15,0,14,0,24,
1,26,0,1,41,2,13,0,12,0,24,1,24,0,1,41,2,11,0,10,0,24,1,11,0,
1,41,2,9,0,8,0,24,1,27,0,1,41,2,7,0,6,0,24,1,9,0,1,41,2,5,0,4,
0,24,1,10,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,4,0,255,255,
76
   };	// end of blr string 
static const UCHAR	jrd_82 [142] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,2,0,41,3,0,32,0,7,0,4,
0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',1,'K',27,0,0,'G',58,
47,24,0,13,0,25,0,1,0,47,24,0,12,0,25,0,0,0,255,2,14,1,2,1,24,
0,4,0,25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,255,17,0,9,13,12,3,18,
0,12,2,10,0,1,2,1,25,2,0,0,24,1,4,0,255,255,255,14,1,1,21,8,0,
0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_93 [319] =
   {	// blr string 

4,2,4,0,39,0,41,3,0,32,0,41,0,0,128,0,9,0,9,0,9,0,9,0,9,0,9,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
12,0,15,'K',2,0,0,2,1,25,0,0,0,24,0,0,0,1,41,0,9,0,8,0,24,0,8,
0,1,41,0,11,0,10,0,24,0,10,0,1,41,0,13,0,12,0,24,0,25,0,1,41,
0,15,0,14,0,24,0,26,0,1,41,0,17,0,16,0,24,0,24,0,1,41,0,19,0,
18,0,24,0,22,0,1,41,0,1,0,20,0,24,0,18,0,1,41,0,22,0,21,0,24,
0,23,0,1,41,0,2,0,23,0,24,0,3,0,1,41,0,3,0,24,0,24,0,2,0,1,41,
0,4,0,25,0,24,0,7,0,1,41,0,5,0,26,0,24,0,6,0,1,41,0,6,0,27,0,
24,0,5,0,1,41,0,7,0,28,0,24,0,4,0,1,41,0,30,0,29,0,24,0,17,0,
1,41,0,32,0,31,0,24,0,11,0,1,41,0,34,0,33,0,24,0,27,0,1,41,0,
'$',0,35,0,24,0,9,0,1,41,0,38,0,37,0,24,0,15,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_134 [142] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,2,0,41,3,0,32,0,7,0,4,
0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',1,'K',27,0,0,'G',58,
47,24,0,13,0,25,0,1,0,47,24,0,12,0,25,0,0,0,255,2,14,1,2,1,24,
0,4,0,25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,255,17,0,9,13,12,3,18,
0,12,2,10,0,1,2,1,25,2,0,0,24,1,4,0,255,255,255,14,1,1,21,8,0,
0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_145 [98] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,
0,2,7,'C',1,'K',2,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,
21,8,0,1,0,0,0,25,1,0,0,255,17,0,9,13,12,3,18,0,12,2,5,0,255,
255,14,1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_154 [211] =
   {	// blr string 

4,2,4,1,15,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',2,0,0,'G',
47,24,0,0,0,25,0,0,0,255,14,1,2,1,24,0,6,0,41,1,0,0,3,0,1,24,
0,4,0,41,1,1,0,5,0,1,21,8,0,1,0,0,0,25,1,2,0,1,24,0,22,0,25,1,
4,0,1,24,0,23,0,25,1,6,0,1,24,0,24,0,25,1,7,0,1,24,0,27,0,25,
1,8,0,1,24,0,25,0,25,1,9,0,1,24,0,26,0,25,1,10,0,1,24,0,11,0,
25,1,11,0,1,24,0,8,0,25,1,12,0,1,24,0,9,0,25,1,13,0,1,24,0,10,
0,25,1,14,0,255,14,1,1,21,8,0,0,0,0,0,25,1,2,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_173 [470] =
   {	// blr string 

4,2,4,7,6,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,4,6,2,0,41,3,0,32,
0,7,0,4,5,4,0,9,0,9,0,7,0,7,0,4,4,2,0,7,0,7,0,4,3,1,0,7,0,4,2,
4,0,41,3,0,32,0,7,0,7,0,7,0,4,1,18,0,9,0,9,0,41,3,0,32,0,41,3,
0,32,0,41,3,0,32,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',2,'K',
5,0,0,'K',6,0,1,'G',58,47,24,1,8,0,24,0,1,0,58,47,24,0,1,0,25,
0,1,0,47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,17,0,41,1,0,0,
9,0,1,24,0,12,0,41,1,1,0,10,0,1,24,0,4,0,41,1,2,0,16,0,1,24,0,
1,0,25,1,3,0,1,24,0,2,0,41,1,4,0,15,0,1,24,1,0,0,41,1,5,0,17,
0,1,21,8,0,1,0,0,0,25,1,6,0,1,24,0,10,0,25,1,7,0,1,24,0,6,0,25,
1,8,0,1,24,0,18,0,41,1,12,0,11,0,1,24,0,8,0,41,1,14,0,13,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,6,2,1,25,2,3,0,24,6,10,0,1,25,2,
2,0,24,6,6,0,1,41,2,0,0,1,0,24,6,4,0,255,12,4,10,0,5,2,1,41,4,
1,0,0,0,24,5,8,0,255,12,5,10,0,4,2,1,41,5,1,0,3,0,24,4,17,0,1,
41,5,0,0,2,0,24,4,12,0,255,12,6,10,0,3,2,1,41,6,0,0,1,0,24,3,
2,0,255,12,7,10,0,2,2,1,41,7,5,0,4,0,24,2,18,0,1,41,7,3,0,2,0,
24,2,8,0,1,41,7,0,0,1,0,24,2,2,0,255,255,255,14,1,1,21,8,0,0,
0,0,0,25,1,6,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_221 [71] =
   {	// blr string 

4,2,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',2,0,0,
'G',47,24,0,0,0,25,0,0,0,255,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,
255,14,1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_226 [86] =
   {	// blr string 

4,2,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',
1,'K',5,0,0,'G',58,47,24,0,1,0,25,0,1,0,47,24,0,0,0,25,0,0,0,
255,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,255,14,1,1,21,8,0,0,0,0,
0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_232 [195] =
   {	// blr string 

4,2,4,4,1,0,41,3,0,32,0,4,3,1,0,7,0,4,2,1,0,41,3,0,32,0,4,1,3,
0,41,3,0,32,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,
12,0,2,7,'C',2,'K',4,0,0,'K',3,0,1,'G',58,47,24,0,0,0,24,1,0,
0,58,47,24,0,1,0,25,0,1,0,47,24,1,1,0,25,0,0,0,255,2,14,1,2,1,
24,0,0,0,25,1,0,0,1,24,1,1,0,25,1,1,0,1,21,8,0,1,0,0,0,25,1,2,
0,255,17,0,9,13,12,3,18,0,12,2,10,0,3,2,1,25,2,0,0,24,3,0,0,255,
12,4,10,1,2,2,1,25,4,0,0,24,2,1,0,255,255,255,14,1,1,21,8,0,0,
0,0,0,25,1,2,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_246 [108] =
   {	// blr string 

4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,
0,2,7,'C',1,'K',13,0,0,'D',21,8,0,1,0,0,0,'G',58,47,24,0,1,0,
25,0,1,0,47,24,0,2,0,25,0,0,0,255,14,1,2,1,24,0,0,0,25,1,0,0,
1,21,8,0,1,0,0,0,25,1,1,0,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,
255,255,76
   };	// end of blr string 
static const UCHAR	jrd_253 [166] =
   {	// blr string 

4,2,4,1,2,0,41,3,0,32,0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,
0,2,7,'C',3,'K',5,0,0,'K',5,0,1,'K',7,0,2,'D',21,8,0,1,0,0,0,
'G',58,47,24,0,1,0,25,0,1,0,58,47,24,0,0,0,25,0,0,0,58,47,24,
0,0,0,24,1,4,0,58,47,24,0,2,0,24,1,2,0,58,47,24,1,1,0,24,2,0,
0,58,47,24,0,1,0,24,2,1,0,47,24,1,10,0,24,2,2,0,255,14,1,2,1,
24,2,0,0,25,1,0,0,1,21,8,0,1,0,0,0,25,1,1,0,255,14,1,1,21,8,0,
0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_260 [128] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,2,0,7,0,7,0,4,0,1,0,41,3,0,32,
0,12,0,2,7,'C',1,'K',5,0,0,'G',47,24,0,1,0,25,0,0,0,'F',1,'H',
24,0,6,0,255,2,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,1,24,0,6,0,25,
1,1,0,255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,25,2,0,0,24,1,6,
0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_270 [181] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,3,0,41,3,0,32,0,7,0,7,0,4,1,4,0,41,3,0,32,
0,7,0,7,0,7,0,4,0,3,0,41,3,0,32,0,7,0,7,0,12,0,2,7,'C',1,'K',
5,0,0,'G',58,47,24,0,1,0,25,0,0,0,58,50,24,0,6,0,25,0,2,0,52,
24,0,6,0,25,0,1,0,255,2,14,1,2,1,24,0,0,0,25,1,0,0,1,21,8,0,1,
0,0,0,25,1,1,0,1,24,0,6,0,41,1,3,0,2,0,255,17,0,9,13,12,3,18,
0,12,2,10,0,1,2,1,41,2,2,0,1,0,24,1,6,0,1,25,2,0,0,24,1,0,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_286 [95] =
   {	// blr string 

4,2,4,0,10,0,41,0,0,0,1,8,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,
0,15,'K',10,0,0,2,1,41,0,4,0,3,0,24,0,5,0,1,41,0,1,0,5,0,24,0,
3,0,1,41,0,2,0,6,0,24,0,2,0,1,41,0,8,0,7,0,24,0,4,0,1,41,0,0,
0,9,0,24,0,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_298 [160] =
   {	// blr string 

4,2,4,5,1,0,7,0,4,4,1,0,7,0,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,
0,4,0,4,0,41,0,0,0,1,7,0,7,0,7,0,2,7,'C',1,'K',10,0,0,255,2,14,
0,2,1,24,0,0,0,41,0,0,0,2,0,1,21,8,0,1,0,0,0,25,0,1,0,1,24,0,
4,0,25,0,3,0,255,17,0,9,13,12,2,18,0,12,1,10,0,2,2,1,25,1,0,0,
24,2,4,0,255,12,3,5,0,12,4,10,0,1,2,1,25,4,0,0,24,1,4,0,255,12,
5,5,0,255,255,14,0,1,21,8,0,0,0,0,0,25,0,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_314 [110] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,0,4,0,2,0,41,3,0,32,0,7,
0,12,0,2,7,'C',1,'K',12,0,0,'G',58,47,24,0,1,0,25,0,0,0,47,24,
0,8,0,25,0,1,0,255,2,14,1,2,1,21,8,0,1,0,0,0,25,1,0,0,255,17,
0,9,13,12,3,18,0,12,2,5,0,255,255,14,1,1,21,8,0,0,0,0,0,25,1,
0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_324 [98] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,1,0,7,0,4,1,1,0,7,0,4,0,1,0,41,3,0,32,0,12,
0,2,7,'C',1,'K',7,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,
21,8,0,1,0,0,0,25,1,0,0,255,17,0,9,13,12,3,18,0,12,2,5,0,255,
255,14,1,1,21,8,0,0,0,0,0,25,1,0,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_333 [290] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,11,0,9,0,9,0,9,0,41,3,0,32,0,41,3,0,32,0,
7,0,7,0,7,0,7,0,7,0,7,0,4,1,12,0,41,3,0,32,0,41,3,0,32,0,9,0,
9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,
2,7,'C',1,'K',6,0,0,'G',58,47,24,0,8,0,25,0,0,0,59,61,24,0,0,
0,255,2,14,1,2,1,24,0,8,0,25,1,0,0,1,24,0,9,0,41,1,1,0,6,0,1,
24,0,1,0,41,1,2,0,7,0,1,24,0,0,0,41,1,3,0,8,0,1,24,0,2,0,41,1,
4,0,11,0,1,21,8,0,1,0,0,0,25,1,5,0,1,24,0,4,0,41,1,10,0,9,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,25,2,4,0,24,1,8,0,1,41,2,
3,0,10,0,24,1,9,0,1,41,2,2,0,9,0,24,1,1,0,1,41,2,1,0,8,0,24,1,
0,0,1,41,2,7,0,6,0,24,1,4,0,1,41,2,0,0,5,0,24,1,2,0,255,255,255,
14,1,1,21,8,0,0,0,0,0,25,1,5,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_363 [177] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,4,0,41,0,0,0,4,7,0,7,0,7,0,4,1,5,0,41,0,0,
0,4,7,0,7,0,7,0,7,0,4,0,2,0,41,3,0,32,0,7,0,12,0,2,7,'C',1,'K',
17,0,0,'G',58,47,24,0,1,0,25,0,1,0,47,24,0,0,0,25,0,0,0,255,2,
14,1,2,1,24,0,2,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,1,24,
0,1,0,41,1,4,0,3,0,255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,
2,0,0,3,0,24,1,2,0,1,41,2,2,0,1,0,24,1,1,0,255,255,255,14,1,1,
21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_380 [159] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,4,0,9,0,7,0,7,0,7,0,4,1,5,0,9,0,7,0,7,0,7,
0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',12,0,0,'G',47,24,
0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,11,0,41,1,0,0,2,0,1,21,8,0,
1,0,0,0,25,1,1,0,1,24,0,10,0,41,1,4,0,3,0,255,17,0,9,13,12,3,
18,0,12,2,10,0,1,2,1,41,2,0,0,3,0,24,1,11,0,1,41,2,2,0,1,0,24,
1,10,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_396 [358] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,15,0,41,3,0,32,0,9,0,41,3,0,32,0,9,0,9,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,1,18,0,9,0,9,0,41,3,
0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',12,0,0,'G',
47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,4,0,41,1,0,0,6,0,1,24,
0,5,0,41,1,1,0,7,0,1,24,0,0,0,25,1,2,0,1,24,0,6,0,41,1,3,0,14,
0,1,24,0,1,0,41,1,4,0,17,0,1,21,8,0,1,0,0,0,25,1,5,0,1,24,0,7,
0,41,1,9,0,8,0,1,24,0,2,0,41,1,11,0,10,0,1,24,0,3,0,41,1,13,0,
12,0,1,24,0,8,0,41,1,16,0,15,0,255,17,0,9,13,12,3,18,0,12,2,10,
0,1,2,1,41,2,4,0,14,0,24,1,4,0,1,41,2,3,0,13,0,24,1,5,0,1,41,
2,12,0,11,0,24,1,7,0,1,41,2,10,0,9,0,24,1,2,0,1,41,2,8,0,7,0,
24,1,3,0,1,25,2,2,0,24,1,0,0,1,41,2,1,0,6,0,24,1,6,0,1,41,2,0,
0,5,0,24,1,1,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,5,0,255,
255,76
   };	// end of blr string 
static const UCHAR	jrd_436 [129] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,9,0,7,0,4,1,3,0,9,0,7,0,7,0,4,0,1,0,41,
3,0,32,0,12,0,2,7,'C',1,'K',31,0,0,'G',47,24,0,0,0,25,0,0,0,255,
2,14,1,2,1,24,0,2,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,0,0,1,0,24,1,2,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_448 [246] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,8,0,41,3,0,32,0,41,0,0,0,1,9,0,7,0,7,0,7,
0,7,0,7,0,4,1,11,0,9,0,41,0,0,0,1,41,3,0,32,0,9,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',6,0,0,
'G',47,24,0,8,0,25,0,0,0,255,2,14,1,2,1,24,0,2,0,41,1,0,0,5,0,
1,24,0,10,0,41,1,1,0,6,0,1,24,0,9,0,41,1,2,0,7,0,1,24,0,0,0,41,
1,3,0,10,0,1,21,8,0,1,0,0,0,25,1,4,0,1,24,0,4,0,41,1,9,0,8,0,
255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,2,0,7,0,24,1,2,0,
1,41,2,1,0,6,0,24,1,10,0,1,41,2,0,0,5,0,24,1,9,0,1,41,2,4,0,3,
0,24,1,4,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,4,0,255,255,
76
   };	// end of blr string 
static const UCHAR	jrd_474 [405] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,20,0,9,0,9,0,9,0,9,0,41,3,0,32,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,1,21,0,
41,3,0,32,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
1,'K',26,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,7,0,
41,1,0,0,6,0,1,24,0,13,0,41,1,1,0,11,0,1,24,0,5,0,41,1,2,0,16,
0,1,24,0,6,0,41,1,3,0,17,0,1,24,0,4,0,41,1,4,0,20,0,1,21,8,0,
1,0,0,0,25,1,5,0,1,24,0,12,0,41,1,8,0,7,0,1,24,0,11,0,41,1,10,
0,9,0,1,24,0,3,0,41,1,13,0,12,0,1,24,0,2,0,41,1,15,0,14,0,1,24,
0,10,0,41,1,19,0,18,0,255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,
41,2,4,0,19,0,24,1,7,0,1,41,2,18,0,17,0,24,1,12,0,1,41,2,16,0,
15,0,24,1,11,0,1,41,2,3,0,14,0,24,1,13,0,1,41,2,13,0,12,0,24,
1,3,0,1,41,2,11,0,10,0,24,1,2,0,1,41,2,2,0,9,0,24,1,5,0,1,41,
2,1,0,8,0,24,1,6,0,1,41,2,7,0,6,0,24,1,10,0,1,41,2,0,0,5,0,24,
1,4,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,5,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_522 [750] =
   {	// blr string 

4,2,4,5,2,0,9,0,7,0,4,4,14,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,7,0,4,3,1,0,7,0,4,2,24,0,9,0,9,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,4,1,41,0,9,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,4,0,2,0,41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',2,'K',27,0,
0,'K',2,0,1,'G',58,47,24,0,0,0,25,0,1,0,58,47,24,0,1,0,25,0,0,
0,47,24,1,0,0,24,0,4,0,255,2,14,1,2,1,24,1,7,0,41,1,0,0,26,0,
1,24,1,6,0,41,1,1,0,27,0,1,24,0,8,0,41,1,2,0,34,0,1,24,0,7,0,
41,1,3,0,35,0,1,24,0,5,0,41,1,4,0,40,0,1,21,8,0,1,0,0,0,25,1,
5,0,1,24,1,27,0,41,1,7,0,6,0,1,24,1,26,0,41,1,9,0,8,0,1,24,1,
25,0,41,1,11,0,10,0,1,24,1,24,0,41,1,13,0,12,0,1,24,1,23,0,41,
1,15,0,14,0,1,24,1,17,0,41,1,17,0,16,0,1,24,1,11,0,41,1,19,0,
18,0,1,24,1,10,0,41,1,21,0,20,0,1,24,1,9,0,41,1,23,0,22,0,1,24,
1,8,0,41,1,25,0,24,0,1,24,0,11,0,41,1,29,0,28,0,1,24,0,10,0,41,
1,31,0,30,0,1,24,0,9,0,41,1,33,0,32,0,1,24,0,3,0,41,1,37,0,'$',
0,1,24,0,2,0,41,1,39,0,38,0,255,17,0,9,13,12,3,18,0,12,4,10,0,
3,2,1,41,4,13,0,12,0,24,3,11,0,1,41,4,11,0,10,0,24,3,10,0,1,41,
4,9,0,8,0,24,3,9,0,1,41,4,1,0,7,0,24,3,8,0,1,41,4,0,0,6,0,24,
3,7,0,1,41,4,5,0,4,0,24,3,3,0,1,41,4,3,0,2,0,24,3,2,0,255,12,
2,10,1,4,2,1,41,2,23,0,22,0,24,4,27,0,1,41,2,21,0,20,0,24,4,26,
0,1,41,2,19,0,18,0,24,4,25,0,1,41,2,17,0,16,0,24,4,24,0,1,41,
2,15,0,14,0,24,4,23,0,1,41,2,13,0,12,0,24,4,17,0,1,41,2,11,0,
10,0,24,4,11,0,1,41,2,9,0,8,0,24,4,10,0,1,41,2,7,0,6,0,24,4,9,
0,1,41,2,5,0,4,0,24,4,8,0,1,41,2,1,0,3,0,24,4,7,0,1,41,2,0,0,
2,0,24,4,6,0,255,12,5,10,0,2,2,1,41,5,0,0,1,0,24,2,5,0,255,255,
255,14,1,1,21,8,0,0,0,0,0,25,1,5,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_613 [390] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,15,0,41,3,0,32,0,41,3,0,32,0,9,0,41,0,0,128,
0,41,3,0,32,0,41,3,0,32,0,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
4,1,16,0,9,0,41,3,0,32,0,41,3,0,32,0,41,0,0,128,0,9,0,41,3,0,
32,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,2,0,
41,3,0,32,0,41,3,0,32,0,12,0,2,7,'C',1,'K',5,0,0,'G',58,47,24,
0,0,0,25,0,1,0,47,24,0,1,0,25,0,0,0,255,2,14,1,2,1,24,0,11,0,
41,1,0,0,8,0,1,24,0,2,0,25,1,1,0,1,24,0,14,0,41,1,2,0,9,0,1,24,
0,5,0,41,1,3,0,10,0,1,24,0,7,0,41,1,4,0,11,0,1,24,0,0,0,25,1,
5,0,1,24,0,3,0,41,1,6,0,12,0,1,21,8,0,1,0,0,0,25,1,7,0,1,24,0,
13,0,41,1,14,0,13,0,1,24,0,6,0,25,1,15,0,255,17,0,9,13,12,3,18,
0,12,2,10,0,1,2,1,41,2,6,0,14,0,24,1,11,0,1,25,2,5,0,24,1,2,0,
1,41,2,4,0,13,0,24,1,14,0,1,41,2,3,0,12,0,24,1,5,0,1,41,2,2,0,
11,0,24,1,7,0,1,25,2,1,0,24,1,0,0,1,41,2,0,0,10,0,24,1,3,0,1,
41,2,9,0,8,0,24,1,13,0,1,25,2,7,0,24,1,6,0,255,255,255,14,1,1,
21,8,0,0,0,0,0,25,1,7,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_652 [217] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,8,0,9,0,27,7,0,7,0,7,0,7,0,7,0,7,0,4,1,9,
0,27,9,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,
2,7,'C',1,'K',4,0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,
0,12,0,41,1,0,0,3,0,1,24,0,4,0,41,1,1,0,4,0,1,21,8,0,1,0,0,0,
25,1,2,0,1,24,0,6,0,41,1,6,0,5,0,1,24,0,3,0,41,1,8,0,7,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,1,0,7,0,24,1,12,0,1,
41,2,0,0,6,0,24,1,4,0,1,41,2,5,0,4,0,24,1,6,0,1,41,2,3,0,2,0,
24,1,3,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,2,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_676 [99] =
   {	// blr string 

4,2,4,1,3,0,41,3,0,32,0,41,3,0,32,0,7,0,4,0,1,0,41,3,0,32,0,12,
0,2,7,'C',1,'K',5,0,0,'G',47,24,0,2,0,25,0,0,0,255,14,1,2,1,24,
0,0,0,25,1,0,0,1,24,0,1,0,25,1,1,0,1,21,8,0,1,0,0,0,25,1,2,0,
255,14,1,1,21,8,0,0,0,0,0,25,1,2,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_683 [163] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,41,3,0,32,0,7,0,4,1,5,0,41,3,0,32,0,41,
3,0,32,0,41,3,0,32,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',
1,'K',5,0,0,'G',47,24,0,2,0,25,0,0,0,255,2,14,1,2,1,24,0,0,0,
25,1,0,0,1,24,0,1,0,25,1,1,0,1,24,0,2,0,41,1,2,0,4,0,1,21,8,0,
1,0,0,0,25,1,3,0,255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,
0,0,1,0,24,1,2,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,3,0,255,
255,76
   };	// end of blr string 
static const UCHAR	jrd_697 [135] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,41,3,0,32,0,7,0,4,1,3,0,41,3,0,32,0,7,
0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',21,0,0,'G',47,24,
0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,0,0,41,1,0,0,2,0,1,21,8,0,
1,0,0,0,25,1,1,0,255,17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,
0,0,1,0,24,1,0,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,
255,76
   };	// end of blr string 
static const UCHAR	jrd_709 [690] =
   {	// blr string 

4,2,4,4,2,0,41,3,0,32,0,7,0,4,3,1,0,7,0,4,2,34,0,9,0,41,3,0,32,
0,9,0,41,0,0,128,0,9,0,9,0,9,0,9,0,9,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,4,1,39,0,9,0,9,0,9,0,9,0,9,0,41,0,0,128,0,9,0,
41,3,0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,
7,0,7,0,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',2,
0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,7,0,41,1,0,0,
11,0,1,24,0,6,0,41,1,1,0,12,0,1,24,0,14,0,41,1,2,0,13,0,1,24,
0,3,0,41,1,3,0,14,0,1,24,0,12,0,41,1,4,0,15,0,1,24,0,18,0,41,
1,5,0,16,0,1,24,0,16,0,41,1,6,0,17,0,1,24,0,1,0,41,1,7,0,18,0,
1,24,0,2,0,41,1,8,0,27,0,1,24,0,0,0,41,1,9,0,28,0,1,21,8,0,1,
0,0,0,25,1,10,0,1,24,0,22,0,25,1,29,0,1,24,0,23,0,25,1,30,0,1,
24,0,24,0,41,1,31,0,22,0,1,24,0,27,0,41,1,32,0,24,0,1,24,0,25,
0,41,1,33,0,20,0,1,24,0,26,0,41,1,34,0,21,0,1,24,0,11,0,41,1,
35,0,23,0,1,24,0,8,0,41,1,'$',0,19,0,1,24,0,9,0,41,1,37,0,25,
0,1,24,0,10,0,41,1,38,0,26,0,255,17,0,9,13,12,3,18,0,12,2,10,
0,2,2,1,41,2,8,0,33,0,24,2,7,0,1,41,2,7,0,32,0,24,2,6,0,1,41,
2,6,0,31,0,24,2,14,0,1,41,2,5,0,30,0,24,2,3,0,1,41,2,4,0,29,0,
24,2,12,0,1,41,2,3,0,28,0,24,2,18,0,1,41,2,2,0,27,0,24,2,16,0,
1,41,2,1,0,26,0,24,2,1,0,1,41,2,0,0,25,0,24,2,2,0,1,41,2,24,0,
23,0,24,2,24,0,1,41,2,22,0,21,0,24,2,27,0,1,41,2,20,0,19,0,24,
2,25,0,1,41,2,18,0,17,0,24,2,26,0,1,41,2,16,0,15,0,24,2,11,0,
1,41,2,14,0,13,0,24,2,8,0,1,41,2,12,0,11,0,24,2,9,0,1,41,2,10,
0,9,0,24,2,10,0,255,12,4,10,0,1,2,1,41,4,0,0,1,0,24,1,0,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,10,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_792 [129] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,9,0,7,0,4,1,3,0,9,0,7,0,7,0,4,0,1,0,41,
3,0,32,0,12,0,2,7,'C',1,'K',20,0,0,'G',47,24,0,0,0,25,0,0,0,255,
2,14,1,2,1,24,0,3,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,0,0,1,0,24,1,3,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_804 [201] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,6,0,9,0,41,0,0,0,1,41,0,0,32,0,7,0,7,0,7,
0,4,1,7,0,41,0,0,32,0,41,0,0,0,1,9,0,7,0,7,0,7,0,7,0,4,0,1,0,
41,3,0,32,0,12,0,2,7,'C',1,'K',14,0,0,'G',47,24,0,0,0,25,0,0,
0,255,2,14,1,2,1,24,0,5,0,41,1,0,0,4,0,1,24,0,4,0,41,1,1,0,5,
0,1,24,0,3,0,41,1,2,0,6,0,1,21,8,0,1,0,0,0,25,1,3,0,255,17,0,
9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,2,0,5,0,24,1,5,0,1,41,2,1,
0,4,0,24,1,4,0,1,41,2,0,0,3,0,24,1,3,0,255,255,255,14,1,1,21,
8,0,0,0,0,0,25,1,3,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_824 [129] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,9,0,7,0,4,1,3,0,9,0,7,0,7,0,4,0,1,0,41,
3,0,32,0,12,0,2,7,'C',1,'K',16,0,0,'G',47,24,0,0,0,25,0,0,0,255,
2,14,1,2,1,24,0,1,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,0,0,1,0,24,1,1,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_836 [165] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,4,0,41,0,0,0,4,9,0,7,0,7,0,4,1,5,0,9,0,41,
0,0,0,4,7,0,7,0,7,0,4,0,1,0,41,3,0,32,0,12,0,2,7,'C',1,'K',30,
0,0,'G',47,24,0,0,0,25,0,0,0,255,2,14,1,2,1,24,0,3,0,41,1,0,0,
3,0,1,24,0,2,0,41,1,1,0,4,0,1,21,8,0,1,0,0,0,25,1,2,0,255,17,
0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,1,0,3,0,24,1,3,0,1,41,2,
0,0,2,0,24,1,2,0,255,255,255,14,1,1,21,8,0,0,0,0,0,25,1,2,0,255,
255,76
   };	// end of blr string 
static const UCHAR	jrd_852 [180] =
   {	// blr string 

4,2,4,2,1,0,7,0,4,1,6,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,
0,4,0,7,0,41,3,0,32,0,9,0,41,3,0,32,0,7,0,7,0,7,0,7,0,2,7,'C',
1,'K',1,0,0,255,2,14,0,2,1,24,0,3,0,41,0,0,0,4,0,1,24,0,0,0,41,
0,1,0,5,0,1,24,0,2,0,41,0,2,0,6,0,1,21,8,0,1,0,0,0,25,0,3,0,255,
17,0,9,13,12,2,18,0,12,1,10,0,1,2,1,41,1,2,0,5,0,24,1,3,0,1,41,
1,1,0,4,0,24,1,0,0,1,41,1,0,0,3,0,24,1,2,0,255,255,255,14,0,1,
21,8,0,0,0,0,0,25,0,3,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_870 [129] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,9,0,7,0,4,1,3,0,9,0,7,0,7,0,4,0,1,0,41,
3,0,32,0,12,0,2,7,'C',1,'K',29,0,0,'G',47,24,0,0,0,25,0,0,0,255,
2,14,1,2,1,24,0,5,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,0,0,1,0,24,1,5,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 
static const UCHAR	jrd_882 [129] =
   {	// blr string 

4,2,4,3,1,0,7,0,4,2,2,0,9,0,7,0,4,1,3,0,9,0,7,0,7,0,4,0,1,0,41,
3,0,32,0,12,0,2,7,'C',1,'K',28,0,0,'G',47,24,0,0,0,25,0,0,0,255,
2,14,1,2,1,24,0,6,0,41,1,0,0,2,0,1,21,8,0,1,0,0,0,25,1,1,0,255,
17,0,9,13,12,3,18,0,12,2,10,0,1,2,1,41,2,0,0,1,0,24,1,6,0,255,
255,255,14,1,1,21,8,0,0,0,0,0,25,1,1,0,255,255,76
   };	// end of blr string 


//const int MAX_CHARS_SHORT	= 6;		// 2**16  = 5 chars + sign
//const int MAX_CHARS_LONG	= 11;		// 2**32  = 10 chars + sign
//const int MAX_CHARS_INT64	= 20;		// 2**64  = 19 chars + sign
//const int MAX_CHARS_DOUBLE	= 22;	// 15 digits + 2 signs + E + decimal + 3 digit exp
//const int MAX_CHARS_FLOAT	= 13;		// 7 digits + 2 signs + E + decimal + 2 digit exp

static const UCHAR alloc_info[] = { isc_info_allocation, isc_info_end };
static void change_backup_mode(Global*, UCHAR verb);

static void modify_lfield_position(thread_db*, Global*, const MetaName&, const MetaName&,
	USHORT, USHORT);
static bool check_view_dependency(thread_db*, Global*, const MetaName&, const MetaName&);
static bool check_sptrig_dependency(thread_db*, Global*,  const MetaName&, const MetaName&);
static void modify_lfield_index(thread_db*, Global*, const MetaName&, const MetaName&,
	const MetaName&);
static bool field_exists(thread_db*, Global*, const MetaName&, const MetaName&);
static bool domain_exists(thread_db*, Global*, const MetaName&);
static void get_domain_type(thread_db*, Global*, dyn_fld&);
static ULONG check_update_fld_type(const dyn_fld&, const dyn_fld&);
static ULONG check_update_numeric_type(const dyn_fld&, const dyn_fld&);
static void modify_err_punt(thread_db*, ULONG, const dyn_fld&, const dyn_fld&);


// ***********************************
// D Y N _ m o d i f y _ c h a r s e t
// ***********************************
// Its purpose is to change the comment in the charset's record.
void DYN_modify_charset(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_893;	// gds__utility 
   } jrd_892;
   struct {
          bid  jrd_890;	// RDB$DESCRIPTION 
          SSHORT jrd_891;	// gds__null_flag 
   } jrd_889;
   struct {
          bid  jrd_886;	// RDB$DESCRIPTION 
          SSHORT jrd_887;	// gds__utility 
          SSHORT jrd_888;	// gds__null_flag 
   } jrd_885;
   struct {
          TEXT  jrd_884 [32];	// RDB$CHARACTER_SET_NAME 
   } jrd_883;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_chset, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$CHARACTER_SETS
				WITH X.RDB$CHARACTER_SET_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_882, sizeof(jrd_882), true);
		gds__vtov ((const char*) t, (char*) jrd_883.jrd_884, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_883);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 12, (UCHAR*) &jrd_885);
		   if (!jrd_885.jrd_887) break;

			if (!DYN_REQUEST(drq_m_chset))
				DYN_REQUEST(drq_m_chset) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_885.jrd_886))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_885.jrd_888 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_885.jrd_888 = TRUE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_889.jrd_890 = jrd_885.jrd_886;
			jrd_889.jrd_891 = jrd_885.jrd_888;
			EXE_send (tdbb, request, 2, 10, (UCHAR*) &jrd_889);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_892);
		   }
		}

		if (!DYN_REQUEST(drq_m_chset))
			DYN_REQUEST(drq_m_chset) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 85);
		// msg 85: "MODIFY RDB$CHARACTER_SETS failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 151, t);
		// msg 151: "Character set %s not found"
	}
}


// ***************************************
// D Y N _ m o d i f y _ c o l l a t i o n
// ***************************************
// Its purpose is to change the comment in the collation's record.
void DYN_modify_collation(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_881;	// gds__utility 
   } jrd_880;
   struct {
          bid  jrd_878;	// RDB$DESCRIPTION 
          SSHORT jrd_879;	// gds__null_flag 
   } jrd_877;
   struct {
          bid  jrd_874;	// RDB$DESCRIPTION 
          SSHORT jrd_875;	// gds__utility 
          SSHORT jrd_876;	// gds__null_flag 
   } jrd_873;
   struct {
          TEXT  jrd_872 [32];	// RDB$COLLATION_NAME 
   } jrd_871;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_coll, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$COLLATIONS
				WITH X.RDB$COLLATION_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_870, sizeof(jrd_870), true);
		gds__vtov ((const char*) t, (char*) jrd_871.jrd_872, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_871);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 12, (UCHAR*) &jrd_873);
		   if (!jrd_873.jrd_875) break;

			if (!DYN_REQUEST(drq_m_coll))
				DYN_REQUEST(drq_m_coll) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_873.jrd_874))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_873.jrd_876 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_873.jrd_876 = TRUE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_877.jrd_878 = jrd_873.jrd_874;
			jrd_877.jrd_879 = jrd_873.jrd_876;
			EXE_send (tdbb, request, 2, 10, (UCHAR*) &jrd_877);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_880);
		   }
		}

		if (!DYN_REQUEST(drq_m_coll))
			DYN_REQUEST(drq_m_coll) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 86);
		// msg 86: "MODIFY RDB$COLLATIONS failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 152, t);
		// msg 152: "Collation %s not found"
	}
}


void DYN_modify_database( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_869;	// gds__utility 
   } jrd_868;
   struct {
          TEXT  jrd_862 [32];	// RDB$SECURITY_CLASS 
          bid  jrd_863;	// RDB$DESCRIPTION 
          TEXT  jrd_864 [32];	// RDB$CHARACTER_SET_NAME 
          SSHORT jrd_865;	// gds__null_flag 
          SSHORT jrd_866;	// gds__null_flag 
          SSHORT jrd_867;	// gds__null_flag 
   } jrd_861;
   struct {
          TEXT  jrd_854 [32];	// RDB$CHARACTER_SET_NAME 
          bid  jrd_855;	// RDB$DESCRIPTION 
          TEXT  jrd_856 [32];	// RDB$SECURITY_CLASS 
          SSHORT jrd_857;	// gds__utility 
          SSHORT jrd_858;	// gds__null_flag 
          SSHORT jrd_859;	// gds__null_flag 
          SSHORT jrd_860;	// gds__null_flag 
   } jrd_853;
/**************************************
 *
 *	D Y N _ m o d i f y _ d a t a b a s e
 *
 **************************************
 *
 * Functional description
 *	Modify a database.
 *
 **************************************/
	UCHAR s[128];

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = NULL;

	try {

	INF_database_info(alloc_info, sizeof(alloc_info), s, sizeof(s));

	if (s[0] != isc_info_allocation) {
		goto dyn_punt_84;
	}

	request = CMP_find_request(tdbb, drq_m_database, DYN_REQUESTS);

	const SSHORT length = gds__vax_integer(s + 1, 2);
	SLONG start = gds__vax_integer(s + 3, length);

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		DBB IN RDB$DATABASE*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_852, sizeof(jrd_852), true);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	while (1)
	   {
	   EXE_receive (tdbb, request, 0, 80, (UCHAR*) &jrd_853);
	   if (!jrd_853.jrd_857) break;

		if (!DYN_REQUEST(drq_m_database))
			DYN_REQUEST(drq_m_database) = request;

		/*MODIFY DBB USING*/
		{
		
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_security_class:
					if (GET_STRING(ptr, /*DBB.RDB$SECURITY_CLASS*/
							    jrd_853.jrd_856))
						/*DBB.RDB$SECURITY_CLASS.NULL*/
						jrd_853.jrd_860 = FALSE;
					else
						/*DBB.RDB$SECURITY_CLASS.NULL*/
						jrd_853.jrd_860 = TRUE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*DBB.RDB$DESCRIPTION*/
									 jrd_853.jrd_855))
						/*DBB.RDB$DESCRIPTION.NULL*/
						jrd_853.jrd_859 = FALSE;
					else
						/*DBB.RDB$DESCRIPTION.NULL*/
						jrd_853.jrd_859 = TRUE;
					break;

				case isc_dyn_def_file:
					DYN_define_file(gbl, ptr, (SLONG) 0, &start, 84);
					break;

				case isc_dyn_def_difference:
					DYN_define_difference(gbl, ptr);
					break;

				case isc_dyn_drop_difference:
				case isc_dyn_begin_backup:
				case isc_dyn_end_backup:
					change_backup_mode(gbl, verb);
					break;

				case isc_dyn_fld_character_set_name:
					if (GET_STRING(ptr, /*DBB.RDB$CHARACTER_SET_NAME*/
							    jrd_853.jrd_854))
						/*DBB.RDB$CHARACTER_SET_NAME.NULL*/
						jrd_853.jrd_858 = FALSE;
					else
						/*DBB.RDB$CHARACTER_SET_NAME.NULL*/
						jrd_853.jrd_858 = TRUE;
					break;

				case isc_dyn_fld_collation:
					{
						MetaName collation;
						GET_STRING(ptr, collation);

						if (!/*DBB.RDB$CHARACTER_SET_NAME.NULL*/
						     jrd_853.jrd_858)
						{
							AlterCharSetNode node(*tdbb->getDefaultPool(),
								/*DBB.RDB$CHARACTER_SET_NAME*/
								jrd_853.jrd_854, collation);
							node.execute(tdbb, gbl->gbl_transaction);
						}
					}
					break;

				default:
					--(*ptr);
					DYN_execute(gbl, ptr, NULL, NULL, NULL, NULL, NULL);
				}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_853.jrd_856, (char*) jrd_861.jrd_862, 32);
		jrd_861.jrd_863 = jrd_853.jrd_855;
		gds__vtov((const char*) jrd_853.jrd_854, (char*) jrd_861.jrd_864, 32);
		jrd_861.jrd_865 = jrd_853.jrd_860;
		jrd_861.jrd_866 = jrd_853.jrd_859;
		jrd_861.jrd_867 = jrd_853.jrd_858;
		EXE_send (tdbb, request, 1, 78, (UCHAR*) &jrd_861);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 2, 2, (UCHAR*) &jrd_868);
	   }
	}

	if (!DYN_REQUEST(drq_m_database))
		DYN_REQUEST(drq_m_database) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 84);
		// msg 84: "MODIFY DATABASE failed"
	}

	return;

dyn_punt_84:
	DYN_error_punt(true, 84);
	// msg 84: "MODIFY DATABASE failed"
}


void DYN_modify_exception( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_851;	// gds__utility 
   } jrd_850;
   struct {
          TEXT  jrd_846 [1024];	// RDB$MESSAGE 
          bid  jrd_847;	// RDB$DESCRIPTION 
          SSHORT jrd_848;	// gds__null_flag 
          SSHORT jrd_849;	// gds__null_flag 
   } jrd_845;
   struct {
          bid  jrd_840;	// RDB$DESCRIPTION 
          TEXT  jrd_841 [1024];	// RDB$MESSAGE 
          SSHORT jrd_842;	// gds__utility 
          SSHORT jrd_843;	// gds__null_flag 
          SSHORT jrd_844;	// gds__null_flag 
   } jrd_839;
   struct {
          TEXT  jrd_838 [32];	// RDB$EXCEPTION_NAME 
   } jrd_837;
/**************************************
 *
 *	D Y N _ m o d i f y _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Modify an exception.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_xcp, DYN_REQUESTS);
	bool found = false;

	try {

	MetaName t;
	GET_STRING(ptr, t);

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$EXCEPTIONS
			WITH X.RDB$EXCEPTION_NAME EQ t.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_836, sizeof(jrd_836), true);
	gds__vtov ((const char*) t.c_str(), (char*) jrd_837.jrd_838, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_837);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 1038, (UCHAR*) &jrd_839);
	   if (!jrd_839.jrd_842) break;

		if (!DYN_REQUEST(drq_m_xcp))
			DYN_REQUEST(drq_m_xcp) = request;

		found = true;
		/*MODIFY X*/
		{
		
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_xcp_msg:
					GET_BYTES(ptr, /*X.RDB$MESSAGE*/
						       jrd_839.jrd_841);
					/*X.RDB$MESSAGE.NULL*/
					jrd_839.jrd_844 = FALSE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
									 jrd_839.jrd_840))
						/*X.RDB$DESCRIPTION.NULL*/
						jrd_839.jrd_843 = FALSE;
					else
						/*X.RDB$DESCRIPTION.NULL*/
						jrd_839.jrd_843 = TRUE;
					break;

				default:
					DYN_unsupported_verb();
				}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_839.jrd_841, (char*) jrd_845.jrd_846, 1024);
		jrd_845.jrd_847 = jrd_839.jrd_840;
		jrd_845.jrd_848 = jrd_839.jrd_844;
		jrd_845.jrd_849 = jrd_839.jrd_843;
		EXE_send (tdbb, request, 2, 1036, (UCHAR*) &jrd_845);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_850);
	   }
	}

	if (!DYN_REQUEST(drq_m_xcp))
		DYN_REQUEST(drq_m_xcp) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 145);
		// msg 145: "MODIFY EXCEPTION failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 144);
		// msg 144: "Exception not found"
	}
}


// *********************************
// D Y N _ m o d i f y _ f i l t e r
// *********************************
// Its purpose is to change the comment in the filter's record.
void DYN_modify_filter(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_835;	// gds__utility 
   } jrd_834;
   struct {
          bid  jrd_832;	// RDB$DESCRIPTION 
          SSHORT jrd_833;	// gds__null_flag 
   } jrd_831;
   struct {
          bid  jrd_828;	// RDB$DESCRIPTION 
          SSHORT jrd_829;	// gds__utility 
          SSHORT jrd_830;	// gds__null_flag 
   } jrd_827;
   struct {
          TEXT  jrd_826 [32];	// RDB$FUNCTION_NAME 
   } jrd_825;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_bfil, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FILTERS
				WITH X.RDB$FUNCTION_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_824, sizeof(jrd_824), true);
		gds__vtov ((const char*) t, (char*) jrd_825.jrd_826, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_825);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 12, (UCHAR*) &jrd_827);
		   if (!jrd_827.jrd_829) break;

			if (!DYN_REQUEST(drq_m_bfil))
				DYN_REQUEST(drq_m_bfil) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_827.jrd_828))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_827.jrd_830 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_827.jrd_830 = TRUE;
						break;

					// Other cases should go there, like modifying the entry point or module name.
					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_831.jrd_832 = jrd_827.jrd_828;
			jrd_831.jrd_833 = jrd_827.jrd_830;
			EXE_send (tdbb, request, 2, 10, (UCHAR*) &jrd_831);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_834);
		   }
		}

		if (!DYN_REQUEST(drq_m_bfil))
			DYN_REQUEST(drq_m_bfil) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 88);
		// msg 88: "MODIFY RDB$BLOB_FILTERS failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 37, t);
		// msg 37: "Blob Filter %s not found"
	}
}


// *************************************
// D Y N _ m o d i f y _ f u n c t i o n
// *************************************
// Its purpose is to change the comment in the function's record and to
// allow changing the entry point and/or the module name.
void DYN_modify_function(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_823;	// gds__utility 
   } jrd_822;
   struct {
          bid  jrd_816;	// RDB$DESCRIPTION 
          TEXT  jrd_817 [256];	// RDB$MODULE_NAME 
          TEXT  jrd_818 [32];	// RDB$ENTRYPOINT 
          SSHORT jrd_819;	// gds__null_flag 
          SSHORT jrd_820;	// gds__null_flag 
          SSHORT jrd_821;	// gds__null_flag 
   } jrd_815;
   struct {
          TEXT  jrd_808 [32];	// RDB$ENTRYPOINT 
          TEXT  jrd_809 [256];	// RDB$MODULE_NAME 
          bid  jrd_810;	// RDB$DESCRIPTION 
          SSHORT jrd_811;	// gds__utility 
          SSHORT jrd_812;	// gds__null_flag 
          SSHORT jrd_813;	// gds__null_flag 
          SSHORT jrd_814;	// gds__null_flag 
   } jrd_807;
   struct {
          TEXT  jrd_806 [32];	// RDB$FUNCTION_NAME 
   } jrd_805;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_fun, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$FUNCTIONS
				WITH X.RDB$FUNCTION_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_804, sizeof(jrd_804), true);
		gds__vtov ((const char*) t, (char*) jrd_805.jrd_806, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_805);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 304, (UCHAR*) &jrd_807);
		   if (!jrd_807.jrd_811) break;

			if (!DYN_REQUEST(drq_m_fun))
				DYN_REQUEST(drq_m_fun) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_807.jrd_810))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_807.jrd_814 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_807.jrd_814 = TRUE;
						break;

					case isc_dyn_func_module_name:
						GET_STRING(ptr, /*X.RDB$MODULE_NAME*/
								jrd_807.jrd_809);
						/*X.RDB$MODULE_NAME.NULL*/
						jrd_807.jrd_813 = FALSE;
						break;

					case isc_dyn_func_entry_point:
						GET_STRING(ptr, /*X.RDB$ENTRYPOINT*/
								jrd_807.jrd_808);
						/*X.RDB$ENTRYPOINT.NULL*/
						jrd_807.jrd_812 = FALSE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_815.jrd_816 = jrd_807.jrd_810;
			gds__vtov((const char*) jrd_807.jrd_809, (char*) jrd_815.jrd_817, 256);
			gds__vtov((const char*) jrd_807.jrd_808, (char*) jrd_815.jrd_818, 32);
			jrd_815.jrd_819 = jrd_807.jrd_814;
			jrd_815.jrd_820 = jrd_807.jrd_813;
			jrd_815.jrd_821 = jrd_807.jrd_812;
			EXE_send (tdbb, request, 2, 302, (UCHAR*) &jrd_815);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_822);
		   }
		}

		if (!DYN_REQUEST(drq_m_fun))
			DYN_REQUEST(drq_m_fun) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 92);
		// msg 92: "MODIFY RDB$FUNCTIONS failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 41, t);
		// msg 41: "Function %s not found"
	}
}


// ***************************************
// D Y N _ m o d i f y _ g e n e r a t o r
// ***************************************
// Its purpose is to change the comment in the generator's record.
void DYN_modify_generator(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_803;	// gds__utility 
   } jrd_802;
   struct {
          bid  jrd_800;	// RDB$DESCRIPTION 
          SSHORT jrd_801;	// gds__null_flag 
   } jrd_799;
   struct {
          bid  jrd_796;	// RDB$DESCRIPTION 
          SSHORT jrd_797;	// gds__utility 
          SSHORT jrd_798;	// gds__null_flag 
   } jrd_795;
   struct {
          TEXT  jrd_794 [32];	// RDB$GENERATOR_NAME 
   } jrd_793;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_gen, DYN_REQUESTS);
	bool found = false;
	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$GENERATORS
				WITH X.RDB$GENERATOR_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_792, sizeof(jrd_792), true);
		gds__vtov ((const char*) t, (char*) jrd_793.jrd_794, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_793);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 12, (UCHAR*) &jrd_795);
		   if (!jrd_795.jrd_797) break;

			if (!DYN_REQUEST(drq_m_gen))
				DYN_REQUEST(drq_m_gen) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_795.jrd_796))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_795.jrd_798 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_795.jrd_798 = TRUE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_799.jrd_800 = jrd_795.jrd_796;
			jrd_799.jrd_801 = jrd_795.jrd_798;
			EXE_send (tdbb, request, 2, 10, (UCHAR*) &jrd_799);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_802);
		   }
		}

		if (!DYN_REQUEST(drq_m_gen))
			DYN_REQUEST(drq_m_gen) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 94);
		// msg 94: "MODIFY GENERATOR failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 214, t);
		// msg 214: "Generator %s not found"
	}
}


void DYN_modify_global_field(Global* gbl,
							 const UCHAR** ptr,
							 const MetaName* relation_name,
							 MetaName* field_name)
{
   struct {
          TEXT  jrd_680 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_681 [32];	// RDB$RELATION_NAME 
          SSHORT jrd_682;	// gds__utility 
   } jrd_679;
   struct {
          TEXT  jrd_678 [32];	// RDB$FIELD_SOURCE 
   } jrd_677;
   struct {
          SSHORT jrd_696;	// gds__utility 
   } jrd_695;
   struct {
          TEXT  jrd_693 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_694;	// gds__null_flag 
   } jrd_692;
   struct {
          TEXT  jrd_687 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_688 [32];	// RDB$RELATION_NAME 
          TEXT  jrd_689 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_690;	// gds__utility 
          SSHORT jrd_691;	// gds__null_flag 
   } jrd_686;
   struct {
          TEXT  jrd_685 [32];	// RDB$FIELD_SOURCE 
   } jrd_684;
   struct {
          SSHORT jrd_708;	// gds__utility 
   } jrd_707;
   struct {
          TEXT  jrd_705 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_706;	// gds__null_flag 
   } jrd_704;
   struct {
          TEXT  jrd_701 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_702;	// gds__utility 
          SSHORT jrd_703;	// gds__null_flag 
   } jrd_700;
   struct {
          TEXT  jrd_699 [32];	// RDB$FIELD_NAME 
   } jrd_698;
   struct {
          TEXT  jrd_790 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_791;	// gds__null_flag 
   } jrd_789;
   struct {
          SSHORT jrd_788;	// gds__utility 
   } jrd_787;
   struct {
          bid  jrd_753;	// RDB$VALIDATION_BLR 
          TEXT  jrd_754 [32];	// RDB$QUERY_NAME 
          bid  jrd_755;	// RDB$QUERY_HEADER 
          TEXT  jrd_756 [128];	// RDB$EDIT_STRING 
          bid  jrd_757;	// RDB$MISSING_VALUE 
          bid  jrd_758;	// RDB$VALIDATION_SOURCE 
          bid  jrd_759;	// RDB$DESCRIPTION 
          bid  jrd_760;	// RDB$DEFAULT_VALUE 
          bid  jrd_761;	// RDB$DEFAULT_SOURCE 
          SSHORT jrd_762;	// gds__null_flag 
          SSHORT jrd_763;	// RDB$FIELD_TYPE 
          SSHORT jrd_764;	// gds__null_flag 
          SSHORT jrd_765;	// RDB$FIELD_SCALE 
          SSHORT jrd_766;	// gds__null_flag 
          SSHORT jrd_767;	// RDB$FIELD_LENGTH 
          SSHORT jrd_768;	// gds__null_flag 
          SSHORT jrd_769;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_770;	// gds__null_flag 
          SSHORT jrd_771;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_772;	// gds__null_flag 
          SSHORT jrd_773;	// RDB$COLLATION_ID 
          SSHORT jrd_774;	// gds__null_flag 
          SSHORT jrd_775;	// RDB$FIELD_PRECISION 
          SSHORT jrd_776;	// gds__null_flag 
          SSHORT jrd_777;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_778;	// gds__null_flag 
          SSHORT jrd_779;	// gds__null_flag 
          SSHORT jrd_780;	// gds__null_flag 
          SSHORT jrd_781;	// gds__null_flag 
          SSHORT jrd_782;	// gds__null_flag 
          SSHORT jrd_783;	// gds__null_flag 
          SSHORT jrd_784;	// gds__null_flag 
          SSHORT jrd_785;	// gds__null_flag 
          SSHORT jrd_786;	// gds__null_flag 
   } jrd_752;
   struct {
          bid  jrd_713;	// RDB$DEFAULT_SOURCE 
          bid  jrd_714;	// RDB$DEFAULT_VALUE 
          bid  jrd_715;	// RDB$DESCRIPTION 
          bid  jrd_716;	// RDB$VALIDATION_SOURCE 
          bid  jrd_717;	// RDB$MISSING_VALUE 
          TEXT  jrd_718 [128];	// RDB$EDIT_STRING 
          bid  jrd_719;	// RDB$QUERY_HEADER 
          TEXT  jrd_720 [32];	// RDB$QUERY_NAME 
          bid  jrd_721;	// RDB$VALIDATION_BLR 
          TEXT  jrd_722 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_723;	// gds__utility 
          SSHORT jrd_724;	// gds__null_flag 
          SSHORT jrd_725;	// gds__null_flag 
          SSHORT jrd_726;	// gds__null_flag 
          SSHORT jrd_727;	// gds__null_flag 
          SSHORT jrd_728;	// gds__null_flag 
          SSHORT jrd_729;	// gds__null_flag 
          SSHORT jrd_730;	// gds__null_flag 
          SSHORT jrd_731;	// gds__null_flag 
          SSHORT jrd_732;	// gds__null_flag 
          SSHORT jrd_733;	// gds__null_flag 
          SSHORT jrd_734;	// gds__null_flag 
          SSHORT jrd_735;	// gds__null_flag 
          SSHORT jrd_736;	// gds__null_flag 
          SSHORT jrd_737;	// gds__null_flag 
          SSHORT jrd_738;	// gds__null_flag 
          SSHORT jrd_739;	// gds__null_flag 
          SSHORT jrd_740;	// gds__null_flag 
          SSHORT jrd_741;	// gds__null_flag 
          SSHORT jrd_742;	// RDB$DIMENSIONS 
          SSHORT jrd_743;	// RDB$NULL_FLAG 
          SSHORT jrd_744;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_745;	// RDB$FIELD_PRECISION 
          SSHORT jrd_746;	// RDB$COLLATION_ID 
          SSHORT jrd_747;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_748;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_749;	// RDB$FIELD_LENGTH 
          SSHORT jrd_750;	// RDB$FIELD_SCALE 
          SSHORT jrd_751;	// RDB$FIELD_TYPE 
   } jrd_712;
   struct {
          TEXT  jrd_711 [32];	// RDB$FIELD_NAME 
   } jrd_710;
/**************************************
 *
 *	D Y N _ m o d i f y _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement.
 * Note: a global field here is a SQL domain.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_gfield, DYN_REQUESTS);
	bool found = false;

	dyn_fld orig_dom, new_dom;

	try {

	bool dtype, scale, prec, subtype, charlen, collation, fldlen, nullflg, charset;
	dtype = scale = prec = subtype = charlen = collation = fldlen = nullflg = charset = false;

	bool bqryname, bqryhdr, bedtstr, bmissingval, bfldvald, bfldvaldsrc, bfielddesc,
		bdelvald, bdeldflt, bflddftval, bflddfltsrc;
	bqryname = bqryhdr = bedtstr = bmissingval = false;
	bfldvald = bfldvaldsrc = bfielddesc = bdelvald = bdeldflt = bflddftval = bflddfltsrc = false;

	const TEXT *qryname, *edtstr;
	const UCHAR *qryhdr, *missingval, *fldvald, *fldvaldsrc, *fielddesc, *flddftval, *flddfltsrc;

	GET_STRING(ptr, orig_dom.dyn_fld_name);

	found = false;
	int field_adjusted_count = 0;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME EQ orig_dom.dyn_fld_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_709, sizeof(jrd_709), true);
	gds__vtov ((const char*) orig_dom.dyn_fld_name.c_str(), (char*) jrd_710.jrd_711, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_710);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 306, (UCHAR*) &jrd_712);
	   if (!jrd_712.jrd_723) break;

		if (!DYN_REQUEST(drq_m_gfield))
			DYN_REQUEST(drq_m_gfield) = request;

		found = true;

		DSC_make_descriptor(&orig_dom.dyn_dsc,
							/*FLD.RDB$FIELD_TYPE*/
							jrd_712.jrd_751,
							/*FLD.RDB$FIELD_SCALE*/
							jrd_712.jrd_750,
							/*FLD.RDB$FIELD_LENGTH*/
							jrd_712.jrd_749,
							/*FLD.RDB$FIELD_SUB_TYPE*/
							jrd_712.jrd_748,
							/*FLD.RDB$CHARACTER_SET_ID*/
							jrd_712.jrd_747, /*FLD.RDB$COLLATION_ID*/
  jrd_712.jrd_746);

		orig_dom.dyn_charbytelen = /*FLD.RDB$FIELD_LENGTH*/
					   jrd_712.jrd_749;
		orig_dom.dyn_dtype = /*FLD.RDB$FIELD_TYPE*/
				     jrd_712.jrd_751;
		orig_dom.dyn_precision = /*FLD.RDB$FIELD_PRECISION*/
					 jrd_712.jrd_745;
		orig_dom.dyn_sub_type = /*FLD.RDB$FIELD_SUB_TYPE*/
					jrd_712.jrd_748;
		orig_dom.dyn_charlen = /*FLD.RDB$CHARACTER_LENGTH*/
				       jrd_712.jrd_744;
		orig_dom.dyn_collation = /*FLD.RDB$COLLATION_ID*/
					 jrd_712.jrd_746;
		orig_dom.dyn_null_flag = /*FLD.RDB$NULL_FLAG*/
					 jrd_712.jrd_743 != 0;

		/* If the original field type is an array, force its blr type to blr_blob */
		bool has_dimensions = false;
		if (/*FLD.RDB$DIMENSIONS*/
		    jrd_712.jrd_742 != 0)
		{
			orig_dom.dyn_dtype = blr_blob;
			has_dimensions = true;
		}

		bool single_validate = false;

		UCHAR verb;
		while ((verb = *(*ptr)++) != isc_dyn_end)
		{
			switch (verb)
			{
			case isc_dyn_fld_name:
				{
					MetaName newfld;

					if (GET_STRING(ptr, newfld))
					{
						if (!domain_exists(tdbb, gbl, newfld))
						{
							/*MODIFY FLD USING*/
							{
							
								strcpy(/*FLD.RDB$FIELD_NAME*/
								       jrd_712.jrd_722, newfld.c_str());
								/*FLD.RDB$FIELD_NAME.NULL*/
								jrd_712.jrd_741 = FALSE;
								jrd_req* old_request = request;
								request = NULL;
								/* CVC: Let's update the dimensions, too. */
								if (has_dimensions)
								{
									/*FOR (REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
										DIM_DOM IN RDB$FIELD_DIMENSIONS
										WITH DIM_DOM.RDB$FIELD_NAME EQ orig_dom.dyn_fld_name.c_str()*/
									{
									if (!request)
									   request = CMP_compile2 (tdbb, (UCHAR*) jrd_697, sizeof(jrd_697), true);
									gds__vtov ((const char*) orig_dom.dyn_fld_name.c_str(), (char*) jrd_698.jrd_699, 32);
									EXE_start (tdbb, request, gbl->gbl_transaction);
									EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_698);
									while (1)
									   {
									   EXE_receive (tdbb, request, 1, 36, (UCHAR*) &jrd_700);
									   if (!jrd_700.jrd_702) break;
										/*MODIFY DIM_DOM USING*/
										{
										
											strcpy (/*DIM_DOM.RDB$FIELD_NAME*/
												jrd_700.jrd_701, newfld.c_str());
											/*DIM_DOM.RDB$FIELD_NAME.NULL*/
											jrd_700.jrd_703 = FALSE;
										/*END_MODIFY;*/
										gds__vtov((const char*) jrd_700.jrd_701, (char*) jrd_704.jrd_705, 32);
										jrd_704.jrd_706 = jrd_700.jrd_703;
										EXE_send (tdbb, request, 2, 34, (UCHAR*) &jrd_704);
										}
									/*END_FOR;*/
									   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_707);
									   }
									}
									CMP_release (tdbb, request);
									request = NULL;
								}
								/* CVC: End modification. */
								/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
									DOM IN RDB$RELATION_FIELDS
									WITH DOM.RDB$FIELD_SOURCE EQ orig_dom.dyn_fld_name.c_str()*/
								{
								if (!request)
								   request = CMP_compile2 (tdbb, (UCHAR*) jrd_683, sizeof(jrd_683), true);
								gds__vtov ((const char*) orig_dom.dyn_fld_name.c_str(), (char*) jrd_684.jrd_685, 32);
								EXE_start (tdbb, request, gbl->gbl_transaction);
								EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_684);
								while (1)
								   {
								   EXE_receive (tdbb, request, 1, 100, (UCHAR*) &jrd_686);
								   if (!jrd_686.jrd_690) break;
									/*MODIFY DOM USING*/
									{
									
										strcpy(/*DOM.RDB$FIELD_SOURCE*/
										       jrd_686.jrd_689, newfld.c_str());
										/*DOM.RDB$FIELD_SOURCE.NULL*/
										jrd_686.jrd_691 = FALSE;
									/*END_MODIFY;*/
									gds__vtov((const char*) jrd_686.jrd_689, (char*) jrd_692.jrd_693, 32);
									jrd_692.jrd_694 = jrd_686.jrd_691;
									EXE_send (tdbb, request, 2, 34, (UCHAR*) &jrd_692);
									}
									modify_lfield_index(tdbb, gbl,
														/*DOM.RDB$RELATION_NAME*/
														jrd_686.jrd_688,
														/*DOM.RDB$FIELD_NAME*/
														jrd_686.jrd_687,
														/*DOM.RDB$FIELD_NAME*/
														jrd_686.jrd_687);
								/*END_FOR;*/
								   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_695);
								   }
								}
								CMP_release(tdbb, request);
								request = old_request;
							/*END_MODIFY;*/
							gds__vtov((const char*) jrd_712.jrd_722, (char*) jrd_789.jrd_790, 32);
							jrd_789.jrd_791 = jrd_712.jrd_741;
							EXE_send (tdbb, request, 4, 34, (UCHAR*) &jrd_789);
							}
						}
						else
						{
							DYN_error_punt(false, 204, SafeArg() << orig_dom.dyn_fld_name.c_str() <<
										   newfld.c_str());
							/* msg 204: Cannot rename domain %s to %s.  A domain with that name already exists. */
						}
					}
					else
					{
						DYN_error_punt(false, 212);
						/* msg 212: "Zero length identifiers not allowed" */
					}
					break;
				}

			case isc_dyn_rel_name:
				GET_STRING(ptr, new_dom.dyn_rel_name);
				break;

			/* CVC: The syntax for DDL alter domain was accepting multiple
					changes in one command even to the same features, IE two length alterations.
					This repetitive type change will cause havoc so it should be stopped in the future. */

			case isc_dyn_fld_length:
				fldlen = true;
				new_dom.dyn_dsc.dsc_length = DYN_get_number(ptr);
				if (++field_adjusted_count > 2)
				{
					EXE_unwind(tdbb, request);
					DYN_error_punt(false, 148, orig_dom.dyn_fld_name.c_str());
					// msg 148: "Only one data type change to the domain %s allowed at a time"
				}
				switch (new_dom.dyn_dtype)
				{

				case blr_text:
				case blr_text2:
				case blr_varying:
				case blr_varying2:
				case blr_cstring:
				case blr_cstring2:
					new_dom.dyn_charbytelen = new_dom.dyn_dsc.dsc_length;
					break;
				default:
					new_dom.dyn_charbytelen = 0; // It won't be used, anyway.
					break;
				}
				break;

			case isc_dyn_fld_type:
				dtype = true;
				new_dom.dyn_dtype = DYN_get_number(ptr);
				if (++field_adjusted_count > 2)
				{
					EXE_unwind(tdbb, request);
					DYN_error_punt(false, 148, orig_dom.dyn_fld_name.c_str());
					// msg 148: "Only one data type change to the domain %s allowed at a time"
				}

				switch (new_dom.dyn_dtype)
				{

				case blr_text:
				case blr_text2:
				case blr_varying:
				case blr_varying2:
				case blr_cstring:
				case blr_cstring2:
					if (new_dom.dyn_dsc.dsc_length && !new_dom.dyn_charbytelen)
						new_dom.dyn_charbytelen = new_dom.dyn_dsc.dsc_length;
					new_dom.dyn_dsc.dsc_length = DSC_string_length(&new_dom.dyn_dsc);
					break;
				case blr_short:
					new_dom.dyn_dsc.dsc_length = 2;
					break;

				case blr_long:
				case blr_float:
					new_dom.dyn_dsc.dsc_length = 4;
					break;

				case blr_int64:
				case blr_sql_time:
				case blr_sql_date:
				case blr_timestamp:
				case blr_double:
				case blr_d_float:
					new_dom.dyn_dsc.dsc_length = 8;
					break;

				default:
					break;
				}
				break;

			case isc_dyn_fld_scale:
				scale = true;
				new_dom.dyn_dsc.dsc_scale = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_precision:
				prec = true;
				new_dom.dyn_precision = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_sub_type:
				subtype = true;
				new_dom.dyn_sub_type = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_char_length:
				charlen = true;
				new_dom.dyn_charlen = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_collation:
				collation = true;
				new_dom.dyn_collation = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_character_set:
				charset = true;
				new_dom.dyn_charset = DYN_get_number(ptr);
				break;

			case isc_dyn_fld_not_null:
				nullflg = true;
				new_dom.dyn_null_flag = true;
				break;

			case isc_dyn_fld_query_name:
				qryname = (TEXT*) * ptr;
				bqryname = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_query_header:
				qryhdr = *ptr;
				bqryhdr = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_edit_string:
				edtstr = (TEXT*) * ptr;
				bedtstr = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_missing_value:
				missingval = *ptr;
				bmissingval = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_single_validation:
				if (single_validate) {
					EXE_unwind(tdbb, request);
					DYN_error_punt(false, 160);
					/* msg 160: "Only one constraint allowed for a domain" */
					break;
				}

				single_validate = true;
				break;

			case isc_dyn_fld_validation_blr:
				if (single_validate && (!/*FLD.RDB$VALIDATION_BLR.NULL*/
							 jrd_712.jrd_740)) {
					EXE_unwind(tdbb, request);
					DYN_error_punt(false, 160);
					/* msg 160: "Only one constraint allowed for a domain" */
					break;
				}

				single_validate = true;
				fldvald = *ptr;
				bfldvald = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_validation_source:
				fldvaldsrc = *ptr;
				bfldvaldsrc = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_description:
				fielddesc = *ptr;
				bfielddesc = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_del_validation:
				bdelvald = true;
				break;

			case isc_dyn_del_default:
				bdeldflt = true;
				break;

			case isc_dyn_fld_default_value:
				if (has_dimensions)
				{
					DYN_error_punt(false, 226, orig_dom.dyn_fld_name.c_str());
					// msg 226: "Default value is not allowed for array type in domain %s"
				}
				flddftval = *ptr;
				bflddftval = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_default_source:
				if (has_dimensions)
				{
					DYN_error_punt(false, 226, orig_dom.dyn_fld_name.c_str());
					// msg 226: "Default value is not allowed for array type in domain %s"
				}
				flddfltsrc = *ptr;
				bflddfltsrc = true;
				DYN_skip_attribute(ptr);
				break;

			case isc_dyn_fld_dimensions:
				new_dom.dyn_dtype = blr_blob;
				break;

				/* These should only be defined for BLOB types and should not come through with
				 * any other types.  Do nothing with them.
				 */

			case isc_dyn_fld_segment_length:
				DYN_get_number(ptr);
				break;

			default:
				--(*ptr);
				DYN_execute(gbl, ptr, relation_name, field_name, NULL, NULL, NULL);
			}
		}


		/* Now that we have all of the information needed, let's check to see if the field type can be modifed.
		 * Only do this, however, if we are actually modifying the datatype of the domain.
		 */

		if (dtype) {
			DSC_make_descriptor(&new_dom.dyn_dsc,
								new_dom.dyn_dtype,
								new_dom.dyn_dsc.dsc_scale,
								new_dom.dyn_dsc.dsc_length,
								new_dom.dyn_sub_type,
								new_dom.dyn_charset,
								new_dom.dyn_collation);
			const ULONG retval = check_update_fld_type(orig_dom, new_dom);
			if (retval != FB_SUCCESS)
				modify_err_punt(tdbb, retval, orig_dom, new_dom);
		}

		/*MODIFY FLD USING*/
		{
		
			if (dtype) {
				/*FLD.RDB$FIELD_TYPE*/
				jrd_712.jrd_751 = new_dom.dyn_dtype;
				/*FLD.RDB$FIELD_TYPE.NULL*/
				jrd_712.jrd_739 = FALSE;

				/* If the datatype was changed, update any indexes that involved the domain */

				jrd_req* old_request = request;
				request = NULL;
				/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
					DOM IN RDB$RELATION_FIELDS
					WITH DOM.RDB$FIELD_SOURCE EQ orig_dom.dyn_fld_name.c_str()*/
				{
				if (!request)
				   request = CMP_compile2 (tdbb, (UCHAR*) jrd_676, sizeof(jrd_676), true);
				gds__vtov ((const char*) orig_dom.dyn_fld_name.c_str(), (char*) jrd_677.jrd_678, 32);
				EXE_start (tdbb, request, gbl->gbl_transaction);
				EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_677);
				while (1)
				   {
				   EXE_receive (tdbb, request, 1, 66, (UCHAR*) &jrd_679);
				   if (!jrd_679.jrd_682) break;
					modify_lfield_index(tdbb, gbl,
										/*DOM.RDB$RELATION_NAME*/
										jrd_679.jrd_681,
										/*DOM.RDB$FIELD_NAME*/
										jrd_679.jrd_680,
										/*DOM.RDB$FIELD_NAME*/
										jrd_679.jrd_680);
				/*END_FOR;*/
				   }
				}

				CMP_release(tdbb, request);
				request = old_request;
			}

			if (scale) {
				/*FLD.RDB$FIELD_SCALE*/
				jrd_712.jrd_750 = new_dom.dyn_dsc.dsc_scale;
				/*FLD.RDB$FIELD_SCALE.NULL*/
				jrd_712.jrd_738 = FALSE;
			}

			if (prec) {
				/*FLD.RDB$FIELD_PRECISION*/
				jrd_712.jrd_745 = new_dom.dyn_precision;
				/*FLD.RDB$FIELD_PRECISION.NULL*/
				jrd_712.jrd_737 = FALSE;
			}

			if (subtype) {
				/*FLD.RDB$FIELD_SUB_TYPE*/
				jrd_712.jrd_748 = new_dom.dyn_sub_type;
				/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
				jrd_712.jrd_736 = FALSE;
			}

			if (charlen) {
				/*FLD.RDB$CHARACTER_LENGTH*/
				jrd_712.jrd_744 = new_dom.dyn_charlen;
				/*FLD.RDB$CHARACTER_LENGTH.NULL*/
				jrd_712.jrd_735 = FALSE;
			}

			if (charset) {
				/*FLD.RDB$CHARACTER_SET_ID*/
				jrd_712.jrd_747 = new_dom.dyn_charset;
				/*FLD.RDB$CHARACTER_SET_ID.NULL*/
				jrd_712.jrd_734 = FALSE;
			}

			if (collation) {
				/*FLD.RDB$COLLATION_ID*/
				jrd_712.jrd_746 = new_dom.dyn_collation;
				/*FLD.RDB$COLLATION_ID.NULL*/
				jrd_712.jrd_733 = FALSE;
			}

			if (fldlen) {
				/* CVC: Rescue from the wrong field_length with a helper. */
				if (new_dom.dyn_dsc.dsc_dtype <= dtype_varying && new_dom.dyn_charbytelen)
					/*FLD.RDB$FIELD_LENGTH*/
					jrd_712.jrd_749 = new_dom.dyn_charbytelen;
				else
					/*FLD.RDB$FIELD_LENGTH*/
					jrd_712.jrd_749 = new_dom.dyn_dsc.dsc_length;
				/*FLD.RDB$FIELD_LENGTH.NULL*/
				jrd_712.jrd_732 = FALSE;
			}

			if (bqryname) {
				if (GET_STRING(&qryname, /*FLD.RDB$QUERY_NAME*/
							 jrd_712.jrd_720))
					/*FLD.RDB$QUERY_NAME.NULL*/
					jrd_712.jrd_731 = FALSE;
				else
					/*FLD.RDB$QUERY_NAME.NULL*/
					jrd_712.jrd_731 = TRUE;
			}

			if (bqryhdr) {
				if (DYN_put_blr_blob(gbl, &qryhdr, &/*FLD.RDB$QUERY_HEADER*/
								    jrd_712.jrd_719))
					/*FLD.RDB$QUERY_HEADER.NULL*/
					jrd_712.jrd_730 = FALSE;
				else
					/*FLD.RDB$QUERY_HEADER.NULL*/
					jrd_712.jrd_730 = TRUE;
			}

			if (bedtstr) {
				if (GET_STRING(&edtstr, /*FLD.RDB$EDIT_STRING*/
							jrd_712.jrd_718))
					/*FLD.RDB$EDIT_STRING.NULL*/
					jrd_712.jrd_729 = FALSE;
				else
					/*FLD.RDB$EDIT_STRING.NULL*/
					jrd_712.jrd_729 = TRUE;
			}

			if (bmissingval) {
				if (DYN_put_blr_blob(gbl, &missingval, &/*FLD.RDB$MISSING_VALUE*/
									jrd_712.jrd_717))
					/*FLD.RDB$MISSING_VALUE.NULL*/
					jrd_712.jrd_728 = FALSE;
				else
					/*FLD.RDB$MISSING_VALUE.NULL*/
					jrd_712.jrd_728 = TRUE;
			}

			if (bfldvald) {
				if (DYN_put_blr_blob(gbl, &fldvald, &/*FLD.RDB$VALIDATION_BLR*/
								     jrd_712.jrd_721))
					/*FLD.RDB$VALIDATION_BLR.NULL*/
					jrd_712.jrd_740 = FALSE;
				else
					/*FLD.RDB$VALIDATION_BLR.NULL*/
					jrd_712.jrd_740 = TRUE;
			}

			if (bfldvaldsrc) {
				if (DYN_put_text_blob(gbl, &fldvaldsrc, &/*FLD.RDB$VALIDATION_SOURCE*/
									 jrd_712.jrd_716))
				{
					/*FLD.RDB$VALIDATION_SOURCE.NULL*/
					jrd_712.jrd_727 = FALSE;
				}
				else
					/*FLD.RDB$VALIDATION_SOURCE.NULL*/
					jrd_712.jrd_727 = TRUE;
			}

			if (bfielddesc) {
				if (DYN_put_text_blob(gbl, &fielddesc, &/*FLD.RDB$DESCRIPTION*/
									jrd_712.jrd_715))
					/*FLD.RDB$DESCRIPTION.NULL*/
					jrd_712.jrd_726 = FALSE;
				else
					/*FLD.RDB$DESCRIPTION.NULL*/
					jrd_712.jrd_726 = TRUE;
			}

			if (bdelvald) {
				/*FLD.RDB$VALIDATION_BLR.NULL*/
				jrd_712.jrd_740 = TRUE;
				/*FLD.RDB$VALIDATION_SOURCE.NULL*/
				jrd_712.jrd_727 = TRUE;
			}

			if (bdeldflt) {
				/*FLD.RDB$DEFAULT_VALUE.NULL*/
				jrd_712.jrd_725 = TRUE;
				/*FLD.RDB$DEFAULT_SOURCE.NULL*/
				jrd_712.jrd_724 = TRUE;
			}

			if (bflddftval) {
				if (DYN_put_blr_blob(gbl, &flddftval, &/*FLD.RDB$DEFAULT_VALUE*/
								       jrd_712.jrd_714))
					/*FLD.RDB$DEFAULT_VALUE.NULL*/
					jrd_712.jrd_725 = FALSE;
				else
					/*FLD.RDB$DEFAULT_VALUE.NULL*/
					jrd_712.jrd_725 = TRUE;
			}

			if (bflddfltsrc) {
				if (DYN_put_text_blob(gbl, &flddfltsrc, &/*FLD.RDB$DEFAULT_SOURCE*/
									 jrd_712.jrd_713))
					/*FLD.RDB$DEFAULT_SOURCE.NULL*/
					jrd_712.jrd_724 = FALSE;
				else
					/*FLD.RDB$DEFAULT_SOURCE.NULL*/
					jrd_712.jrd_724 = TRUE;
			}

		/*END_MODIFY;*/
		jrd_752.jrd_753 = jrd_712.jrd_721;
		gds__vtov((const char*) jrd_712.jrd_720, (char*) jrd_752.jrd_754, 32);
		jrd_752.jrd_755 = jrd_712.jrd_719;
		gds__vtov((const char*) jrd_712.jrd_718, (char*) jrd_752.jrd_756, 128);
		jrd_752.jrd_757 = jrd_712.jrd_717;
		jrd_752.jrd_758 = jrd_712.jrd_716;
		jrd_752.jrd_759 = jrd_712.jrd_715;
		jrd_752.jrd_760 = jrd_712.jrd_714;
		jrd_752.jrd_761 = jrd_712.jrd_713;
		jrd_752.jrd_762 = jrd_712.jrd_739;
		jrd_752.jrd_763 = jrd_712.jrd_751;
		jrd_752.jrd_764 = jrd_712.jrd_738;
		jrd_752.jrd_765 = jrd_712.jrd_750;
		jrd_752.jrd_766 = jrd_712.jrd_732;
		jrd_752.jrd_767 = jrd_712.jrd_749;
		jrd_752.jrd_768 = jrd_712.jrd_736;
		jrd_752.jrd_769 = jrd_712.jrd_748;
		jrd_752.jrd_770 = jrd_712.jrd_734;
		jrd_752.jrd_771 = jrd_712.jrd_747;
		jrd_752.jrd_772 = jrd_712.jrd_733;
		jrd_752.jrd_773 = jrd_712.jrd_746;
		jrd_752.jrd_774 = jrd_712.jrd_737;
		jrd_752.jrd_775 = jrd_712.jrd_745;
		jrd_752.jrd_776 = jrd_712.jrd_735;
		jrd_752.jrd_777 = jrd_712.jrd_744;
		jrd_752.jrd_778 = jrd_712.jrd_740;
		jrd_752.jrd_779 = jrd_712.jrd_731;
		jrd_752.jrd_780 = jrd_712.jrd_730;
		jrd_752.jrd_781 = jrd_712.jrd_729;
		jrd_752.jrd_782 = jrd_712.jrd_728;
		jrd_752.jrd_783 = jrd_712.jrd_727;
		jrd_752.jrd_784 = jrd_712.jrd_726;
		jrd_752.jrd_785 = jrd_712.jrd_725;
		jrd_752.jrd_786 = jrd_712.jrd_724;
		EXE_send (tdbb, request, 2, 266, (UCHAR*) &jrd_752);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_787);
	   }
	}

	if (!DYN_REQUEST(drq_m_gfield))
		DYN_REQUEST(drq_m_gfield) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 87);
		/* msg 87: "MODIFY RDB$FIELDS failed" */
	}

	if (!found)
	{
		DYN_error_punt(false, 89);
		/* msg 89: "Global field not found" */
	}
}


void DYN_modify_index( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_675;	// gds__utility 
   } jrd_674;
   struct {
          bid  jrd_666;	// RDB$DESCRIPTION 
          double  jrd_667;	// RDB$STATISTICS 
          SSHORT jrd_668;	// gds__null_flag 
          SSHORT jrd_669;	// RDB$UNIQUE_FLAG 
          SSHORT jrd_670;	// gds__null_flag 
          SSHORT jrd_671;	// RDB$INDEX_INACTIVE 
          SSHORT jrd_672;	// gds__null_flag 
          SSHORT jrd_673;	// gds__null_flag 
   } jrd_665;
   struct {
          double  jrd_656;	// RDB$STATISTICS 
          bid  jrd_657;	// RDB$DESCRIPTION 
          SSHORT jrd_658;	// gds__utility 
          SSHORT jrd_659;	// gds__null_flag 
          SSHORT jrd_660;	// gds__null_flag 
          SSHORT jrd_661;	// gds__null_flag 
          SSHORT jrd_662;	// RDB$INDEX_INACTIVE 
          SSHORT jrd_663;	// gds__null_flag 
          SSHORT jrd_664;	// RDB$UNIQUE_FLAG 
   } jrd_655;
   struct {
          TEXT  jrd_654 [32];	// RDB$INDEX_NAME 
   } jrd_653;
/**************************************
 *
 *	D Y N _ m o d i f y _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Modify an existing index
 *
 **************************************/
	MetaName name;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_index, DYN_REQUESTS);
	bool found = false;

	try {

	GET_STRING(ptr, name);

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_652, sizeof(jrd_652), true);
	gds__vtov ((const char*) name.c_str(), (char*) jrd_653.jrd_654, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_653);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 30, (UCHAR*) &jrd_655);
	   if (!jrd_655.jrd_658) break;

		if (!DYN_REQUEST(drq_m_index))
			DYN_REQUEST(drq_m_index) = request;

		found = true;
		/*MODIFY IDX USING*/
		{
		
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_idx_unique:
					/*IDX.RDB$UNIQUE_FLAG*/
					jrd_655.jrd_664 = DYN_get_number(ptr);
					/*IDX.RDB$UNIQUE_FLAG.NULL*/
					jrd_655.jrd_663 = FALSE;
					break;

				case isc_dyn_idx_inactive:
					/*IDX.RDB$INDEX_INACTIVE*/
					jrd_655.jrd_662 = DYN_get_number(ptr);
					/*IDX.RDB$INDEX_INACTIVE.NULL*/
					jrd_655.jrd_661 = FALSE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*IDX.RDB$DESCRIPTION*/
									 jrd_655.jrd_657))
						/*IDX.RDB$DESCRIPTION.NULL*/
						jrd_655.jrd_660 = FALSE;
					else
						/*IDX.RDB$DESCRIPTION.NULL*/
						jrd_655.jrd_660 = TRUE;
					break;

					/* For V4 index selectivity can be set only to -1 */

				case isc_dyn_idx_statistic:
					/*IDX.RDB$STATISTICS*/
					jrd_655.jrd_656 = -1.0;
					/*IDX.RDB$STATISTICS.NULL*/
					jrd_655.jrd_659 = FALSE;
					break;

				default:
					DYN_unsupported_verb();
				}
		/*END_MODIFY;*/
		jrd_665.jrd_666 = jrd_655.jrd_657;
		jrd_665.jrd_667 = jrd_655.jrd_656;
		jrd_665.jrd_668 = jrd_655.jrd_663;
		jrd_665.jrd_669 = jrd_655.jrd_664;
		jrd_665.jrd_670 = jrd_655.jrd_661;
		jrd_665.jrd_671 = jrd_655.jrd_662;
		jrd_665.jrd_672 = jrd_655.jrd_660;
		jrd_665.jrd_673 = jrd_655.jrd_659;
		EXE_send (tdbb, request, 2, 28, (UCHAR*) &jrd_665);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_674);
	   }
	}

	if (!DYN_REQUEST(drq_m_index))
		DYN_REQUEST(drq_m_index) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 91);
		// msg 91: "MODIFY RDB$INDICES failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 48);
		/* msg 48: "Index not found" */
	}
}


void DYN_modify_local_field(Global* gbl,
							const UCHAR** ptr,
							const MetaName* relation_name)
{
   struct {
          SSHORT jrd_651;	// gds__utility 
   } jrd_650;
   struct {
          TEXT  jrd_635 [32];	// RDB$QUERY_NAME 
          TEXT  jrd_636 [32];	// RDB$FIELD_NAME 
          bid  jrd_637;	// RDB$QUERY_HEADER 
          TEXT  jrd_638 [128];	// RDB$EDIT_STRING 
          TEXT  jrd_639 [32];	// RDB$SECURITY_CLASS 
          TEXT  jrd_640 [32];	// RDB$FIELD_SOURCE 
          bid  jrd_641;	// RDB$DESCRIPTION 
          SSHORT jrd_642;	// RDB$FIELD_POSITION 
          SSHORT jrd_643;	// gds__null_flag 
          SSHORT jrd_644;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_645;	// gds__null_flag 
          SSHORT jrd_646;	// gds__null_flag 
          SSHORT jrd_647;	// gds__null_flag 
          SSHORT jrd_648;	// gds__null_flag 
          SSHORT jrd_649;	// gds__null_flag 
   } jrd_634;
   struct {
          bid  jrd_618;	// RDB$DESCRIPTION 
          TEXT  jrd_619 [32];	// RDB$FIELD_SOURCE 
          TEXT  jrd_620 [32];	// RDB$SECURITY_CLASS 
          TEXT  jrd_621 [128];	// RDB$EDIT_STRING 
          bid  jrd_622;	// RDB$QUERY_HEADER 
          TEXT  jrd_623 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_624 [32];	// RDB$QUERY_NAME 
          SSHORT jrd_625;	// gds__utility 
          SSHORT jrd_626;	// gds__null_flag 
          SSHORT jrd_627;	// gds__null_flag 
          SSHORT jrd_628;	// gds__null_flag 
          SSHORT jrd_629;	// gds__null_flag 
          SSHORT jrd_630;	// gds__null_flag 
          SSHORT jrd_631;	// gds__null_flag 
          SSHORT jrd_632;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_633;	// RDB$FIELD_POSITION 
   } jrd_617;
   struct {
          TEXT  jrd_615 [32];	// RDB$RELATION_NAME 
          TEXT  jrd_616 [32];	// RDB$FIELD_NAME 
   } jrd_614;
/**************************************
 *
 *	D Y N _ m o d i f y _ l o c a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement.
 *
 **************************************/
	USHORT position;
	MetaName f, r;
	const UCHAR* query_name;
	const UCHAR* edit_string;
	const UCHAR* security_class;
	const UCHAR* new_name;
	const UCHAR* query_header;
	const UCHAR* description;
	const UCHAR* new_source = NULL;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	GET_STRING(ptr, f);

	bool sfflag, qnflag, qhflag, esflag, dflag, system_flag, scflag, nnflag, ntflag, npflag;
	sfflag = qnflag = qhflag = esflag = dflag = scflag = npflag = nnflag = ntflag = false;

	UCHAR verb;
	while ((verb = *(*ptr)++) != isc_dyn_end)
		switch (verb)
		{
		case isc_dyn_rel_name:
			GET_STRING(ptr, r);
			break;

		case isc_dyn_system_flag:
			system_flag = DYN_get_number(ptr);
			sfflag = true;
			break;

		case isc_dyn_fld_position:
			position = DYN_get_number(ptr);
			npflag = true;
			break;

		case isc_dyn_new_fld_name:
			new_name = *ptr;
			nnflag = true;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_fld_query_name:
			query_name = *ptr;
			qnflag = true;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_fld_query_header:
			query_header = *ptr;
			qhflag = true;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_fld_edit_string:
			edit_string = *ptr;
			esflag = true;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_security_class:
			security_class = *ptr;
			scflag = true;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_fld_source:
			new_source = *ptr;
			DYN_skip_attribute(ptr);
			break;

		case isc_dyn_description:
			description = *ptr;
			dflag = true;
			DYN_skip_attribute(ptr);
			break;

		default:
			--(*ptr);
			DYN_execute(gbl, ptr, relation_name, NULL, NULL, NULL, NULL);
		}

	jrd_req* request = CMP_find_request(tdbb, drq_m_lfield, DYN_REQUESTS);
	bool found = false;

	try {

	USHORT existing_position;
	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$RELATION_FIELDS
			WITH FLD.RDB$FIELD_NAME EQ f.c_str()
			 AND FLD.RDB$RELATION_NAME EQ r.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_613, sizeof(jrd_613), true);
	gds__vtov ((const char*) r.c_str(), (char*) jrd_614.jrd_615, 32);
	gds__vtov ((const char*) f.c_str(), (char*) jrd_614.jrd_616, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_614);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 290, (UCHAR*) &jrd_617);
	   if (!jrd_617.jrd_625) break;

		if (!DYN_REQUEST(drq_m_lfield))
			DYN_REQUEST(drq_m_lfield) = request;

		found = true;

		/*MODIFY FLD USING*/
		{
		
			if (npflag)
				existing_position = /*FLD.RDB$FIELD_POSITION*/
						    jrd_617.jrd_633;

			if (sfflag) {
				/*FLD.RDB$SYSTEM_FLAG*/
				jrd_617.jrd_632 = system_flag;
				/*FLD.RDB$SYSTEM_FLAG.NULL*/
				jrd_617.jrd_631 = FALSE;
			}
			if (qnflag) {
				if (GET_STRING(&query_name, /*FLD.RDB$QUERY_NAME*/
							    jrd_617.jrd_624))
					/*FLD.RDB$QUERY_NAME.NULL*/
					jrd_617.jrd_630 = FALSE;
				else
					/*FLD.RDB$QUERY_NAME.NULL*/
					jrd_617.jrd_630 = TRUE;
			}

			if (nnflag) {
				MetaName new_fld;
				GET_STRING(&new_name, new_fld);
				if (new_fld.length() == 0)
				{
					DYN_error_punt(false, 212);
					/* msg 212: "Zero length identifiers not allowed" */
				}

				check_view_dependency(tdbb, gbl, r, f);
				check_sptrig_dependency(tdbb, gbl, r, f);
				if (!field_exists(tdbb, gbl, r, new_fld)) {
					strcpy(/*FLD.RDB$FIELD_NAME*/
					       jrd_617.jrd_623, new_fld.c_str());
					modify_lfield_index(tdbb, gbl, r, f, /*FLD.RDB$FIELD_NAME*/
									     jrd_617.jrd_623);
				}
				else {
					DYN_error_punt(false, 205, SafeArg() << f.c_str() << new_fld.c_str() <<
									r.c_str());
					/* msg 205: Cannot rename field %s to %s.  A field with that name already exists in table %s. */
				}
			}

			if (qhflag) {
				if (DYN_put_blr_blob(gbl, &query_header, &/*FLD.RDB$QUERY_HEADER*/
									  jrd_617.jrd_622))
					/*FLD.RDB$QUERY_HEADER.NULL*/
					jrd_617.jrd_629 = FALSE;
				else
					/*FLD.RDB$QUERY_HEADER.NULL*/
					jrd_617.jrd_629 = TRUE;
			}
			if (esflag) {
				if (GET_STRING(&edit_string, /*FLD.RDB$EDIT_STRING*/
							     jrd_617.jrd_621))
					/*FLD.RDB$EDIT_STRING.NULL*/
					jrd_617.jrd_628 = FALSE;
				else
					/*FLD.RDB$EDIT_STRING.NULL*/
					jrd_617.jrd_628 = TRUE;
			}
			if (scflag) {
				if (GET_STRING(&security_class, /*FLD.RDB$SECURITY_CLASS*/
								jrd_617.jrd_620))
					/*FLD.RDB$SECURITY_CLASS.NULL*/
					jrd_617.jrd_627 = FALSE;
				else
					/*FLD.RDB$SECURITY_CLASS.NULL*/
					jrd_617.jrd_627 = TRUE;
			}

			if (new_source)
				GET_STRING(&new_source, /*FLD.RDB$FIELD_SOURCE*/
							jrd_617.jrd_619);

			if (dflag) {
				if (DYN_put_text_blob(gbl, &description, &/*FLD.RDB$DESCRIPTION*/
									  jrd_617.jrd_618))
					/*FLD.RDB$DESCRIPTION.NULL*/
					jrd_617.jrd_626 = FALSE;
				else
					/*FLD.RDB$DESCRIPTION.NULL*/
					jrd_617.jrd_626 = TRUE;
			}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_617.jrd_624, (char*) jrd_634.jrd_635, 32);
		gds__vtov((const char*) jrd_617.jrd_623, (char*) jrd_634.jrd_636, 32);
		jrd_634.jrd_637 = jrd_617.jrd_622;
		gds__vtov((const char*) jrd_617.jrd_621, (char*) jrd_634.jrd_638, 128);
		gds__vtov((const char*) jrd_617.jrd_620, (char*) jrd_634.jrd_639, 32);
		gds__vtov((const char*) jrd_617.jrd_619, (char*) jrd_634.jrd_640, 32);
		jrd_634.jrd_641 = jrd_617.jrd_618;
		jrd_634.jrd_642 = jrd_617.jrd_633;
		jrd_634.jrd_643 = jrd_617.jrd_631;
		jrd_634.jrd_644 = jrd_617.jrd_632;
		jrd_634.jrd_645 = jrd_617.jrd_630;
		jrd_634.jrd_646 = jrd_617.jrd_629;
		jrd_634.jrd_647 = jrd_617.jrd_628;
		jrd_634.jrd_648 = jrd_617.jrd_627;
		jrd_634.jrd_649 = jrd_617.jrd_626;
		EXE_send (tdbb, request, 2, 288, (UCHAR*) &jrd_634);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_650);
	   }
	}

	if (!DYN_REQUEST(drq_m_lfield))
		DYN_REQUEST(drq_m_lfield) = request;

	if (npflag && found && position != existing_position)
		modify_lfield_position(tdbb, gbl, r, f, position, existing_position);
	} // try
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 95);
		/* msg 95: "MODIFY RDB$RELATION_FIELDS failed" */
	}

	if (!found)
	{
		DYN_error_punt(false, 176, SafeArg() << f.c_str() << r.c_str());
		// msg 176: "column %s does not exist in table/view %s"
	}
}


// Modifies a procedure parameter.
void DYN_modify_parameter(Global* gbl, const UCHAR** ptr)
{
   struct {
          bid  jrd_611;	// RDB$DESCRIPTION 
          SSHORT jrd_612;	// gds__null_flag 
   } jrd_610;
   struct {
          bid  jrd_596;	// RDB$DEFAULT_VALUE 
          bid  jrd_597;	// RDB$DEFAULT_SOURCE 
          SSHORT jrd_598;	// gds__null_flag 
          SSHORT jrd_599;	// RDB$PARAMETER_NUMBER 
          SSHORT jrd_600;	// gds__null_flag 
          SSHORT jrd_601;	// RDB$PARAMETER_TYPE 
          SSHORT jrd_602;	// gds__null_flag 
          SSHORT jrd_603;	// gds__null_flag 
          SSHORT jrd_604;	// gds__null_flag 
          SSHORT jrd_605;	// RDB$COLLATION_ID 
          SSHORT jrd_606;	// gds__null_flag 
          SSHORT jrd_607;	// RDB$NULL_FLAG 
          SSHORT jrd_608;	// gds__null_flag 
          SSHORT jrd_609;	// RDB$PARAMETER_MECHANISM 
   } jrd_595;
   struct {
          SSHORT jrd_594;	// gds__utility 
   } jrd_593;
   struct {
          bid  jrd_569;	// RDB$DEFAULT_VALUE 
          bid  jrd_570;	// RDB$DEFAULT_SOURCE 
          SSHORT jrd_571;	// gds__null_flag 
          SSHORT jrd_572;	// gds__null_flag 
          SSHORT jrd_573;	// gds__null_flag 
          SSHORT jrd_574;	// RDB$FIELD_LENGTH 
          SSHORT jrd_575;	// gds__null_flag 
          SSHORT jrd_576;	// RDB$FIELD_SCALE 
          SSHORT jrd_577;	// gds__null_flag 
          SSHORT jrd_578;	// RDB$FIELD_TYPE 
          SSHORT jrd_579;	// gds__null_flag 
          SSHORT jrd_580;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_581;	// gds__null_flag 
          SSHORT jrd_582;	// RDB$SEGMENT_LENGTH 
          SSHORT jrd_583;	// gds__null_flag 
          SSHORT jrd_584;	// RDB$NULL_FLAG 
          SSHORT jrd_585;	// gds__null_flag 
          SSHORT jrd_586;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_587;	// gds__null_flag 
          SSHORT jrd_588;	// RDB$COLLATION_ID 
          SSHORT jrd_589;	// gds__null_flag 
          SSHORT jrd_590;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_591;	// gds__null_flag 
          SSHORT jrd_592;	// RDB$FIELD_PRECISION 
   } jrd_568;
   struct {
          bid  jrd_527;	// RDB$DEFAULT_SOURCE 
          bid  jrd_528;	// RDB$DEFAULT_VALUE 
          bid  jrd_529;	// RDB$DEFAULT_SOURCE 
          bid  jrd_530;	// RDB$DEFAULT_VALUE 
          bid  jrd_531;	// RDB$DESCRIPTION 
          SSHORT jrd_532;	// gds__utility 
          SSHORT jrd_533;	// gds__null_flag 
          SSHORT jrd_534;	// RDB$FIELD_PRECISION 
          SSHORT jrd_535;	// gds__null_flag 
          SSHORT jrd_536;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_537;	// gds__null_flag 
          SSHORT jrd_538;	// RDB$COLLATION_ID 
          SSHORT jrd_539;	// gds__null_flag 
          SSHORT jrd_540;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_541;	// gds__null_flag 
          SSHORT jrd_542;	// RDB$NULL_FLAG 
          SSHORT jrd_543;	// gds__null_flag 
          SSHORT jrd_544;	// RDB$SEGMENT_LENGTH 
          SSHORT jrd_545;	// gds__null_flag 
          SSHORT jrd_546;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_547;	// gds__null_flag 
          SSHORT jrd_548;	// RDB$FIELD_TYPE 
          SSHORT jrd_549;	// gds__null_flag 
          SSHORT jrd_550;	// RDB$FIELD_SCALE 
          SSHORT jrd_551;	// gds__null_flag 
          SSHORT jrd_552;	// RDB$FIELD_LENGTH 
          SSHORT jrd_553;	// gds__null_flag 
          SSHORT jrd_554;	// gds__null_flag 
          SSHORT jrd_555;	// gds__null_flag 
          SSHORT jrd_556;	// RDB$PARAMETER_MECHANISM 
          SSHORT jrd_557;	// gds__null_flag 
          SSHORT jrd_558;	// RDB$NULL_FLAG 
          SSHORT jrd_559;	// gds__null_flag 
          SSHORT jrd_560;	// RDB$COLLATION_ID 
          SSHORT jrd_561;	// gds__null_flag 
          SSHORT jrd_562;	// gds__null_flag 
          SSHORT jrd_563;	// gds__null_flag 
          SSHORT jrd_564;	// RDB$PARAMETER_TYPE 
          SSHORT jrd_565;	// gds__null_flag 
          SSHORT jrd_566;	// RDB$PARAMETER_NUMBER 
          SSHORT jrd_567;	// gds__null_flag 
   } jrd_526;
   struct {
          TEXT  jrd_524 [32];	// RDB$PROCEDURE_NAME 
          TEXT  jrd_525 [32];	// RDB$PARAMETER_NAME 
   } jrd_523;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_prm, DYN_REQUESTS);
	bool found = false;

	SqlIdentifier t;
	GET_STRING(ptr, t);
	SqlIdentifier p;

	try
	{
		if (**ptr == isc_dyn_prc_name)
		{
			++*ptr;
			GET_STRING(ptr, p);
		}
		else
			DYN_unsupported_verb();

		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			PRM IN RDB$PROCEDURE_PARAMETERS CROSS
			FLD IN RDB$FIELDS
			WITH PRM.RDB$PARAMETER_NAME EQ t AND
				 PRM.RDB$PROCEDURE_NAME EQ p AND
				 FLD.RDB$FIELD_NAME EQ PRM.RDB$FIELD_SOURCE*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_522, sizeof(jrd_522), true);
		gds__vtov ((const char*) p, (char*) jrd_523.jrd_524, 32);
		gds__vtov ((const char*) t, (char*) jrd_523.jrd_525, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_523);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 112, (UCHAR*) &jrd_526);
		   if (!jrd_526.jrd_532) break;
		{
			if (!DYN_REQUEST(drq_m_prm))
				DYN_REQUEST(drq_m_prm) = request;

			found = true;

			if (**ptr == isc_dyn_description)
			{
				/*MODIFY PRM*/
				{
				
					++*ptr;
					if (DYN_put_text_blob(gbl, ptr, &/*PRM.RDB$DESCRIPTION*/
									 jrd_526.jrd_531))
						/*PRM.RDB$DESCRIPTION.NULL*/
						jrd_526.jrd_567 = FALSE;
					else
						/*PRM.RDB$DESCRIPTION.NULL*/
						jrd_526.jrd_567 = TRUE;

					fb_assert(**ptr == isc_dyn_end)
				/*END_MODIFY*/
				jrd_610.jrd_611 = jrd_526.jrd_531;
				jrd_610.jrd_612 = jrd_526.jrd_567;
				EXE_send (tdbb, request, 5, 10, (UCHAR*) &jrd_610);
				}
			}
			else
			{
				/*MODIFY PRM*/
				{
				 /*MODIFY FLD*/
 {
 
				{
					/*PRM.RDB$PARAMETER_NUMBER.NULL*/
					jrd_526.jrd_565 = TRUE;
					/*PRM.RDB$PARAMETER_TYPE.NULL*/
					jrd_526.jrd_563 = TRUE;
					/*PRM.RDB$DEFAULT_VALUE.NULL*/
					jrd_526.jrd_562 = TRUE;
					/*PRM.RDB$DEFAULT_SOURCE.NULL*/
					jrd_526.jrd_561 = TRUE;
					/*PRM.RDB$COLLATION_ID.NULL*/
					jrd_526.jrd_559 = TRUE;
					/*PRM.RDB$NULL_FLAG.NULL*/
					jrd_526.jrd_557 = TRUE;
					/*PRM.RDB$PARAMETER_MECHANISM.NULL*/
					jrd_526.jrd_555 = TRUE;

					/*FLD.RDB$DEFAULT_VALUE.NULL*/
					jrd_526.jrd_554 = TRUE;
					/*FLD.RDB$DEFAULT_SOURCE.NULL*/
					jrd_526.jrd_553 = TRUE;
					/*FLD.RDB$FIELD_LENGTH.NULL*/
					jrd_526.jrd_551 = TRUE;
					/*FLD.RDB$FIELD_SCALE.NULL*/
					jrd_526.jrd_549 = TRUE;
					/*FLD.RDB$FIELD_TYPE.NULL*/
					jrd_526.jrd_547 = TRUE;
					/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
					jrd_526.jrd_545 = TRUE;
					/*FLD.RDB$SEGMENT_LENGTH.NULL*/
					jrd_526.jrd_543 = TRUE;
					/*FLD.RDB$NULL_FLAG.NULL*/
					jrd_526.jrd_541 = TRUE;
					/*FLD.RDB$CHARACTER_LENGTH.NULL*/
					jrd_526.jrd_539 = TRUE;
					/*FLD.RDB$COLLATION_ID.NULL*/
					jrd_526.jrd_537 = TRUE;
					/*FLD.RDB$CHARACTER_SET_ID.NULL*/
					jrd_526.jrd_535 = TRUE;
					/*FLD.RDB$FIELD_PRECISION.NULL*/
					jrd_526.jrd_533 = TRUE;

					UCHAR verb;
					while ((verb = *(*ptr)++) != isc_dyn_end)
					{
						switch (verb)
						{
						case isc_dyn_prm_number:
							/*PRM.RDB$PARAMETER_NUMBER*/
							jrd_526.jrd_566 = (SSHORT) DYN_get_number(ptr);
							/*PRM.RDB$PARAMETER_NUMBER.NULL*/
							jrd_526.jrd_565 = FALSE;
							break;

						case isc_dyn_prm_type:
							/*PRM.RDB$PARAMETER_TYPE*/
							jrd_526.jrd_564 = (SSHORT) DYN_get_number(ptr);
							/*PRM.RDB$PARAMETER_TYPE.NULL*/
							jrd_526.jrd_563 = FALSE;
							break;

						case isc_dyn_fld_not_null:
							if (ENCODE_ODS(dbb->dbb_ods_version, dbb->dbb_minor_original) < ODS_11_1)
							{
								// Feature not supported on ODS version older than %d.%d
								ERR_post(Arg::Gds(isc_dsql_feature_not_supported_ods) <<
									Arg::Num(11) << Arg::Num(1));
							}

							/*PRM.RDB$NULL_FLAG*/
							jrd_526.jrd_558 = TRUE;
							/*PRM.RDB$NULL_FLAG.NULL*/
							jrd_526.jrd_557 = FALSE;
							break;

						case isc_dyn_fld_length:
							/*FLD.RDB$FIELD_LENGTH*/
							jrd_526.jrd_552 = (USHORT) DYN_get_number(ptr);
							/*FLD.RDB$FIELD_LENGTH.NULL*/
							jrd_526.jrd_551 = FALSE;
							break;

						case isc_dyn_fld_type:
							/*FLD.RDB$FIELD_TYPE*/
							jrd_526.jrd_548 = (USHORT) DYN_get_number(ptr);
							/*FLD.RDB$FIELD_TYPE.NULL*/
							jrd_526.jrd_547 = FALSE;

							switch (/*FLD.RDB$FIELD_TYPE*/
								jrd_526.jrd_548)
							{
							case blr_short:
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_526.jrd_552 = 2;
								/*FLD.RDB$FIELD_LENGTH.NULL*/
								jrd_526.jrd_551 = FALSE;
								break;

							case blr_long:
							case blr_float:
							case blr_sql_time:
							case blr_sql_date:
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_526.jrd_552 = 4;
								/*FLD.RDB$FIELD_LENGTH.NULL*/
								jrd_526.jrd_551 = FALSE;
								break;

							case blr_int64:
							case blr_quad:
							case blr_timestamp:
							case blr_double:
							case blr_d_float:
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_526.jrd_552 = 8;
								/*FLD.RDB$FIELD_LENGTH.NULL*/
								jrd_526.jrd_551 = FALSE;
								break;

							default:
								if (/*FLD.RDB$FIELD_TYPE*/
								    jrd_526.jrd_548 == blr_blob)
								{
									/*FLD.RDB$FIELD_LENGTH*/
									jrd_526.jrd_552 = 8;
									/*FLD.RDB$FIELD_LENGTH.NULL*/
									jrd_526.jrd_551 = FALSE;
								}
								break;
							}
							break;

						case isc_dyn_fld_scale:
							/*FLD.RDB$FIELD_SCALE*/
							jrd_526.jrd_550 = (SSHORT) DYN_get_number(ptr);
							/*FLD.RDB$FIELD_SCALE.NULL*/
							jrd_526.jrd_549 = FALSE;
							break;

						case isc_dyn_fld_precision:
							/*FLD.RDB$FIELD_PRECISION*/
							jrd_526.jrd_534 = (SSHORT) DYN_get_number(ptr);
							/*FLD.RDB$FIELD_PRECISION.NULL*/
							jrd_526.jrd_533 = FALSE;
							break;

						case isc_dyn_fld_sub_type:
							/*FLD.RDB$FIELD_SUB_TYPE*/
							jrd_526.jrd_546 = (SSHORT) DYN_get_number(ptr);
							/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
							jrd_526.jrd_545 = FALSE;
							break;

						case isc_dyn_fld_char_length:
							/*FLD.RDB$CHARACTER_LENGTH*/
							jrd_526.jrd_540 = (USHORT) DYN_get_number(ptr);
							/*FLD.RDB$CHARACTER_LENGTH.NULL*/
							jrd_526.jrd_539 = FALSE;
							break;

						case isc_dyn_fld_character_set:
							/*FLD.RDB$CHARACTER_SET_ID*/
							jrd_526.jrd_536 = (SSHORT) DYN_get_number(ptr);
							/*FLD.RDB$CHARACTER_SET_ID.NULL*/
							jrd_526.jrd_535 = FALSE;
							break;

						case isc_dyn_fld_collation:
							/*FLD.RDB$COLLATION_ID*/
							jrd_526.jrd_538 = (SSHORT) DYN_get_number(ptr);
							/*FLD.RDB$COLLATION_ID.NULL*/
							jrd_526.jrd_537 = FALSE;
							break;

						case isc_dyn_fld_segment_length:
							/*FLD.RDB$SEGMENT_LENGTH*/
							jrd_526.jrd_544 = (USHORT) DYN_get_number(ptr);
							/*FLD.RDB$SEGMENT_LENGTH.NULL*/
							jrd_526.jrd_543 = FALSE;
							break;

						case isc_dyn_fld_default_value:
							DYN_put_blr_blob(gbl, ptr, &/*FLD.RDB$DEFAULT_VALUE*/
										    jrd_526.jrd_528);
							/*FLD.RDB$DEFAULT_VALUE.NULL*/
							jrd_526.jrd_554 = FALSE;
							break;

						case isc_dyn_fld_default_source:
							DYN_put_text_blob(gbl, ptr, &/*FLD.RDB$DEFAULT_SOURCE*/
										     jrd_526.jrd_527);
							/*FLD.RDB$DEFAULT_SOURCE.NULL*/
							jrd_526.jrd_553 = FALSE;
							break;

						case isc_dyn_prm_mechanism:
							/*PRM.RDB$PARAMETER_MECHANISM*/
							jrd_526.jrd_556 = (prm_mech_t) DYN_get_number(ptr);
							/*PRM.RDB$PARAMETER_MECHANISM.NULL*/
							jrd_526.jrd_555 = FALSE;
							break;

						default:
							DYN_unsupported_verb();
						}
					}
				}
				/*END_MODIFY*/
				jrd_568.jrd_569 = jrd_526.jrd_528;
				jrd_568.jrd_570 = jrd_526.jrd_527;
				jrd_568.jrd_571 = jrd_526.jrd_554;
				jrd_568.jrd_572 = jrd_526.jrd_553;
				jrd_568.jrd_573 = jrd_526.jrd_551;
				jrd_568.jrd_574 = jrd_526.jrd_552;
				jrd_568.jrd_575 = jrd_526.jrd_549;
				jrd_568.jrd_576 = jrd_526.jrd_550;
				jrd_568.jrd_577 = jrd_526.jrd_547;
				jrd_568.jrd_578 = jrd_526.jrd_548;
				jrd_568.jrd_579 = jrd_526.jrd_545;
				jrd_568.jrd_580 = jrd_526.jrd_546;
				jrd_568.jrd_581 = jrd_526.jrd_543;
				jrd_568.jrd_582 = jrd_526.jrd_544;
				jrd_568.jrd_583 = jrd_526.jrd_541;
				jrd_568.jrd_584 = jrd_526.jrd_542;
				jrd_568.jrd_585 = jrd_526.jrd_539;
				jrd_568.jrd_586 = jrd_526.jrd_540;
				jrd_568.jrd_587 = jrd_526.jrd_537;
				jrd_568.jrd_588 = jrd_526.jrd_538;
				jrd_568.jrd_589 = jrd_526.jrd_535;
				jrd_568.jrd_590 = jrd_526.jrd_536;
				jrd_568.jrd_591 = jrd_526.jrd_533;
				jrd_568.jrd_592 = jrd_526.jrd_534;
				EXE_send (tdbb, request, 2, 60, (UCHAR*) &jrd_568);
				} /*END_MODIFY*/
 jrd_595.jrd_596 = jrd_526.jrd_530;
 jrd_595.jrd_597 = jrd_526.jrd_529;
 jrd_595.jrd_598 = jrd_526.jrd_565;
 jrd_595.jrd_599 = jrd_526.jrd_566;
 jrd_595.jrd_600 = jrd_526.jrd_563;
 jrd_595.jrd_601 = jrd_526.jrd_564;
 jrd_595.jrd_602 = jrd_526.jrd_562;
 jrd_595.jrd_603 = jrd_526.jrd_561;
 jrd_595.jrd_604 = jrd_526.jrd_559;
 jrd_595.jrd_605 = jrd_526.jrd_560;
 jrd_595.jrd_606 = jrd_526.jrd_557;
 jrd_595.jrd_607 = jrd_526.jrd_558;
 jrd_595.jrd_608 = jrd_526.jrd_555;
 jrd_595.jrd_609 = jrd_526.jrd_556;
 EXE_send (tdbb, request, 4, 40, (UCHAR*) &jrd_595);
 }
			}
		}
		/*END_FOR*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_593);
		   }
		}

		if (!DYN_REQUEST(drq_m_prm))
			DYN_REQUEST(drq_m_prm) = request;
	}
	catch (const Exception& ex)
	{
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 100);
		// msg 100: "MODIFY RDB$PROCEDURE_PARAMETERS failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 146, SafeArg() << t << p);
		// msg : "Parameter %s in procedure %s not found"
	}
}


void DYN_modify_procedure( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_521;	// gds__utility 
   } jrd_520;
   struct {
          bid  jrd_500;	// RDB$DESCRIPTION 
          bid  jrd_501;	// RDB$PROCEDURE_BLR 
          bid  jrd_502;	// RDB$PROCEDURE_SOURCE 
          bid  jrd_503;	// RDB$DEBUG_INFO 
          TEXT  jrd_504 [32];	// RDB$SECURITY_CLASS 
          SSHORT jrd_505;	// gds__null_flag 
          SSHORT jrd_506;	// gds__null_flag 
          SSHORT jrd_507;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_508;	// gds__null_flag 
          SSHORT jrd_509;	// gds__null_flag 
          SSHORT jrd_510;	// gds__null_flag 
          SSHORT jrd_511;	// RDB$PROCEDURE_INPUTS 
          SSHORT jrd_512;	// gds__null_flag 
          SSHORT jrd_513;	// RDB$PROCEDURE_OUTPUTS 
          SSHORT jrd_514;	// gds__null_flag 
          SSHORT jrd_515;	// gds__null_flag 
          SSHORT jrd_516;	// RDB$PROCEDURE_TYPE 
          SSHORT jrd_517;	// gds__null_flag 
          SSHORT jrd_518;	// RDB$VALID_BLR 
          SSHORT jrd_519;	// gds__null_flag 
   } jrd_499;
   struct {
          TEXT  jrd_478 [32];	// RDB$SECURITY_CLASS 
          bid  jrd_479;	// RDB$DEBUG_INFO 
          bid  jrd_480;	// RDB$PROCEDURE_SOURCE 
          bid  jrd_481;	// RDB$PROCEDURE_BLR 
          bid  jrd_482;	// RDB$DESCRIPTION 
          SSHORT jrd_483;	// gds__utility 
          SSHORT jrd_484;	// gds__null_flag 
          SSHORT jrd_485;	// gds__null_flag 
          SSHORT jrd_486;	// RDB$VALID_BLR 
          SSHORT jrd_487;	// gds__null_flag 
          SSHORT jrd_488;	// RDB$PROCEDURE_TYPE 
          SSHORT jrd_489;	// gds__null_flag 
          SSHORT jrd_490;	// gds__null_flag 
          SSHORT jrd_491;	// RDB$PROCEDURE_OUTPUTS 
          SSHORT jrd_492;	// gds__null_flag 
          SSHORT jrd_493;	// RDB$PROCEDURE_INPUTS 
          SSHORT jrd_494;	// gds__null_flag 
          SSHORT jrd_495;	// gds__null_flag 
          SSHORT jrd_496;	// gds__null_flag 
          SSHORT jrd_497;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_498;	// gds__null_flag 
   } jrd_477;
   struct {
          TEXT  jrd_476 [32];	// RDB$PROCEDURE_NAME 
   } jrd_475;
/**************************************
 *
 *	D Y N _ m o d i f y _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement.
 *
 **************************************/
	MetaName procedure_name;

	GET_STRING(ptr, procedure_name);

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = NULL;
	bool found = false;
	bool only_description = false;

	try {

	request = CMP_find_request(tdbb, drq_m_prcs, DYN_REQUESTS);

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_NAME = procedure_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_474, sizeof(jrd_474), true);
	gds__vtov ((const char*) procedure_name.c_str(), (char*) jrd_475.jrd_476, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_475);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 96, (UCHAR*) &jrd_477);
	   if (!jrd_477.jrd_483) break;

		if (!DYN_REQUEST(drq_m_prcs))
			DYN_REQUEST(drq_m_prcs) = request;

		found = true;

		/* Set NULL flags to TRUE only for fields which must be specified in the DYN string.
		   Retain existing values on other fields (RDB$DESCRIPTION, RDB$SECURITY_CLASS),
		   unless explicitly changed in the DYN string */
		/*MODIFY P*/
		{
		

			if (**ptr == isc_dyn_description)
			{
				++*ptr;
				if (DYN_put_text_blob(gbl, ptr, &/*P.RDB$DESCRIPTION*/
								 jrd_477.jrd_482))
					/*P.RDB$DESCRIPTION.NULL*/
					jrd_477.jrd_498 = FALSE;
				else
					/*P.RDB$DESCRIPTION.NULL*/
					jrd_477.jrd_498 = TRUE;

				if (**ptr == isc_dyn_end)
					only_description = true;
			}

			if (!only_description)
			{
				/*P.RDB$SYSTEM_FLAG*/
				jrd_477.jrd_497 = 0;
				/*P.RDB$SYSTEM_FLAG.NULL*/
				jrd_477.jrd_496 = FALSE;
				/*P.RDB$PROCEDURE_BLR.NULL*/
				jrd_477.jrd_495 = TRUE;
				/*P.RDB$PROCEDURE_SOURCE.NULL*/
				jrd_477.jrd_494 = TRUE;
				/*P.RDB$PROCEDURE_INPUTS.NULL*/
				jrd_477.jrd_492 = TRUE;
				/*P.RDB$PROCEDURE_OUTPUTS.NULL*/
				jrd_477.jrd_490 = TRUE;

				// ODS_11_1 fields
				/*P.RDB$DEBUG_INFO.NULL*/
				jrd_477.jrd_489 = TRUE;

				/*P.RDB$PROCEDURE_TYPE*/
				jrd_477.jrd_488 = prc_legacy;
				/*P.RDB$PROCEDURE_TYPE.NULL*/
				jrd_477.jrd_487 = FALSE;

				/*P.RDB$VALID_BLR*/
				jrd_477.jrd_486 = TRUE;
				/*P.RDB$VALID_BLR.NULL*/
				jrd_477.jrd_485 = FALSE;
			}

			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_system_flag:
					/*P.RDB$SYSTEM_FLAG*/
					jrd_477.jrd_497 = DYN_get_number(ptr);
					/*P.RDB$SYSTEM_FLAG.NULL*/
					jrd_477.jrd_496 = FALSE;
					break;

				case isc_dyn_prc_blr:
					if (DYN_put_blr_blob(gbl, ptr, &/*P.RDB$PROCEDURE_BLR*/
									jrd_477.jrd_481))
						/*P.RDB$PROCEDURE_BLR.NULL*/
						jrd_477.jrd_495 = FALSE;
					else
						/*P.RDB$PROCEDURE_BLR.NULL*/
						jrd_477.jrd_495 = TRUE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*P.RDB$DESCRIPTION*/
									 jrd_477.jrd_482))
						/*P.RDB$DESCRIPTION.NULL*/
						jrd_477.jrd_498 = FALSE;
					else
						/*P.RDB$DESCRIPTION.NULL*/
						jrd_477.jrd_498 = TRUE;
					break;

				case isc_dyn_prc_source:
					if (DYN_put_text_blob(gbl, ptr, &/*P.RDB$PROCEDURE_SOURCE*/
									 jrd_477.jrd_480))
						/*P.RDB$PROCEDURE_SOURCE.NULL*/
						jrd_477.jrd_494 = FALSE;
					else
						/*P.RDB$PROCEDURE_SOURCE.NULL*/
						jrd_477.jrd_494 = TRUE;
					break;

				case isc_dyn_prc_inputs:
					/*P.RDB$PROCEDURE_INPUTS*/
					jrd_477.jrd_493 = DYN_get_number(ptr);
					/*P.RDB$PROCEDURE_INPUTS.NULL*/
					jrd_477.jrd_492 = FALSE;
					break;

				case isc_dyn_prc_outputs:
					/*P.RDB$PROCEDURE_OUTPUTS*/
					jrd_477.jrd_491 = DYN_get_number(ptr);
					/*P.RDB$PROCEDURE_OUTPUTS.NULL*/
					jrd_477.jrd_490 = FALSE;
					break;

				case isc_dyn_security_class:
					GET_STRING(ptr, /*P.RDB$SECURITY_CLASS*/
							jrd_477.jrd_478);
					/*P.RDB$SECURITY_CLASS.NULL*/
					jrd_477.jrd_484 = FALSE;
					break;

				case isc_dyn_debug_info:
					DYN_put_blr_blob(gbl, ptr, &/*P.RDB$DEBUG_INFO*/
								    jrd_477.jrd_479);	// ODS_11_1 field
					/*P.RDB$DEBUG_INFO.NULL*/
					jrd_477.jrd_489 = FALSE;
					break;

				case isc_dyn_prc_type:
					/*P.RDB$PROCEDURE_TYPE*/
					jrd_477.jrd_488 = DYN_get_number(ptr);	// ODS_11_1 field
					break;

				default:
					--(*ptr);
					DYN_execute(gbl, ptr, NULL, NULL, NULL, NULL, &procedure_name);
				}

		/*END_MODIFY;*/
		jrd_499.jrd_500 = jrd_477.jrd_482;
		jrd_499.jrd_501 = jrd_477.jrd_481;
		jrd_499.jrd_502 = jrd_477.jrd_480;
		jrd_499.jrd_503 = jrd_477.jrd_479;
		gds__vtov((const char*) jrd_477.jrd_478, (char*) jrd_499.jrd_504, 32);
		jrd_499.jrd_505 = jrd_477.jrd_498;
		jrd_499.jrd_506 = jrd_477.jrd_496;
		jrd_499.jrd_507 = jrd_477.jrd_497;
		jrd_499.jrd_508 = jrd_477.jrd_495;
		jrd_499.jrd_509 = jrd_477.jrd_494;
		jrd_499.jrd_510 = jrd_477.jrd_492;
		jrd_499.jrd_511 = jrd_477.jrd_493;
		jrd_499.jrd_512 = jrd_477.jrd_490;
		jrd_499.jrd_513 = jrd_477.jrd_491;
		jrd_499.jrd_514 = jrd_477.jrd_489;
		jrd_499.jrd_515 = jrd_477.jrd_487;
		jrd_499.jrd_516 = jrd_477.jrd_488;
		jrd_499.jrd_517 = jrd_477.jrd_485;
		jrd_499.jrd_518 = jrd_477.jrd_486;
		jrd_499.jrd_519 = jrd_477.jrd_484;
		EXE_send (tdbb, request, 2, 94, (UCHAR*) &jrd_499);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_520);
	   }
	}

	if (!DYN_REQUEST(drq_m_prcs))
		DYN_REQUEST(drq_m_prcs) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 141);
		/* msg 141: "MODIFY RDB$PROCEDURES failed" */
	}

	if (!found) {
		DYN_error_punt(false, 140, procedure_name.c_str());
		/* msg 140: "Procedure %s not found" */
	}
}


void DYN_modify_relation( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_473;	// gds__utility 
   } jrd_472;
   struct {
          TEXT  jrd_464 [32];	// RDB$SECURITY_CLASS 
          TEXT  jrd_465 [256];	// RDB$EXTERNAL_FILE 
          bid  jrd_466;	// RDB$DESCRIPTION 
          SSHORT jrd_467;	// gds__null_flag 
          SSHORT jrd_468;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_469;	// gds__null_flag 
          SSHORT jrd_470;	// gds__null_flag 
          SSHORT jrd_471;	// gds__null_flag 
   } jrd_463;
   struct {
          bid  jrd_452;	// RDB$DESCRIPTION 
          TEXT  jrd_453 [256];	// RDB$EXTERNAL_FILE 
          TEXT  jrd_454 [32];	// RDB$SECURITY_CLASS 
          bid  jrd_455;	// RDB$VIEW_BLR 
          SSHORT jrd_456;	// gds__utility 
          SSHORT jrd_457;	// gds__null_flag 
          SSHORT jrd_458;	// gds__null_flag 
          SSHORT jrd_459;	// gds__null_flag 
          SSHORT jrd_460;	// gds__null_flag 
          SSHORT jrd_461;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_462;	// gds__null_flag 
   } jrd_451;
   struct {
          TEXT  jrd_450 [32];	// RDB$RELATION_NAME 
   } jrd_449;
/**************************************
 *
 *	D Y N _ m o d i f y _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Modify an existing relation
 *
 **************************************/
	MetaName name, field_name;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	GET_STRING(ptr, name);

	jrd_req* request = CMP_find_request(tdbb, drq_m_relation, DYN_REQUESTS);
	bool found = false;

	try {

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		REL IN RDB$RELATIONS WITH REL.RDB$RELATION_NAME EQ name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_448, sizeof(jrd_448), true);
	gds__vtov ((const char*) name.c_str(), (char*) jrd_449.jrd_450, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_449);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 318, (UCHAR*) &jrd_451);
	   if (!jrd_451.jrd_456) break;

		if (!DYN_REQUEST(drq_m_relation))
			DYN_REQUEST(drq_m_relation) = request;

		if (!/*REL.RDB$VIEW_BLR.NULL*/
		     jrd_451.jrd_462)
			DYN_error_punt(false, 177);

		found = true;
		/*MODIFY REL USING*/
		{
		
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_system_flag:
					/*REL.RDB$SYSTEM_FLAG*/
					jrd_451.jrd_461 = DYN_get_number(ptr);
					/*REL.RDB$SYSTEM_FLAG.NULL*/
					jrd_451.jrd_460 = FALSE;
					break;

				case isc_dyn_security_class:
					if (GET_STRING(ptr, /*REL.RDB$SECURITY_CLASS*/
							    jrd_451.jrd_454))
						/*REL.RDB$SECURITY_CLASS.NULL*/
						jrd_451.jrd_459 = FALSE;
					else
						/*REL.RDB$SECURITY_CLASS.NULL*/
						jrd_451.jrd_459 = TRUE;
					break;

				case isc_dyn_rel_ext_file:
					if (/*REL.RDB$EXTERNAL_FILE.NULL*/
					    jrd_451.jrd_458) {
						DYN_rundown_request(request, -1);
						DYN_error_punt(false, 97);
						/* msg 97: "add EXTERNAL FILE not allowed" */
					}
					if (!GET_STRING(ptr, /*REL.RDB$EXTERNAL_FILE*/
							     jrd_451.jrd_453)) {
						DYN_rundown_request(request, -1);
						DYN_error_punt(false, 98);
						/* msg 98: "drop EXTERNAL FILE not allowed" */
					}
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*REL.RDB$DESCRIPTION*/
									 jrd_451.jrd_452))
						/*REL.RDB$DESCRIPTION.NULL*/
						jrd_451.jrd_457 = FALSE;
					else
						/*REL.RDB$DESCRIPTION.NULL*/
						jrd_451.jrd_457 = TRUE;
					break;

				default:
					--(*ptr);
					DYN_execute(gbl, ptr, &name, &field_name, NULL, NULL, NULL);
				}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_451.jrd_454, (char*) jrd_463.jrd_464, 32);
		gds__vtov((const char*) jrd_451.jrd_453, (char*) jrd_463.jrd_465, 256);
		jrd_463.jrd_466 = jrd_451.jrd_452;
		jrd_463.jrd_467 = jrd_451.jrd_460;
		jrd_463.jrd_468 = jrd_451.jrd_461;
		jrd_463.jrd_469 = jrd_451.jrd_459;
		jrd_463.jrd_470 = jrd_451.jrd_458;
		jrd_463.jrd_471 = jrd_451.jrd_457;
		EXE_send (tdbb, request, 2, 306, (UCHAR*) &jrd_463);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_472);
	   }
	}

	if (!DYN_REQUEST(drq_m_relation))
		DYN_REQUEST(drq_m_relation) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 99);
		/* msg 99: "MODIFY RDB$RELATIONS failed" */
	}

	if (!found)
	{
		DYN_error_punt(false, 101);
		/* msg 101: "Relation field not found" */
	}
}


// *****************************
// D Y N _ m o d i f y _ r o l e
// *****************************
// Its purpose is to change the comment in the role's record.
void DYN_modify_role(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_447;	// gds__utility 
   } jrd_446;
   struct {
          bid  jrd_444;	// RDB$DESCRIPTION 
          SSHORT jrd_445;	// gds__null_flag 
   } jrd_443;
   struct {
          bid  jrd_440;	// RDB$DESCRIPTION 
          SSHORT jrd_441;	// gds__utility 
          SSHORT jrd_442;	// gds__null_flag 
   } jrd_439;
   struct {
          TEXT  jrd_438 [32];	// RDB$ROLE_NAME 
   } jrd_437;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_rol, DYN_REQUESTS);
	bool found = false;
	SqlIdentifier t;
	GET_STRING(ptr, t);

	try {
		found = false;
		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			X IN RDB$ROLES
				WITH X.RDB$ROLE_NAME EQ t*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_436, sizeof(jrd_436), true);
		gds__vtov ((const char*) t, (char*) jrd_437.jrd_438, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_437);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 12, (UCHAR*) &jrd_439);
		   if (!jrd_439.jrd_441) break;

			if (!DYN_REQUEST(drq_m_rol))
				DYN_REQUEST(drq_m_rol) = request;

			found = true;
			/*MODIFY X*/
			{
			
				UCHAR verb;
				while ((verb = *(*ptr)++) != isc_dyn_end)
				{
					switch (verb)
					{
					case isc_dyn_description:
						if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
										 jrd_439.jrd_440))
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_439.jrd_442 = FALSE;
						else
							/*X.RDB$DESCRIPTION.NULL*/
							jrd_439.jrd_442 = TRUE;
						break;

					default:
						DYN_unsupported_verb();
					}
				}
			/*END_MODIFY;*/
			jrd_443.jrd_444 = jrd_439.jrd_440;
			jrd_443.jrd_445 = jrd_439.jrd_442;
			EXE_send (tdbb, request, 2, 10, (UCHAR*) &jrd_443);
			}
		/*END_FOR;*/
		   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_446);
		   }
		}

		if (!DYN_REQUEST(drq_m_rol))
			DYN_REQUEST(drq_m_rol) = request;
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 158);
		// msg 158: "MODIFY RDB$ROLES failed"
	}

	if (!found)
	{
		DYN_error_punt(false, 155, t);
		// msg 155: "Role %s not found"
	}
}


void DYN_modify_trigger( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_395;	// gds__utility 
   } jrd_394;
   struct {
          bid  jrd_390;	// RDB$DEBUG_INFO 
          SSHORT jrd_391;	// gds__null_flag 
          SSHORT jrd_392;	// RDB$VALID_BLR 
          SSHORT jrd_393;	// gds__null_flag 
   } jrd_389;
   struct {
          bid  jrd_384;	// RDB$DEBUG_INFO 
          SSHORT jrd_385;	// gds__utility 
          SSHORT jrd_386;	// gds__null_flag 
          SSHORT jrd_387;	// gds__null_flag 
          SSHORT jrd_388;	// RDB$VALID_BLR 
   } jrd_383;
   struct {
          TEXT  jrd_382 [32];	// RDB$TRIGGER_NAME 
   } jrd_381;
   struct {
          SSHORT jrd_435;	// gds__utility 
   } jrd_434;
   struct {
          TEXT  jrd_419 [32];	// RDB$RELATION_NAME 
          bid  jrd_420;	// RDB$DESCRIPTION 
          TEXT  jrd_421 [32];	// RDB$TRIGGER_NAME 
          bid  jrd_422;	// RDB$TRIGGER_BLR 
          bid  jrd_423;	// RDB$TRIGGER_SOURCE 
          SSHORT jrd_424;	// gds__null_flag 
          SSHORT jrd_425;	// gds__null_flag 
          SSHORT jrd_426;	// gds__null_flag 
          SSHORT jrd_427;	// RDB$TRIGGER_TYPE 
          SSHORT jrd_428;	// gds__null_flag 
          SSHORT jrd_429;	// RDB$TRIGGER_SEQUENCE 
          SSHORT jrd_430;	// gds__null_flag 
          SSHORT jrd_431;	// RDB$TRIGGER_INACTIVE 
          SSHORT jrd_432;	// gds__null_flag 
          SSHORT jrd_433;	// gds__null_flag 
   } jrd_418;
   struct {
          bid  jrd_400;	// RDB$TRIGGER_SOURCE 
          bid  jrd_401;	// RDB$TRIGGER_BLR 
          TEXT  jrd_402 [32];	// RDB$TRIGGER_NAME 
          bid  jrd_403;	// RDB$DESCRIPTION 
          TEXT  jrd_404 [32];	// RDB$RELATION_NAME 
          SSHORT jrd_405;	// gds__utility 
          SSHORT jrd_406;	// gds__null_flag 
          SSHORT jrd_407;	// gds__null_flag 
          SSHORT jrd_408;	// gds__null_flag 
          SSHORT jrd_409;	// RDB$TRIGGER_INACTIVE 
          SSHORT jrd_410;	// gds__null_flag 
          SSHORT jrd_411;	// RDB$TRIGGER_SEQUENCE 
          SSHORT jrd_412;	// gds__null_flag 
          SSHORT jrd_413;	// RDB$TRIGGER_TYPE 
          SSHORT jrd_414;	// gds__null_flag 
          SSHORT jrd_415;	// gds__null_flag 
          SSHORT jrd_416;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_417;	// gds__null_flag 
   } jrd_399;
   struct {
          TEXT  jrd_398 [32];	// RDB$TRIGGER_NAME 
   } jrd_397;
/**************************************
 *
 *	D Y N _ m o d i f y _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Modify a trigger for a relation.
 *
 **************************************/
	MetaName trigger_name;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_trigger, DYN_REQUESTS);
	bool found = false;
	bool only_description = false;

	try {

	GET_STRING(ptr, trigger_name);
	const UCHAR* source = NULL;
	const UCHAR* blr = NULL;
	const UCHAR* debug_info_ptr = NULL;

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$TRIGGERS WITH X.RDB$TRIGGER_NAME EQ trigger_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_396, sizeof(jrd_396), true);
	gds__vtov ((const char*) trigger_name.c_str(), (char*) jrd_397.jrd_398, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_397);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 114, (UCHAR*) &jrd_399);
	   if (!jrd_399.jrd_405) break;

		if (!DYN_REQUEST(drq_m_trigger)) {
			DYN_REQUEST(drq_m_trigger) = request;
		}

		if (/*X.RDB$RELATION_NAME.NULL*/
		    jrd_399.jrd_417 && !tdbb->getAttachment()->locksmith())
			ERR_post(Arg::Gds(isc_adm_task_denied));

		// CVC: I think that we'll do well by hiding our automatic triggers from this function.
		// Why would a user want to fiddle with triggers that were generated automatically?

		if (!/*X.RDB$SYSTEM_FLAG.NULL*/
		     jrd_399.jrd_415)
		{
			switch (/*X.RDB$SYSTEM_FLAG*/
				jrd_399.jrd_416)
			{
			case fb_sysflag_check_constraint:
			case fb_sysflag_referential_constraint:
			case fb_sysflag_view_check:
				DYN_error_punt(false, 109);
				// msg 109: "Triggers created automatically cannot be modified"
				break;
			default:
				break;
			}
		}

		found = true;

		/*MODIFY X*/
		{
		

			if (**ptr == isc_dyn_description)
			{
				++*ptr;
				if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
								 jrd_399.jrd_403))
					/*X.RDB$DESCRIPTION.NULL*/
					jrd_399.jrd_414 = FALSE;
				else
					/*X.RDB$DESCRIPTION.NULL*/
					jrd_399.jrd_414 = TRUE;

				if (**ptr == isc_dyn_end)
					only_description = true;
			}

			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_trg_name:
					{
						MetaName new_trigger_name;
						GET_STRING(ptr, new_trigger_name);
						if (new_trigger_name.length() == 0)
							DYN_error_punt(false, 212);
							// msg 212: "Zero length identifiers not allowed"
					    strcpy (/*X.RDB$TRIGGER_NAME*/
						    jrd_399.jrd_402, new_trigger_name.c_str());
					}
					break;

				case isc_dyn_trg_type:
					/*X.RDB$TRIGGER_TYPE*/
					jrd_399.jrd_413 = DYN_get_number(ptr);
					/*X.RDB$TRIGGER_TYPE.NULL*/
					jrd_399.jrd_412 = FALSE;
					break;

				case isc_dyn_trg_sequence:
					/*X.RDB$TRIGGER_SEQUENCE*/
					jrd_399.jrd_411 = DYN_get_number(ptr);
					/*X.RDB$TRIGGER_SEQUENCE.NULL*/
					jrd_399.jrd_410 = FALSE;
					break;

				case isc_dyn_trg_inactive:
					/*X.RDB$TRIGGER_INACTIVE*/
					jrd_399.jrd_409 = DYN_get_number(ptr);
					/*X.RDB$TRIGGER_INACTIVE.NULL*/
					jrd_399.jrd_408 = FALSE;
					break;

				case isc_dyn_rel_name:
					GET_STRING(ptr, /*X.RDB$RELATION_NAME*/
							jrd_399.jrd_404);
					/*X.RDB$RELATION_NAME.NULL*/
					jrd_399.jrd_417 = FALSE;
					break;

				case isc_dyn_trg_blr:
					blr = *ptr;
					DYN_skip_attribute(ptr);
					if (DYN_put_blr_blob(gbl, &blr, &/*X.RDB$TRIGGER_BLR*/
									 jrd_399.jrd_401))
						/*X.RDB$TRIGGER_BLR.NULL*/
						jrd_399.jrd_407 = FALSE;
					else
						/*X.RDB$TRIGGER_BLR.NULL*/
						jrd_399.jrd_407 = TRUE;
					break;

				case isc_dyn_trg_source:
					source = *ptr;
					DYN_skip_attribute(ptr);
					if (DYN_put_text_blob(gbl, &source, &/*X.RDB$TRIGGER_SOURCE*/
									     jrd_399.jrd_400))
						/*X.RDB$TRIGGER_SOURCE.NULL*/
						jrd_399.jrd_406 = FALSE;
					else
						/*X.RDB$TRIGGER_SOURCE.NULL*/
						jrd_399.jrd_406 = TRUE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*X.RDB$DESCRIPTION*/
									 jrd_399.jrd_403))
						/*X.RDB$DESCRIPTION.NULL*/
						jrd_399.jrd_414 = FALSE;
					else
						/*X.RDB$DESCRIPTION.NULL*/
						jrd_399.jrd_414 = TRUE;
					break;

				case isc_dyn_debug_info:
					debug_info_ptr = *ptr;
					DYN_skip_attribute(ptr);
					break;

				default:
					--(*ptr);
					DYN_execute(gbl, ptr, NULL, NULL, &trigger_name, NULL, NULL);
				}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_399.jrd_404, (char*) jrd_418.jrd_419, 32);
		jrd_418.jrd_420 = jrd_399.jrd_403;
		gds__vtov((const char*) jrd_399.jrd_402, (char*) jrd_418.jrd_421, 32);
		jrd_418.jrd_422 = jrd_399.jrd_401;
		jrd_418.jrd_423 = jrd_399.jrd_400;
		jrd_418.jrd_424 = jrd_399.jrd_417;
		jrd_418.jrd_425 = jrd_399.jrd_414;
		jrd_418.jrd_426 = jrd_399.jrd_412;
		jrd_418.jrd_427 = jrd_399.jrd_413;
		jrd_418.jrd_428 = jrd_399.jrd_410;
		jrd_418.jrd_429 = jrd_399.jrd_411;
		jrd_418.jrd_430 = jrd_399.jrd_408;
		jrd_418.jrd_431 = jrd_399.jrd_409;
		jrd_418.jrd_432 = jrd_399.jrd_407;
		jrd_418.jrd_433 = jrd_399.jrd_406;
		EXE_send (tdbb, request, 2, 108, (UCHAR*) &jrd_418);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_434);
	   }
	}

	if (!DYN_REQUEST(drq_m_trigger))
		DYN_REQUEST(drq_m_trigger) = request;

	if (!only_description)
	{
		if (ENCODE_ODS(dbb->dbb_ods_version, dbb->dbb_minor_original) >= ODS_11_1)
		{
			jrd_req* sub_request = NULL;

			/*FOR(REQUEST_HANDLE sub_request TRANSACTION_HANDLE gbl->gbl_transaction)
				TRG IN RDB$TRIGGERS WITH TRG.RDB$TRIGGER_NAME EQ trigger_name.c_str()*/
			{
			if (!sub_request)
			   sub_request = CMP_compile2 (tdbb, (UCHAR*) jrd_380, sizeof(jrd_380), true);
			gds__vtov ((const char*) trigger_name.c_str(), (char*) jrd_381.jrd_382, 32);
			EXE_start (tdbb, sub_request, gbl->gbl_transaction);
			EXE_send (tdbb, sub_request, 0, 32, (UCHAR*) &jrd_381);
			while (1)
			   {
			   EXE_receive (tdbb, sub_request, 1, 16, (UCHAR*) &jrd_383);
			   if (!jrd_383.jrd_385) break;

				/*MODIFY TRG USING*/
				{
				
					/*TRG.RDB$VALID_BLR*/
					jrd_383.jrd_388 = TRUE;
					/*TRG.RDB$VALID_BLR.NULL*/
					jrd_383.jrd_387 = FALSE;

					/*TRG.RDB$DEBUG_INFO.NULL*/
					jrd_383.jrd_386 = (debug_info_ptr == NULL) ? TRUE : FALSE;
					if (debug_info_ptr)
						DYN_put_blr_blob(gbl, &debug_info_ptr, &/*TRG.RDB$DEBUG_INFO*/
											jrd_383.jrd_384);
				/*END_MODIFY;*/
				jrd_389.jrd_390 = jrd_383.jrd_384;
				jrd_389.jrd_391 = jrd_383.jrd_387;
				jrd_389.jrd_392 = jrd_383.jrd_388;
				jrd_389.jrd_393 = jrd_383.jrd_386;
				EXE_send (tdbb, sub_request, 2, 14, (UCHAR*) &jrd_389);
				}
			/*END_FOR;*/
			   EXE_send (tdbb, sub_request, 3, 2, (UCHAR*) &jrd_394);
			   }
			}

			CMP_release(tdbb, sub_request);
		}
	}

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 102);
		/* msg 102: "MODIFY TRIGGER failed" */
	}

	if (!found) {
		DYN_error_punt(false, 147, trigger_name.c_str());
		/* msg 147: "Trigger %s not found" */
	}
}


void DYN_modify_trigger_msg( Global* gbl, const UCHAR** ptr, MetaName* trigger_name)
{
   struct {
          SSHORT jrd_379;	// gds__utility 
   } jrd_378;
   struct {
          TEXT  jrd_374 [1024];	// RDB$MESSAGE 
          SSHORT jrd_375;	// gds__null_flag 
          SSHORT jrd_376;	// RDB$MESSAGE_NUMBER 
          SSHORT jrd_377;	// gds__null_flag 
   } jrd_373;
   struct {
          TEXT  jrd_368 [1024];	// RDB$MESSAGE 
          SSHORT jrd_369;	// gds__utility 
          SSHORT jrd_370;	// gds__null_flag 
          SSHORT jrd_371;	// gds__null_flag 
          SSHORT jrd_372;	// RDB$MESSAGE_NUMBER 
   } jrd_367;
   struct {
          TEXT  jrd_365 [32];	// RDB$TRIGGER_NAME 
          SSHORT jrd_366;	// RDB$MESSAGE_NUMBER 
   } jrd_364;
/**************************************
 *
 *	D Y N _ m o d i f y _ t r i g g e r _ m s g
 *
 **************************************
 *
 * Functional description
 *	Modify a trigger message.
 *
 **************************************/
	MetaName t;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_trg_msg, DYN_REQUESTS);

	try {

	const int number = DYN_get_number(ptr);
	if (trigger_name)
		t = *trigger_name;
	else if (*(*ptr)++ == isc_dyn_trg_name)
		GET_STRING(ptr, t);
	else
		DYN_error_punt(false, 103);
	/* msg 103: "TRIGGER NAME expected" */

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$TRIGGER_MESSAGES
			WITH X.RDB$MESSAGE_NUMBER EQ number AND X.RDB$TRIGGER_NAME EQ t.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_363, sizeof(jrd_363), true);
	gds__vtov ((const char*) t.c_str(), (char*) jrd_364.jrd_365, 32);
	jrd_364.jrd_366 = number;
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 34, (UCHAR*) &jrd_364);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 1032, (UCHAR*) &jrd_367);
	   if (!jrd_367.jrd_369) break;

		if (!DYN_REQUEST(drq_m_trg_msg))
			DYN_REQUEST(drq_m_trg_msg) = request;

		/*MODIFY X*/
		{
		
			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_trg_msg_number:
					/*X.RDB$MESSAGE_NUMBER*/
					jrd_367.jrd_372 = DYN_get_number(ptr);
					/*X.RDB$MESSAGE_NUMBER.NULL*/
					jrd_367.jrd_371 = FALSE;
					break;

				case isc_dyn_trg_msg:
					GET_STRING(ptr, /*X.RDB$MESSAGE*/
							jrd_367.jrd_368);
					/*X.RDB$MESSAGE.NULL*/
					jrd_367.jrd_370 = FALSE;
					break;

				default:
					DYN_unsupported_verb();
				}
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_367.jrd_368, (char*) jrd_373.jrd_374, 1024);
		jrd_373.jrd_375 = jrd_367.jrd_371;
		jrd_373.jrd_376 = jrd_367.jrd_372;
		jrd_373.jrd_377 = jrd_367.jrd_370;
		EXE_send (tdbb, request, 2, 1030, (UCHAR*) &jrd_373);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_378);
	   }
	}

	if (!DYN_REQUEST(drq_m_trg_msg))
		DYN_REQUEST(drq_m_trg_msg) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 105);
		/* msg 105: "MODIFY TRIGGER MESSAGE failed" */
	}
}


void DYN_modify_view( Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_323;	// gds__utility 
   } jrd_322;
   struct {
          SSHORT jrd_321;	// gds__utility 
   } jrd_320;
   struct {
          SSHORT jrd_319;	// gds__utility 
   } jrd_318;
   struct {
          TEXT  jrd_316 [32];	// RDB$RELATION_NAME 
          SSHORT jrd_317;	// RDB$SYSTEM_FLAG 
   } jrd_315;
   struct {
          SSHORT jrd_332;	// gds__utility 
   } jrd_331;
   struct {
          SSHORT jrd_330;	// gds__utility 
   } jrd_329;
   struct {
          SSHORT jrd_328;	// gds__utility 
   } jrd_327;
   struct {
          TEXT  jrd_326 [32];	// RDB$VIEW_NAME 
   } jrd_325;
   struct {
          SSHORT jrd_362;	// gds__utility 
   } jrd_361;
   struct {
          bid  jrd_350;	// RDB$DESCRIPTION 
          bid  jrd_351;	// RDB$VIEW_BLR 
          bid  jrd_352;	// RDB$VIEW_SOURCE 
          TEXT  jrd_353 [32];	// RDB$SECURITY_CLASS 
          TEXT  jrd_354 [32];	// RDB$RELATION_NAME 
          SSHORT jrd_355;	// gds__null_flag 
          SSHORT jrd_356;	// gds__null_flag 
          SSHORT jrd_357;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_358;	// gds__null_flag 
          SSHORT jrd_359;	// gds__null_flag 
          SSHORT jrd_360;	// gds__null_flag 
   } jrd_349;
   struct {
          TEXT  jrd_337 [32];	// RDB$RELATION_NAME 
          TEXT  jrd_338 [32];	// RDB$SECURITY_CLASS 
          bid  jrd_339;	// RDB$VIEW_SOURCE 
          bid  jrd_340;	// RDB$VIEW_BLR 
          bid  jrd_341;	// RDB$DESCRIPTION 
          SSHORT jrd_342;	// gds__utility 
          SSHORT jrd_343;	// gds__null_flag 
          SSHORT jrd_344;	// gds__null_flag 
          SSHORT jrd_345;	// gds__null_flag 
          SSHORT jrd_346;	// gds__null_flag 
          SSHORT jrd_347;	// RDB$SYSTEM_FLAG 
          SSHORT jrd_348;	// gds__null_flag 
   } jrd_336;
   struct {
          TEXT  jrd_335 [32];	// RDB$RELATION_NAME 
   } jrd_334;
/**************************************
 *
 *	D Y N _ m o d i f y _ v i e w
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	MetaName view_name;
	GET_STRING(ptr, view_name);

	if (view_name.length() == 0)
	{
		DYN_error_punt(false, 212);
		/* msg 212: "Zero length identifiers not allowed" */
	}

	jrd_req* request = NULL;
	bool found = false;

	try {

	request = CMP_find_request(tdbb, drq_m_view, DYN_REQUESTS);

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		REL IN RDB$RELATIONS
			WITH REL.RDB$RELATION_NAME EQ view_name.c_str()
				AND REL.RDB$VIEW_BLR NOT MISSING*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_333, sizeof(jrd_333), true);
	gds__vtov ((const char*) view_name.c_str(), (char*) jrd_334.jrd_335, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_334);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 102, (UCHAR*) &jrd_336);
	   if (!jrd_336.jrd_342) break;

		if (!DYN_REQUEST(drq_m_view))
			DYN_REQUEST(drq_m_view) = request;

		found = true;
		bool only_description = false;

		/*MODIFY REL*/
		{
		

			if (**ptr == isc_dyn_description)
			{
				++*ptr;
				if (DYN_put_text_blob(gbl, ptr, &/*REL.RDB$DESCRIPTION*/
								 jrd_336.jrd_341))
					/*REL.RDB$DESCRIPTION.NULL*/
					jrd_336.jrd_348 = FALSE;
				else
					/*REL.RDB$DESCRIPTION.NULL*/
					jrd_336.jrd_348 = TRUE;

				if (**ptr == isc_dyn_end)
					only_description = true;
			}

			if (!only_description)
			{
				/*REL.RDB$SYSTEM_FLAG*/
				jrd_336.jrd_347 = 0;
				/*REL.RDB$SYSTEM_FLAG.NULL*/
				jrd_336.jrd_346 = FALSE;
				/*REL.RDB$VIEW_BLR.NULL*/
				jrd_336.jrd_345 = TRUE;
				/*REL.RDB$VIEW_SOURCE.NULL*/
				jrd_336.jrd_344 = TRUE;

				jrd_req* request2 = NULL;

				/*FOR (REQUEST_HANDLE request2 TRANSACTION_HANDLE gbl->gbl_transaction)
					VR IN RDB$VIEW_RELATIONS
					WITH VR.RDB$VIEW_NAME EQ view_name.c_str()*/
				{
				if (!request2)
				   request2 = CMP_compile2 (tdbb, (UCHAR*) jrd_324, sizeof(jrd_324), true);
				gds__vtov ((const char*) view_name.c_str(), (char*) jrd_325.jrd_326, 32);
				EXE_start (tdbb, request2, gbl->gbl_transaction);
				EXE_send (tdbb, request2, 0, 32, (UCHAR*) &jrd_325);
				while (1)
				   {
				   EXE_receive (tdbb, request2, 1, 2, (UCHAR*) &jrd_327);
				   if (!jrd_327.jrd_328) break;

					/*ERASE VR;*/
					EXE_send (tdbb, request2, 2, 2, (UCHAR*) &jrd_329);
				/*END_FOR;*/
				   EXE_send (tdbb, request2, 3, 2, (UCHAR*) &jrd_331);
				   }
				}

				CMP_release(tdbb, request2);

				request2 = NULL;

				/*FOR (REQUEST_HANDLE request2 TRANSACTION_HANDLE gbl->gbl_transaction)
					TRG IN RDB$TRIGGERS
					WITH TRG.RDB$RELATION_NAME EQ view_name.c_str() AND
						 TRG.RDB$SYSTEM_FLAG EQ fb_sysflag_view_check*/
				{
				if (!request2)
				   request2 = CMP_compile2 (tdbb, (UCHAR*) jrd_314, sizeof(jrd_314), true);
				gds__vtov ((const char*) view_name.c_str(), (char*) jrd_315.jrd_316, 32);
				jrd_315.jrd_317 = fb_sysflag_view_check;
				EXE_start (tdbb, request2, gbl->gbl_transaction);
				EXE_send (tdbb, request2, 0, 34, (UCHAR*) &jrd_315);
				while (1)
				   {
				   EXE_receive (tdbb, request2, 1, 2, (UCHAR*) &jrd_318);
				   if (!jrd_318.jrd_319) break;

					/*ERASE TRG;*/
					EXE_send (tdbb, request2, 2, 2, (UCHAR*) &jrd_320);
				/*END_FOR*/
				   EXE_send (tdbb, request2, 3, 2, (UCHAR*) &jrd_322);
				   }
				}

				CMP_release(tdbb, request2);
			}

			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end)
				switch (verb)
				{
				case isc_dyn_system_flag:
					/*REL.RDB$SYSTEM_FLAG*/
					jrd_336.jrd_347 = DYN_get_number(ptr);
					/*REL.RDB$SYSTEM_FLAG.NULL*/
					jrd_336.jrd_346 = FALSE;
					break;

				case isc_dyn_view_blr:
					if (DYN_put_blr_blob(gbl, ptr, &/*REL.RDB$VIEW_BLR*/
									jrd_336.jrd_340))
						/*REL.RDB$VIEW_BLR.NULL*/
						jrd_336.jrd_345 = FALSE;
					else
						/*REL.RDB$VIEW_BLR.NULL*/
						jrd_336.jrd_345 = TRUE;
					break;

				case isc_dyn_view_source:
					if (DYN_put_text_blob(gbl, ptr, &/*REL.RDB$VIEW_SOURCE*/
									 jrd_336.jrd_339))
						/*REL.RDB$VIEW_SOURCE.NULL*/
						jrd_336.jrd_344 = FALSE;
					else
						/*REL.RDB$VIEW_SOURCE.NULL*/
						jrd_336.jrd_344 = TRUE;
					break;

				case isc_dyn_security_class:
					GET_STRING(ptr, /*REL.RDB$SECURITY_CLASS*/
							jrd_336.jrd_338);
					/*REL.RDB$SECURITY_CLASS.NULL*/
					jrd_336.jrd_343 = FALSE;
					break;

				case isc_dyn_description:
					if (DYN_put_text_blob(gbl, ptr, &/*REL.RDB$DESCRIPTION*/
									 jrd_336.jrd_341))
						/*REL.RDB$DESCRIPTION.NULL*/
						jrd_336.jrd_348 = FALSE;
					else
						/*REL.RDB$DESCRIPTION.NULL*/
						jrd_336.jrd_348 = TRUE;
					break;

				default:
					--(*ptr);
					MetaTmp(/*REL.RDB$RELATION_NAME*/
						jrd_336.jrd_337)
						DYN_execute(gbl, ptr, &tmp, NULL, NULL, NULL, NULL);
				}
		/*END_MODIFY;*/
		jrd_349.jrd_350 = jrd_336.jrd_341;
		jrd_349.jrd_351 = jrd_336.jrd_340;
		jrd_349.jrd_352 = jrd_336.jrd_339;
		gds__vtov((const char*) jrd_336.jrd_338, (char*) jrd_349.jrd_353, 32);
		gds__vtov((const char*) jrd_336.jrd_337, (char*) jrd_349.jrd_354, 32);
		jrd_349.jrd_355 = jrd_336.jrd_348;
		jrd_349.jrd_356 = jrd_336.jrd_346;
		jrd_349.jrd_357 = jrd_336.jrd_347;
		jrd_349.jrd_358 = jrd_336.jrd_345;
		jrd_349.jrd_359 = jrd_336.jrd_344;
		jrd_349.jrd_360 = jrd_336.jrd_343;
		EXE_send (tdbb, request, 2, 100, (UCHAR*) &jrd_349);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_361);
	   }
	}

	if (!DYN_REQUEST(drq_m_view))
		DYN_REQUEST(drq_m_view) = request;

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, -1);
		DYN_error_punt(true, 99);
		/* msg 99: "MODIFY RDB$RELATIONS failed" */
	}

	if (!found) {
		DYN_error_punt(false, 54, view_name.c_str());
		/* msg 54: "View %s not found" */
	}
}


static void change_backup_mode( Global* gbl, UCHAR verb)
{
   struct {
          TEXT  jrd_288 [256];	// RDB$FILE_NAME 
          SLONG  jrd_289;	// RDB$FILE_LENGTH 
          SLONG  jrd_290;	// RDB$FILE_START 
          SSHORT jrd_291;	// gds__null_flag 
          SSHORT jrd_292;	// RDB$SHADOW_NUMBER 
          SSHORT jrd_293;	// gds__null_flag 
          SSHORT jrd_294;	// gds__null_flag 
          SSHORT jrd_295;	// gds__null_flag 
          SSHORT jrd_296;	// RDB$FILE_FLAGS 
          SSHORT jrd_297;	// gds__null_flag 
   } jrd_287;
   struct {
          SSHORT jrd_313;	// gds__utility 
   } jrd_312;
   struct {
          SSHORT jrd_311;	// RDB$FILE_FLAGS 
   } jrd_310;
   struct {
          SSHORT jrd_309;	// gds__utility 
   } jrd_308;
   struct {
          SSHORT jrd_307;	// gds__utility 
   } jrd_306;
   struct {
          SSHORT jrd_305;	// RDB$FILE_FLAGS 
   } jrd_304;
   struct {
          TEXT  jrd_300 [256];	// RDB$FILE_NAME 
          SSHORT jrd_301;	// gds__utility 
          SSHORT jrd_302;	// gds__null_flag 
          SSHORT jrd_303;	// RDB$FILE_FLAGS 
   } jrd_299;
/**************************************
 *
 *	c h a n g e _ b a c k u p _ m o d e
 *
 **************************************
 *
 * Functional description
 *	Drop backup difference file for the database,
 *  begin or end backup
 *
 **************************************/
	bool invalid_state = false;

	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	if (!tdbb->getAttachment()->locksmith())
	{
		ERR_post(Arg::Gds(isc_adm_task_denied));
	}

	jrd_req* request = CMP_find_request(tdbb, drq_d_difference, DYN_REQUESTS);
	bool found = false;

	try {

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$FILES*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_298, sizeof(jrd_298), true);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	while (1)
	   {
	   EXE_receive (tdbb, request, 0, 262, (UCHAR*) &jrd_299);
	   if (!jrd_299.jrd_301) break;

		if (/*X.RDB$FILE_FLAGS*/
		    jrd_299.jrd_303 & FILE_difference) {
			found = true;
			switch (verb)
			{
			case isc_dyn_drop_difference:
				/*ERASE X;*/
				EXE_send (tdbb, request, 5, 2, (UCHAR*) &jrd_312);
				break;
			case isc_dyn_begin_backup:
				if (/*X.RDB$FILE_FLAGS*/
				    jrd_299.jrd_303 & FILE_backing_up) {
					invalid_state = true;
				}
				else {
					/*MODIFY X USING*/
					{
					
						/*X.RDB$FILE_FLAGS*/
						jrd_299.jrd_303 |= FILE_backing_up;
					/*END_MODIFY;*/
					jrd_310.jrd_311 = jrd_299.jrd_303;
					EXE_send (tdbb, request, 4, 2, (UCHAR*) &jrd_310);
					}
				}
				break;
			case isc_dyn_end_backup:
				if (/*X.RDB$FILE_FLAGS*/
				    jrd_299.jrd_303 & FILE_backing_up) {
					if (/*X.RDB$FILE_NAME.NULL*/
					    jrd_299.jrd_302) {
						/*ERASE X;*/
						EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_308);
					}
					else {
						/*MODIFY X USING*/
						{
						
							/*X.RDB$FILE_FLAGS*/
							jrd_299.jrd_303 &= ~FILE_backing_up;
						/*END_MODIFY;*/
						jrd_304.jrd_305 = jrd_299.jrd_303;
						EXE_send (tdbb, request, 1, 2, (UCHAR*) &jrd_304);
						}
					}
				}
				else {
					invalid_state = true;
				}
				break;
			}
		}

	/*END_FOR;*/
	   EXE_send (tdbb, request, 2, 2, (UCHAR*) &jrd_306);
	   }
	}

	if (!DYN_REQUEST(drq_d_difference)) {
		DYN_REQUEST(drq_d_difference) = request;
	}

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_rundown_request(request, drq_d_difference);
		DYN_error_punt(true, 63);
		/* msg 63: ERASE RDB$FILE failed */
	}

	if (!found && verb == isc_dyn_begin_backup) {
		try {
			request = CMP_find_request(tdbb, drq_s2_difference, DYN_REQUESTS);
			/*STORE(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
				X IN RDB$FILES*/
			{
			
				/*X.RDB$FILE_NAME.NULL*/
				jrd_287.jrd_297 = TRUE;
				/*X.RDB$FILE_FLAGS.NULL*/
				jrd_287.jrd_295 = FALSE;
				/*X.RDB$FILE_FLAGS*/
				jrd_287.jrd_296 = FILE_difference | FILE_backing_up;
				/*X.RDB$FILE_START*/
				jrd_287.jrd_290 = 0;
				/*X.RDB$FILE_START.NULL*/
				jrd_287.jrd_294 = FALSE;
				/*X.RDB$FILE_LENGTH.NULL*/
				jrd_287.jrd_293 = TRUE;
				/*X.RDB$SHADOW_NUMBER.NULL*/
				jrd_287.jrd_291 = TRUE;
			/*END_STORE;*/
			if (!request)
			   request = CMP_compile2 (tdbb, (UCHAR*) jrd_286, sizeof(jrd_286), true);
			EXE_start (tdbb, request, gbl->gbl_transaction);
			EXE_send (tdbb, request, 0, 278, (UCHAR*) &jrd_287);
			}

			found = true;

			if (!DYN_REQUEST(drq_s2_difference))
			{
				DYN_REQUEST(drq_s2_difference) = request;
			}
		}
		catch (const Exception& ex) {
			stuff_exception(tdbb->tdbb_status_vector, ex);
			DYN_rundown_request(request, drq_s2_difference);
			DYN_error_punt(true, 150);
			/* msg 150: STORE RDB$FILES failed */
		}
	}

	if (invalid_state) {
		DYN_error_punt(false, verb == isc_dyn_begin_backup ? 217 : 218);
		/* msg 217: "Database is already in the physical backup mode" */
		/* msg 218: "Database is not in the physical backup mode" */
	}

	if (!found)
	{
		DYN_error_punt(false, verb == isc_dyn_end_backup ? 218 : 215);
		/* msg 218: "Database is not in the physical backup mode" */
		/* msg 215: "Difference file is not defined" */
	}
}


static void modify_lfield_position(thread_db* tdbb,
								   Global* gbl,
								   const MetaName& relation_name,
								   const MetaName& field_name,
								   USHORT new_position,
								   USHORT existing_position)
{
   struct {
          SSHORT jrd_269;	// gds__utility 
   } jrd_268;
   struct {
          SSHORT jrd_267;	// RDB$FIELD_POSITION 
   } jrd_266;
   struct {
          SSHORT jrd_264;	// gds__utility 
          SSHORT jrd_265;	// RDB$FIELD_POSITION 
   } jrd_263;
   struct {
          TEXT  jrd_262 [32];	// RDB$RELATION_NAME 
   } jrd_261;
   struct {
          SSHORT jrd_285;	// gds__utility 
   } jrd_284;
   struct {
          TEXT  jrd_281 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_282;	// gds__null_flag 
          SSHORT jrd_283;	// RDB$FIELD_POSITION 
   } jrd_280;
   struct {
          TEXT  jrd_276 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_277;	// gds__utility 
          SSHORT jrd_278;	// gds__null_flag 
          SSHORT jrd_279;	// RDB$FIELD_POSITION 
   } jrd_275;
   struct {
          TEXT  jrd_272 [32];	// RDB$RELATION_NAME 
          SSHORT jrd_273;	// RDB$FIELD_POSITION 
          SSHORT jrd_274;	// RDB$FIELD_POSITION 
   } jrd_271;
/***********************************************************
 *
 *  m o d i f y _ l f i e l d _ p o s i t i o n
 ***********************************************************
 *
 *  Functional Description:
 *     Alters the position of a field with respect to the
 *     other fields in the relation.  This will only affect
 *     the order in which the fields will be returned when either
 *     viewing the relation or performing select * from the relation.
 *
 *     The rules of engagement are as follows:
 *          if new_position > original position
 *             increase RDB$FIELD_POSITION for all fields with RDB$FIELD_POSITION
 *             between the new_position and existing position of the field
 *	       then update the position of the field being altered.
 *              just update the position
 *
 *          if new_position < original position
 *             decrease RDB$FIELD_POSITION for all fields with RDB$FIELD_POSITION
 *             between the new_position and existing position of the field
 *	       then update the position of the field being altered.
 *
 *	    if new_position == original_position -- no_op
 *
 ***********************************************************/
	jrd_req* request = NULL;

	try {

/* Find the position of the last field in the relation */
	SLONG max_position = -1;
	DYN_UTIL_generate_field_position(tdbb, gbl, relation_name, &max_position);

/* if the existing position of the field is less than the new position of
 * the field, subtract 1 to move the fields to their new positions otherwise,
 * increase the value in RDB$FIELD_POSITION by one
 */

	bool move_down = false;
	if (existing_position < new_position)
		move_down = true;

/* Retrieve the records for the fields which have a position between the
 * existing field position and the new field position
 */

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$RELATION_FIELDS
		WITH FLD.RDB$RELATION_NAME EQ relation_name.c_str() AND
		FLD.RDB$FIELD_POSITION >= MIN(new_position, existing_position) AND
		FLD.RDB$FIELD_POSITION <= MAX(new_position, existing_position)*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_270, sizeof(jrd_270), true);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_271.jrd_272, 32);
	jrd_271.jrd_273 = MAX(new_position,existing_position);
	jrd_271.jrd_274 = MIN(new_position,existing_position);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 36, (UCHAR*) &jrd_271);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 38, (UCHAR*) &jrd_275);
	   if (!jrd_275.jrd_277) break;
		/*MODIFY FLD USING*/
		{
		
			/* If the field is the one we want, change the position, otherwise
			 * increase the value of RDB$FIELD_POSITION
			 */
			if (field_name == /*FLD.RDB$FIELD_NAME*/
					  jrd_275.jrd_276) {
				if (new_position > max_position)
					/* This prevents gaps in the position sequence of the
					 * fields */
					/*FLD.RDB$FIELD_POSITION*/
					jrd_275.jrd_279 = max_position;
				else
					/*FLD.RDB$FIELD_POSITION*/
					jrd_275.jrd_279 = new_position;
			}
			else {
				if (move_down)
					/*FLD.RDB$FIELD_POSITION*/
					jrd_275.jrd_279 = /*FLD.RDB$FIELD_POSITION*/
   jrd_275.jrd_279 - 1;
				else
					/*FLD.RDB$FIELD_POSITION*/
					jrd_275.jrd_279 = /*FLD.RDB$FIELD_POSITION*/
   jrd_275.jrd_279 + 1;
			}

			/*FLD.RDB$FIELD_POSITION.NULL*/
			jrd_275.jrd_278 = FALSE;
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_275.jrd_276, (char*) jrd_280.jrd_281, 32);
		jrd_280.jrd_282 = jrd_275.jrd_278;
		jrd_280.jrd_283 = jrd_275.jrd_279;
		EXE_send (tdbb, request, 2, 36, (UCHAR*) &jrd_280);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_284);
	   }
	}

	CMP_release(tdbb, request);
	request = NULL;

/* Once the field position has been changed, make sure that there are no
 * duplicate field positions and no gaps in the position sequence (this can
 * not be guaranteed by the query above */

	USHORT new_pos = 0;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$RELATION_FIELDS WITH FLD.RDB$RELATION_NAME EQ relation_name.c_str()
			SORTED BY ASCENDING FLD.RDB$FIELD_POSITION*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_260, sizeof(jrd_260), true);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_261.jrd_262, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_261);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 4, (UCHAR*) &jrd_263);
	   if (!jrd_263.jrd_264) break;

		if (/*FLD.RDB$FIELD_POSITION*/
		    jrd_263.jrd_265 != new_pos) {
			/*MODIFY FLD USING*/
			{
			
				/*FLD.RDB$FIELD_POSITION*/
				jrd_263.jrd_265 = new_pos;
			/*END_MODIFY;*/
			jrd_266.jrd_267 = jrd_263.jrd_265;
			EXE_send (tdbb, request, 2, 2, (UCHAR*) &jrd_266);
			}
		}
		new_pos += 1;
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_268);
	   }
	}

	CMP_release(tdbb, request);
	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 95);
		/* msg 95: "MODIFY RDB$RELATION_FIELDS failed" */
	}
}


static bool check_view_dependency(thread_db* tdbb,
									 Global* gbl,
									 const MetaName& relation_name,
									 const MetaName& field_name)
{
   struct {
          TEXT  jrd_258 [32];	// RDB$VIEW_NAME 
          SSHORT jrd_259;	// gds__utility 
   } jrd_257;
   struct {
          TEXT  jrd_255 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_256 [32];	// RDB$RELATION_NAME 
   } jrd_254;
/***********************************************************
 *
 *  c h e c k _ v i e w _ d e p e n d e n c y
 ***********************************************************
 *
 *  Functional Description:
 *	Checks to see if the given field is referenced in a view. If the field
 *	is referenced in a view, return true, else return false
 *  CVC: The function never has a chance to return true because it punts.
 *
 ***********************************************************/
	jrd_req* request = NULL;
	bool retval = false;
	MetaName view_name;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FIRST 1
			X IN RDB$RELATION_FIELDS CROSS Y IN RDB$RELATION_FIELDS CROSS
			Z IN RDB$VIEW_RELATIONS WITH
			X.RDB$RELATION_NAME EQ relation_name.c_str() AND
			X.RDB$FIELD_NAME EQ field_name.c_str() AND
			X.RDB$FIELD_NAME EQ Y.RDB$BASE_FIELD AND
			X.RDB$FIELD_SOURCE EQ Y.RDB$FIELD_SOURCE AND
			Y.RDB$RELATION_NAME EQ Z.RDB$VIEW_NAME AND
			X.RDB$RELATION_NAME EQ Z.RDB$RELATION_NAME AND
			Y.RDB$VIEW_CONTEXT EQ Z.RDB$VIEW_CONTEXT*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_253, sizeof(jrd_253), true);
	gds__vtov ((const char*) field_name.c_str(), (char*) jrd_254.jrd_255, 32);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_254.jrd_256, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_254);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 34, (UCHAR*) &jrd_257);
	   if (!jrd_257.jrd_259) break;
		retval = true;
		view_name = /*Z.RDB$VIEW_NAME*/
			    jrd_257.jrd_258;
	/*END_FOR;*/
	   }
	}

	CMP_release(tdbb, request);

	if (retval)
		DYN_error_punt(false, 206, SafeArg() << field_name.c_str() <<
						relation_name.c_str() << view_name.c_str());
	/* msg 206: Column %s from table %s is referenced in  %s. */

	return retval;
}


static bool check_sptrig_dependency(thread_db* tdbb,
									   Global* gbl,
									   const MetaName& relation_name,
									   const MetaName& field_name)
{
   struct {
          TEXT  jrd_251 [32];	// RDB$DEPENDENT_NAME 
          SSHORT jrd_252;	// gds__utility 
   } jrd_250;
   struct {
          TEXT  jrd_248 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_249 [32];	// RDB$DEPENDED_ON_NAME 
   } jrd_247;
/***********************************************************
 *
 *  c h e c k _ s p t r i g _ d e p e n d e n c y
 ***********************************************************
 *
 *  Functional Description:
 *	Checks to see if the given field is referenced in a stored procedure
 *	or trigger.  If the field is referenced, return true, else return
 *  false, but true causes the function to punt instead.
 ***********************************************************/
	jrd_req* request = NULL;
	bool retval = false;
	MetaName dep_name;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FIRST 1
			DEP IN RDB$DEPENDENCIES WITH
			DEP.RDB$DEPENDED_ON_NAME EQ relation_name.c_str() AND
			DEP.RDB$FIELD_NAME EQ field_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_246, sizeof(jrd_246), true);
	gds__vtov ((const char*) field_name.c_str(), (char*) jrd_247.jrd_248, 32);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_247.jrd_249, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_247);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 34, (UCHAR*) &jrd_250);
	   if (!jrd_250.jrd_252) break;
		retval = true;
		dep_name = /*DEP.RDB$DEPENDENT_NAME*/
			   jrd_250.jrd_251;
	/*END_FOR;*/
	   }
	}

	CMP_release(tdbb, request);

	if (retval)
		DYN_error_punt(false, 206, SafeArg() << field_name.c_str() <<
						relation_name.c_str() << dep_name.c_str());
	/* msg 206: Column %s from table %s is referenced in %s. */

	return retval;
}


static void modify_lfield_index(thread_db* tdbb,
								Global* gbl,
								const MetaName&	relation_name,
								const MetaName&	field_name,
								const MetaName&	new_fld_name)
{
   struct {
          TEXT  jrd_245 [32];	// RDB$FIELD_NAME 
   } jrd_244;
   struct {
          SSHORT jrd_243;	// gds__utility 
   } jrd_242;
   struct {
          TEXT  jrd_241 [32];	// RDB$INDEX_NAME 
   } jrd_240;
   struct {
          TEXT  jrd_237 [32];	// RDB$INDEX_NAME 
          TEXT  jrd_238 [32];	// RDB$FIELD_NAME 
          SSHORT jrd_239;	// gds__utility 
   } jrd_236;
   struct {
          TEXT  jrd_234 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_235 [32];	// RDB$RELATION_NAME 
   } jrd_233;
/***********************************************************
 *
 *  m o d i f y _ l f i e l d _ i n d e x
 ***********************************************************
 *
 *  Functional Description:
 *	Updates the field names in an index and forces the index to be rebuilt
 *	with the new field names
 *
 ***********************************************************/
	jrd_req* request = NULL;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		IDX IN RDB$INDICES CROSS IDXS IN RDB$INDEX_SEGMENTS WITH
			IDX.RDB$INDEX_NAME EQ IDXS.RDB$INDEX_NAME AND
			IDX.RDB$RELATION_NAME EQ relation_name.c_str() AND
			IDXS.RDB$FIELD_NAME EQ field_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_232, sizeof(jrd_232), true);
	gds__vtov ((const char*) field_name.c_str(), (char*) jrd_233.jrd_234, 32);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_233.jrd_235, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_233);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 66, (UCHAR*) &jrd_236);
	   if (!jrd_236.jrd_239) break;
			/* Change the name of the field in the index */
		/*MODIFY IDXS USING*/
		{
		
			memcpy(/*IDXS.RDB$FIELD_NAME*/
			       jrd_236.jrd_238, new_fld_name.c_str(), sizeof(/*IDXS.RDB$FIELD_NAME*/
			       jrd_236.jrd_238));
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_236.jrd_238, (char*) jrd_244.jrd_245, 32);
		EXE_send (tdbb, request, 4, 32, (UCHAR*) &jrd_244);
		}

		/* Set the index name to itself to tell the index to rebuild */
		/*MODIFY IDX USING*/
		{
		
			// This is to fool both gpre and gcc.
			char* p = /*IDX.RDB$INDEX_NAME*/
				  jrd_236.jrd_237;
			p[MAX_SQL_IDENTIFIER_LEN] = 0;
		/*END_MODIFY;*/
		gds__vtov((const char*) jrd_236.jrd_237, (char*) jrd_240.jrd_241, 32);
		EXE_send (tdbb, request, 2, 32, (UCHAR*) &jrd_240);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_242);
	   }
	}

	CMP_release(tdbb, request);
}


static bool field_exists(thread_db* tdbb,
						 Global* gbl,
						 const MetaName& relation_name,
						 const MetaName& field_name)
{
   struct {
          SSHORT jrd_231;	// gds__utility 
   } jrd_230;
   struct {
          TEXT  jrd_228 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_229 [32];	// RDB$RELATION_NAME 
   } jrd_227;
/***********************************************************
 *
 *  f i e l d _ e x i s t s
 ***********************************************************
 *
 *  Functional Description:
 *	Checks to see if the given field already exists in a relation
 ***********************************************************/
	jrd_req* request = NULL;
	bool retval = false;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$RELATION_FIELDS WITH
			FLD.RDB$RELATION_NAME EQ relation_name.c_str() AND
			FLD.RDB$FIELD_NAME EQ field_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_226, sizeof(jrd_226), true);
	gds__vtov ((const char*) field_name.c_str(), (char*) jrd_227.jrd_228, 32);
	gds__vtov ((const char*) relation_name.c_str(), (char*) jrd_227.jrd_229, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_227);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 2, (UCHAR*) &jrd_230);
	   if (!jrd_230.jrd_231) break;
		retval = true;
	/*END_FOR;*/
	   }
	}

	CMP_release(tdbb, request);
	return retval;
}


static bool domain_exists(thread_db* tdbb,
						  Global* gbl,
						  const MetaName& field_name)
{
   struct {
          SSHORT jrd_225;	// gds__utility 
   } jrd_224;
   struct {
          TEXT  jrd_223 [32];	// RDB$FIELD_NAME 
   } jrd_222;
/***********************************************************
 *
 *  d o m a i n _ e x i s t s
 ***********************************************************
 *
 *  Functional Description:
 *	Checks to see if the given field already exists in a relation
 ***********************************************************/
	jrd_req* request = NULL;
	bool retval = false;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME EQ field_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_221, sizeof(jrd_221), true);
	gds__vtov ((const char*) field_name.c_str(), (char*) jrd_222.jrd_223, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_222);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 2, (UCHAR*) &jrd_224);
	   if (!jrd_224.jrd_225) break;
		retval = true;
	/*END_FOR;*/
	   }
	}

	CMP_release(tdbb, request);
	return retval;
}


void DYN_modify_sql_field(Global* gbl,
						  const UCHAR** ptr,
						  const MetaName* relation_name)
{
   struct {
          SSHORT jrd_81;	// gds__utility 
   } jrd_80;
   struct {
          bid  jrd_56;	// RDB$DEFAULT_SOURCE 
          bid  jrd_57;	// RDB$DEFAULT_VALUE 
          bid  jrd_58;	// RDB$COMPUTED_BLR 
          bid  jrd_59;	// RDB$COMPUTED_SOURCE 
          SSHORT jrd_60;	// gds__null_flag 
          SSHORT jrd_61;	// RDB$FIELD_TYPE 
          SSHORT jrd_62;	// gds__null_flag 
          SSHORT jrd_63;	// RDB$FIELD_SCALE 
          SSHORT jrd_64;	// gds__null_flag 
          SSHORT jrd_65;	// RDB$FIELD_PRECISION 
          SSHORT jrd_66;	// gds__null_flag 
          SSHORT jrd_67;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_68;	// gds__null_flag 
          SSHORT jrd_69;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_70;	// gds__null_flag 
          SSHORT jrd_71;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_72;	// gds__null_flag 
          SSHORT jrd_73;	// RDB$COLLATION_ID 
          SSHORT jrd_74;	// gds__null_flag 
          SSHORT jrd_75;	// RDB$FIELD_LENGTH 
          SSHORT jrd_76;	// gds__null_flag 
          SSHORT jrd_77;	// gds__null_flag 
          SSHORT jrd_78;	// gds__null_flag 
          SSHORT jrd_79;	// gds__null_flag 
   } jrd_55;
   struct {
          bid  jrd_30;	// RDB$COMPUTED_SOURCE 
          bid  jrd_31;	// RDB$COMPUTED_BLR 
          bid  jrd_32;	// RDB$DEFAULT_VALUE 
          bid  jrd_33;	// RDB$DEFAULT_SOURCE 
          SSHORT jrd_34;	// gds__utility 
          SSHORT jrd_35;	// gds__null_flag 
          SSHORT jrd_36;	// gds__null_flag 
          SSHORT jrd_37;	// gds__null_flag 
          SSHORT jrd_38;	// gds__null_flag 
          SSHORT jrd_39;	// gds__null_flag 
          SSHORT jrd_40;	// RDB$FIELD_LENGTH 
          SSHORT jrd_41;	// gds__null_flag 
          SSHORT jrd_42;	// RDB$COLLATION_ID 
          SSHORT jrd_43;	// gds__null_flag 
          SSHORT jrd_44;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_45;	// gds__null_flag 
          SSHORT jrd_46;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_47;	// gds__null_flag 
          SSHORT jrd_48;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_49;	// gds__null_flag 
          SSHORT jrd_50;	// RDB$FIELD_PRECISION 
          SSHORT jrd_51;	// gds__null_flag 
          SSHORT jrd_52;	// RDB$FIELD_SCALE 
          SSHORT jrd_53;	// gds__null_flag 
          SSHORT jrd_54;	// RDB$FIELD_TYPE 
   } jrd_29;
   struct {
          TEXT  jrd_28 [32];	// RDB$FIELD_SOURCE 
   } jrd_27;
   struct {
          SSHORT jrd_92;	// gds__utility 
   } jrd_91;
   struct {
          TEXT  jrd_90 [32];	// RDB$FIELD_SOURCE 
   } jrd_89;
   struct {
          TEXT  jrd_87 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_88;	// gds__utility 
   } jrd_86;
   struct {
          TEXT  jrd_84 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_85 [32];	// RDB$RELATION_NAME 
   } jrd_83;
   struct {
          TEXT  jrd_95 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_96 [128];	// RDB$EDIT_STRING 
          bid  jrd_97;	// RDB$VALIDATION_SOURCE 
          bid  jrd_98;	// RDB$VALIDATION_BLR 
          bid  jrd_99;	// RDB$DEFAULT_SOURCE 
          bid  jrd_100;	// RDB$DEFAULT_VALUE 
          bid  jrd_101;	// RDB$COMPUTED_SOURCE 
          bid  jrd_102;	// RDB$COMPUTED_BLR 
          SSHORT jrd_103;	// gds__null_flag 
          SSHORT jrd_104;	// RDB$FIELD_LENGTH 
          SSHORT jrd_105;	// gds__null_flag 
          SSHORT jrd_106;	// RDB$FIELD_TYPE 
          SSHORT jrd_107;	// gds__null_flag 
          SSHORT jrd_108;	// RDB$COLLATION_ID 
          SSHORT jrd_109;	// gds__null_flag 
          SSHORT jrd_110;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_111;	// gds__null_flag 
          SSHORT jrd_112;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_113;	// gds__null_flag 
          SSHORT jrd_114;	// RDB$DIMENSIONS 
          SSHORT jrd_115;	// gds__null_flag 
          SSHORT jrd_116;	// gds__null_flag 
          SSHORT jrd_117;	// RDB$NULL_FLAG 
          SSHORT jrd_118;	// gds__null_flag 
          SSHORT jrd_119;	// gds__null_flag 
          SSHORT jrd_120;	// gds__null_flag 
          SSHORT jrd_121;	// gds__null_flag 
          SSHORT jrd_122;	// gds__null_flag 
          SSHORT jrd_123;	// gds__null_flag 
          SSHORT jrd_124;	// gds__null_flag 
          SSHORT jrd_125;	// RDB$SEGMENT_LENGTH 
          SSHORT jrd_126;	// gds__null_flag 
          SSHORT jrd_127;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_128;	// gds__null_flag 
          SSHORT jrd_129;	// RDB$FIELD_PRECISION 
          SSHORT jrd_130;	// gds__null_flag 
          SSHORT jrd_131;	// RDB$FIELD_SCALE 
          SSHORT jrd_132;	// gds__null_flag 
          SSHORT jrd_133;	// RDB$SYSTEM_FLAG 
   } jrd_94;
   struct {
          SSHORT jrd_144;	// gds__utility 
   } jrd_143;
   struct {
          TEXT  jrd_142 [32];	// RDB$FIELD_SOURCE 
   } jrd_141;
   struct {
          TEXT  jrd_139 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_140;	// gds__utility 
   } jrd_138;
   struct {
          TEXT  jrd_136 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_137 [32];	// RDB$RELATION_NAME 
   } jrd_135;
   struct {
          SSHORT jrd_153;	// gds__utility 
   } jrd_152;
   struct {
          SSHORT jrd_151;	// gds__utility 
   } jrd_150;
   struct {
          SSHORT jrd_149;	// gds__utility 
   } jrd_148;
   struct {
          TEXT  jrd_147 [32];	// RDB$FIELD_SOURCE 
   } jrd_146;
   struct {
          bid  jrd_158;	// RDB$DEFAULT_VALUE 
          bid  jrd_159;	// RDB$COMPUTED_BLR 
          SSHORT jrd_160;	// gds__utility 
          SSHORT jrd_161;	// gds__null_flag 
          SSHORT jrd_162;	// RDB$DIMENSIONS 
          SSHORT jrd_163;	// gds__null_flag 
          SSHORT jrd_164;	// RDB$NULL_FLAG 
          SSHORT jrd_165;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_166;	// RDB$FIELD_PRECISION 
          SSHORT jrd_167;	// RDB$COLLATION_ID 
          SSHORT jrd_168;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_169;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_170;	// RDB$FIELD_LENGTH 
          SSHORT jrd_171;	// RDB$FIELD_SCALE 
          SSHORT jrd_172;	// RDB$FIELD_TYPE 
   } jrd_157;
   struct {
          TEXT  jrd_156 [32];	// RDB$FIELD_SOURCE 
   } jrd_155;
   struct {
          TEXT  jrd_215 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_216;	// gds__null_flag 
          SSHORT jrd_217;	// gds__null_flag 
          SSHORT jrd_218;	// RDB$UPDATE_FLAG 
          SSHORT jrd_219;	// gds__null_flag 
          SSHORT jrd_220;	// RDB$COLLATION_ID 
   } jrd_214;
   struct {
          TEXT  jrd_212 [32];	// RDB$FIELD_SOURCE 
          SSHORT jrd_213;	// gds__null_flag 
   } jrd_211;
   struct {
          bid  jrd_207;	// RDB$DEFAULT_VALUE 
          bid  jrd_208;	// RDB$DEFAULT_SOURCE 
          SSHORT jrd_209;	// gds__null_flag 
          SSHORT jrd_210;	// gds__null_flag 
   } jrd_206;
   struct {
          SSHORT jrd_204;	// gds__null_flag 
          SSHORT jrd_205;	// RDB$UPDATE_FLAG 
   } jrd_203;
   struct {
          SSHORT jrd_202;	// gds__utility 
   } jrd_201;
   struct {
          TEXT  jrd_197 [32];	// RDB$BASE_FIELD 
          SSHORT jrd_198;	// gds__null_flag 
          SSHORT jrd_199;	// RDB$FIELD_POSITION 
          SSHORT jrd_200;	// RDB$VIEW_CONTEXT 
   } jrd_196;
   struct {
          bid  jrd_178;	// RDB$DEFAULT_SOURCE 
          bid  jrd_179;	// RDB$DEFAULT_VALUE 
          TEXT  jrd_180 [32];	// RDB$BASE_FIELD 
          TEXT  jrd_181 [32];	// RDB$RELATION_NAME 
          TEXT  jrd_182 [32];	// RDB$FIELD_SOURCE 
          bid  jrd_183;	// RDB$VIEW_BLR 
          SSHORT jrd_184;	// gds__utility 
          SSHORT jrd_185;	// RDB$VIEW_CONTEXT 
          SSHORT jrd_186;	// RDB$FIELD_POSITION 
          SSHORT jrd_187;	// gds__null_flag 
          SSHORT jrd_188;	// gds__null_flag 
          SSHORT jrd_189;	// gds__null_flag 
          SSHORT jrd_190;	// RDB$COLLATION_ID 
          SSHORT jrd_191;	// gds__null_flag 
          SSHORT jrd_192;	// RDB$UPDATE_FLAG 
          SSHORT jrd_193;	// gds__null_flag 
          SSHORT jrd_194;	// gds__null_flag 
          SSHORT jrd_195;	// gds__null_flag 
   } jrd_177;
   struct {
          TEXT  jrd_175 [32];	// RDB$FIELD_NAME 
          TEXT  jrd_176 [32];	// RDB$RELATION_NAME 
   } jrd_174;
/**************************************
 *
 *	D Y N _ m o d i f y _ s q l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Execute a dynamic ddl statement
 *      to modify the datatype of a field.
 *
 *  If there are dependencies on the field, abort the operation
 *  unless the dependency is an index.  In this case, rebuild the
 *  index once the operation has completed.
 *
 *  If the original datatype of the field was a domain:
 *     if the new type is a domain, just make the change to the new domain
 *     if it exists
 *
 *     if the new type is a base type, just make the change
 *
 *  If the original datatype of the field was a base type:
 *     if the new type is a base type, just make the change
 *
 *     if the new type is a domain, make the change to the field
 *     definition and remove the entry for RDB$FIELD_SOURCE from the original
 *     field.  In other words ... clean up after ourselves
 *
 *  The following conversions are not allowed:
 *        Blob to anything
 *        Array to anything
 *        Date to anything
 *        Char to any numeric
 *        Varchar to any numeric
 *        Anything to Blob
 *        Anything to Array
 *
 *  The following operations return a warning
 *        Decreasing the length of a char (varchar) field
 *
 *	CVC: This is a misleading comment. There's no code that
 *	produces a warning. This condition raises an error, too.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	dyn_fld orig_fld, new_fld, dom_fld;

	try {

	GET_STRING(ptr, orig_fld.dyn_fld_name);

	// Check to see if the field being altered is involved in any type of dependency.
	// If there is a dependency, call DYN_error_punt (inside the function).
	fb_assert(relation_name);

	// ASF: check disabled to allow change of field type to be used
	// with TYPE OF COLUMN table.column feature.
	//check_sptrig_dependency(tdbb, gbl, *relation_name,
	//						orig_fld.dyn_fld_name);

	jrd_req* request = NULL;
	jrd_req* first_request = NULL;
	bool found = false;
	bool dtype, scale, prec, subtype, charlen, collation, fldlen, nullflg, charset;
	dtype = scale = prec = subtype = charlen = collation = fldlen = nullflg = charset = false;

	int field_adjusted_count = 0;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		RFR IN RDB$RELATION_FIELDS CROSS
		REL IN RDB$RELATIONS WITH
			REL.RDB$RELATION_NAME = RFR.RDB$RELATION_NAME AND
			RFR.RDB$RELATION_NAME = relation_name->c_str() AND
			RFR.RDB$FIELD_NAME = orig_fld.dyn_fld_name.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_173, sizeof(jrd_173), true);
	gds__vtov ((const char*) orig_fld.dyn_fld_name.c_str(), (char*) jrd_174.jrd_175, 32);
	gds__vtov ((const char*) relation_name->c_str(), (char*) jrd_174.jrd_176, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_174);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 144, (UCHAR*) &jrd_177);
	   if (!jrd_177.jrd_184) break;
		first_request = request;
		request = NULL;

		found = true;
		bool is_view = !/*REL.RDB$VIEW_BLR.NULL*/
				jrd_177.jrd_195;
		bool has_dimensions = false;
		bool update_domain = false;
		bool domain_has_default = false;
		bool domain_is_computed = false;
		SSHORT fld_position = 0;
		bool fld_position_change = false;
		SSHORT view_context = 0;
		bool view_context_change = false;
		MetaName fld_base_field;
		bool fld_base_field_change = false;
		bool orig_computed = false;

		/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
			FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME = RFR.RDB$FIELD_SOURCE*/
		{
		if (!request)
		   request = CMP_compile2 (tdbb, (UCHAR*) jrd_154, sizeof(jrd_154), true);
		gds__vtov ((const char*) jrd_177.jrd_182, (char*) jrd_155.jrd_156, 32);
		EXE_start (tdbb, request, gbl->gbl_transaction);
		EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_155);
		while (1)
		   {
		   EXE_receive (tdbb, request, 1, 42, (UCHAR*) &jrd_157);
		   if (!jrd_157.jrd_160) break;
			// Get information about the original field type.  If a conversion
			// can not be at any time made between the two datatypes, error.
			DSC_make_descriptor(&orig_fld.dyn_dsc,
								/*FLD.RDB$FIELD_TYPE*/
								jrd_157.jrd_172,
								/*FLD.RDB$FIELD_SCALE*/
								jrd_157.jrd_171,
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_157.jrd_170,
								/*FLD.RDB$FIELD_SUB_TYPE*/
								jrd_157.jrd_169,
								/*FLD.RDB$CHARACTER_SET_ID*/
								jrd_157.jrd_168,
								/*FLD.RDB$COLLATION_ID*/
								jrd_157.jrd_167);

			orig_fld.dyn_charbytelen = /*FLD.RDB$FIELD_LENGTH*/
						   jrd_157.jrd_170;
			orig_fld.dyn_dtype = /*FLD.RDB$FIELD_TYPE*/
					     jrd_157.jrd_172;
			orig_fld.dyn_precision = /*FLD.RDB$FIELD_PRECISION*/
						 jrd_157.jrd_166;
			orig_fld.dyn_sub_type = /*FLD.RDB$FIELD_SUB_TYPE*/
						jrd_157.jrd_169;
			orig_fld.dyn_charlen = /*FLD.RDB$CHARACTER_LENGTH*/
					       jrd_157.jrd_165;
			orig_fld.dyn_collation = /*FLD.RDB$COLLATION_ID*/
						 jrd_157.jrd_167;
			orig_fld.dyn_null_flag = /*FLD.RDB$NULL_FLAG*/
						 jrd_157.jrd_164 != 0;
			orig_fld.dyn_fld_source = /*RFR.RDB$FIELD_SOURCE*/
						  jrd_177.jrd_182;
			orig_computed = !/*FLD.RDB$COMPUTED_BLR.NULL*/
					 jrd_157.jrd_163;

			// If the original field type is an array, force its blr type to blr_blob
			if (/*FLD.RDB$DIMENSIONS*/
			    jrd_157.jrd_162 != 0)
			{
				orig_fld.dyn_dtype = blr_blob;
				has_dimensions = true;
			}

			domain_has_default = !/*FLD.RDB$DEFAULT_VALUE.NULL*/
					      jrd_157.jrd_161;
			domain_is_computed = !/*FLD.RDB$COMPUTED_BLR.NULL*/
					      jrd_157.jrd_163;

			UCHAR verb;
			while ((verb = *(*ptr)++) != isc_dyn_end) {
				switch (verb)
				{
				case isc_dyn_fld_source:
					GET_STRING(ptr, dom_fld.dyn_fld_source);
					if (fb_utils::implicit_domain(dom_fld.dyn_fld_source.c_str()))
					{
						DYN_error_punt(false, 224, SafeArg() << dom_fld.dyn_fld_source.c_str() <<
										orig_fld.dyn_fld_name.c_str());
						// msg 224: "Cannot use the internal domain %s as new type for field %s".
					}
					get_domain_type(tdbb, gbl, dom_fld);
					update_domain = true;
					break;

				case isc_dyn_rel_name:
					GET_STRING(ptr, new_fld.dyn_rel_name);
					break;

				case isc_dyn_fld_length:
					fldlen = true;
					new_fld.dyn_dsc.dsc_length = DYN_get_number(ptr);
					if (++field_adjusted_count > 2)
					{
						DYN_error_punt(false, 149, orig_fld.dyn_fld_name.c_str());
						// msg 149: "Only one data type change to the field %s allowed at a time"
					}

					switch (new_fld.dyn_dtype)
					{
					case blr_text:
					case blr_text2:
					case blr_varying:
					case blr_varying2:
					case blr_cstring:
					case blr_cstring2:
						new_fld.dyn_charbytelen = new_fld.dyn_dsc.dsc_length;
						break;
					default:
						new_fld.dyn_charbytelen = 0; // It won't be used, anyway.
						break;
					}
					break;

				case isc_dyn_fld_type:
					dtype = true;
					new_fld.dyn_dtype = DYN_get_number(ptr);
					if (++field_adjusted_count > 2)
					{
						DYN_error_punt(false, 149, orig_fld.dyn_fld_name.c_str());
						// msg 149: "Only one data type change to the field %s allowed at a time"
					}

					switch (new_fld.dyn_dtype)
					{
					case blr_text:
					case blr_text2:
					case blr_varying:
					case blr_varying2:
					case blr_cstring:
					case blr_cstring2:
						if (new_fld.dyn_dsc.dsc_length && !new_fld.dyn_charbytelen)
							new_fld.dyn_charbytelen = new_fld.dyn_dsc.dsc_length;
						new_fld.dyn_dsc.dsc_length = DSC_string_length (&new_fld.dyn_dsc);
						break;

					case blr_short:
						new_fld.dyn_dsc.dsc_length = 2;
						break;

					case blr_long:
					case blr_float:
						new_fld.dyn_dsc.dsc_length = 4;
						break;

					case blr_int64:
					case blr_sql_time:
					case blr_sql_date:
					case blr_timestamp:
					case blr_double:
					case blr_d_float:
						new_fld.dyn_dsc.dsc_length = 8;
						break;

					default:
						break;
					}
					break;

				case isc_dyn_fld_scale:
					scale = true;
					new_fld.dyn_dsc.dsc_scale = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_precision:
					prec = true;
					new_fld.dyn_precision = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_sub_type:
					subtype = true;
					new_fld.dyn_sub_type = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_char_length:
					charlen = true;
					new_fld.dyn_charlen = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_collation:
					collation = true;
					new_fld.dyn_collation = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_character_set:
					charset = true;
					new_fld.dyn_charset = DYN_get_number(ptr);
					break;

				case isc_dyn_fld_not_null:
					nullflg = true;
					new_fld.dyn_null_flag = true;
					break;

				case isc_dyn_fld_dimensions:
					new_fld.dyn_dtype = blr_blob;
					break;

				case isc_dyn_fld_position:
					fld_position = DYN_get_number(ptr);
					fld_position_change = true;
					break;

				case isc_dyn_fld_base_fld:
					GET_STRING(ptr, fld_base_field);
					fld_base_field_change = true;
					break;

				case isc_dyn_view_context:
					view_context = DYN_get_number(ptr);
					view_context_change = true;
					break;

				case isc_dyn_fld_computed_blr:
					domain_is_computed = true;
					new_fld.dyn_computed_val = *ptr;
					DYN_skip_attribute(ptr);
					break;

				case isc_dyn_fld_computed_source:
					new_fld.dyn_computed_src = *ptr;
					DYN_skip_attribute(ptr);
					break;

				case isc_dyn_del_computed:
					domain_is_computed = false;
					new_fld.dyn_drop_computed = true;
					break;

				case isc_dyn_del_default:
					new_fld.dyn_drop_default = true;
					break;

				case isc_dyn_fld_default_value:
					if (has_dimensions)
					{
						DYN_error_punt(false, 225, orig_fld.dyn_fld_name.c_str());
						// msg 225: "Default value is not allowed for array type in field %s"
					}
					new_fld.dyn_default_val = *ptr;
					DYN_skip_attribute(ptr);
					break;

				case isc_dyn_fld_default_source:
					if (has_dimensions)
					{
						DYN_error_punt(false, 225, orig_fld.dyn_fld_name.c_str());
						// msg 225: "Default value is not allowed for array type in field %s"
					}
					new_fld.dyn_default_src = *ptr;
					DYN_skip_attribute(ptr);
					break;

				// These should only be defined for BLOB types and should not come through with
				// any other types.  BLOB types are detected above
				case isc_dyn_fld_segment_length:
					DYN_get_number(ptr);
					break;

				default:
					--(*ptr);
					MetaTmp(/*RFR.RDB$FIELD_SOURCE*/
						jrd_177.jrd_182)
						DYN_execute(gbl, ptr, relation_name, &tmp, NULL, NULL, NULL);
				}
			}

			if (fld_base_field_change && view_context_change)
			{
				fb_assert(is_view);

				if (fld_base_field.hasData())
				{
					char field_name[MAX_SQL_IDENTIFIER_SIZE];
					DYN_UTIL_find_field_source(tdbb, gbl, /*RFR.RDB$RELATION_NAME*/
									      jrd_177.jrd_181, view_context,
						fld_base_field.c_str(), field_name);
					dom_fld.dyn_fld_source = field_name;
					update_domain = true;
				}
				else
					DYN_UTIL_generate_field_name(tdbb, gbl, new_fld.dyn_fld_source);
			}
		/*END_FOR;*/
		   }
		} // FLD in RDB$FIELDS
		CMP_release(tdbb, request);
		request = NULL;

		if (!is_view &&
			((new_fld.dyn_computed_val && !orig_computed) ||
				(!new_fld.dyn_computed_val && orig_computed)))
		{
			// Cannot add or remove COMPUTED from column @1
			DYN_error_punt(false, 249, SafeArg() << orig_fld.dyn_fld_name.c_str());
		}

		const bool sourceIsInternalDomain =
			fb_utils::implicit_domain(orig_fld.dyn_fld_source.c_str()) && /*RFR.RDB$BASE_FIELD.NULL*/
										      jrd_177.jrd_194;
		const bool changeComputed = new_fld.dyn_computed_val || new_fld.dyn_drop_computed;

		// Now that we have all of the information needed, let's check to see
		// if the field type can be modified

		if (update_domain)
		{
			// a1. Internal domain -> domain.
			// a2. Domain -> domain.

			/* CVC: Since get_domain_type() called above already called DSC_make_descriptor,
					there's no point in calling it again, since it will increment AGAIN the length
					of varchar fields! This bug detected thanks to new check field dyn_charbytelen.
			DSC_make_descriptor(&dom_fld.dyn_dsc,
								dom_fld.dyn_dtype,
								dom_fld.dyn_dsc.dsc_scale,
								dom_fld.dyn_dsc.dsc_length,
								dom_fld.dyn_sub_type,
								dom_fld.dyn_charset, dom_fld.dyn_collation);
			*/

			if (!domain_is_computed && !is_view)
			{
				const ULONG retval = check_update_fld_type(orig_fld, dom_fld);
				if (retval != FB_SUCCESS)
					modify_err_punt(tdbb, retval, orig_fld, dom_fld);
			}

			// If the original definition was a base field type, remove the entries from RDB$FIELDS
			if (sourceIsInternalDomain)
			{
				// a1. Internal domain -> domain.
				/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
					FLD IN RDB$FIELDS
					WITH FLD.RDB$FIELD_NAME = RFR.RDB$FIELD_SOURCE*/
				{
				if (!request)
				   request = CMP_compile2 (tdbb, (UCHAR*) jrd_145, sizeof(jrd_145), true);
				gds__vtov ((const char*) jrd_177.jrd_182, (char*) jrd_146.jrd_147, 32);
				EXE_start (tdbb, request, gbl->gbl_transaction);
				EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_146);
				while (1)
				   {
				   EXE_receive (tdbb, request, 1, 2, (UCHAR*) &jrd_148);
				   if (!jrd_148.jrd_149) break;

					/*ERASE FLD;*/
					EXE_send (tdbb, request, 2, 2, (UCHAR*) &jrd_150);
				/*END_FOR;*/
				   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_152);
				   }
				}

				CMP_release(tdbb, request);
				request = NULL;
			}
			request = first_request;
			/*MODIFY RFR USING*/
			{
			
				strcpy(/*RFR.RDB$FIELD_SOURCE*/
				       jrd_177.jrd_182, dom_fld.dyn_fld_source.c_str());
				/*RFR.RDB$FIELD_SOURCE.NULL*/
				jrd_177.jrd_193 = FALSE;
				if (domain_is_computed)
				{
					/*RFR.RDB$UPDATE_FLAG.NULL*/
					jrd_177.jrd_191 = FALSE;
					/*RFR.RDB$UPDATE_FLAG*/
					jrd_177.jrd_192 = 1;
				}

				/*RFR.RDB$COLLATION_ID.NULL*/
				jrd_177.jrd_189 = TRUE;	// CORE-2426
			/*END_MODIFY;*/
			gds__vtov((const char*) jrd_177.jrd_182, (char*) jrd_214.jrd_215, 32);
			jrd_214.jrd_216 = jrd_177.jrd_193;
			jrd_214.jrd_217 = jrd_177.jrd_191;
			jrd_214.jrd_218 = jrd_177.jrd_192;
			jrd_214.jrd_219 = jrd_177.jrd_189;
			jrd_214.jrd_220 = jrd_177.jrd_190;
			EXE_send (tdbb, request, 7, 42, (UCHAR*) &jrd_214);
			}
			first_request = request;
			request = NULL;

			if (ENCODE_ODS(dbb->dbb_ods_version, dbb->dbb_minor_original) >= ODS_11_2)
			{
				/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
					PRM IN RDB$PROCEDURE_PARAMETERS
					WITH PRM.RDB$RELATION_NAME = relation_name->c_str() AND
						 PRM.RDB$FIELD_NAME = orig_fld.dyn_fld_name.c_str()*/
				{
				if (!request)
				   request = CMP_compile2 (tdbb, (UCHAR*) jrd_134, sizeof(jrd_134), true);
				gds__vtov ((const char*) orig_fld.dyn_fld_name.c_str(), (char*) jrd_135.jrd_136, 32);
				gds__vtov ((const char*) relation_name->c_str(), (char*) jrd_135.jrd_137, 32);
				EXE_start (tdbb, request, gbl->gbl_transaction);
				EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_135);
				while (1)
				   {
				   EXE_receive (tdbb, request, 1, 34, (UCHAR*) &jrd_138);
				   if (!jrd_138.jrd_140) break;

					/*MODIFY PRM USING*/
					{
					
						strcpy(/*PRM.RDB$FIELD_SOURCE*/
						       jrd_138.jrd_139, dom_fld.dyn_fld_source.c_str());
					/*END_MODIFY;*/
					gds__vtov((const char*) jrd_138.jrd_139, (char*) jrd_141.jrd_142, 32);
					EXE_send (tdbb, request, 2, 32, (UCHAR*) &jrd_141);
					}
				/*END_FOR;*/
				   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_143);
				   }
				}

				CMP_release(tdbb, request);
				request = NULL;
			}
		}
		else
		{
			// b1. Domain -> internal domain.
			// b2. Internal domain -> internal domain.

			const UCHAR* defVal = new_fld.dyn_default_val;
			const UCHAR* defSrc = new_fld.dyn_default_src;
			const bool dropDefault = new_fld.dyn_drop_default;
			const bool changeDefault = defVal || defSrc || dropDefault;

			// If we are altering only the default, we need the old field settings.
			if (changeDefault && !new_fld.dyn_dsc.dsc_dtype)
			{
				new_fld = orig_fld;
				// We already called DSC_make_descriptor on orig_fld, so fix new_fld.
				switch (new_fld.dyn_dtype)
				{
				case blr_text:
				case blr_varying:
				case blr_cstring:
				    new_fld.dyn_dsc.dsc_length = DSC_string_length(&orig_fld.dyn_dsc);
					break;
				}
			}

			DSC_make_descriptor(&new_fld.dyn_dsc,
								new_fld.dyn_dtype,
								new_fld.dyn_dsc.dsc_scale,
								new_fld.dyn_dsc.dsc_length,
								new_fld.dyn_sub_type,
								new_fld.dyn_charset, new_fld.dyn_collation);

			if (!changeComputed && !orig_computed && !is_view)
			{
				const ULONG retval = check_update_fld_type(orig_fld, new_fld);
				if (retval != FB_SUCCESS)
					modify_err_punt(tdbb, retval, orig_fld, new_fld);
			}

			// Check to see if the original data type for the field was based on a domain.  If it
			// was (and now it isn't), remove the domain information and replace it with a generated
			// field name for RDB$FIELDS

			if (!changeDefault && !sourceIsInternalDomain)
			{
				// b1. Domain -> internal domain. Not for changing DEFAULT value.

				request = first_request;
				/*MODIFY RFR USING*/
				{
				
					DYN_UTIL_generate_field_name(tdbb, gbl, /*RFR.RDB$FIELD_SOURCE*/
										jrd_177.jrd_182);
					new_fld.dyn_fld_source = /*RFR.RDB$FIELD_SOURCE*/
								 jrd_177.jrd_182;
				/*END_MODIFY;*/
				gds__vtov((const char*) jrd_177.jrd_182, (char*) jrd_211.jrd_212, 32);
				jrd_211.jrd_213 = jrd_177.jrd_193;
				EXE_send (tdbb, request, 6, 34, (UCHAR*) &jrd_211);
				}
				first_request = request;
				request = NULL;

				/*STORE(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
					FLD IN RDB$FIELDS*/
				{
				
					/*FLD.RDB$SYSTEM_FLAG*/
					jrd_94.jrd_133 = 0;
					/*FLD.RDB$SYSTEM_FLAG.NULL*/
					jrd_94.jrd_132 = FALSE;
					/*FLD.RDB$FIELD_SCALE.NULL*/
					jrd_94.jrd_130 = TRUE;
					/*FLD.RDB$FIELD_PRECISION.NULL*/
					jrd_94.jrd_128 = TRUE;
					/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
					jrd_94.jrd_126 = TRUE;
					/*FLD.RDB$SEGMENT_LENGTH.NULL*/
					jrd_94.jrd_124 = TRUE;
					/*FLD.RDB$COMPUTED_BLR.NULL*/
					jrd_94.jrd_123 = TRUE;
					/*FLD.RDB$COMPUTED_SOURCE.NULL*/
					jrd_94.jrd_122 = TRUE;
					/*FLD.RDB$DEFAULT_VALUE.NULL*/
					jrd_94.jrd_121 = TRUE;
					/*FLD.RDB$DEFAULT_SOURCE.NULL*/
					jrd_94.jrd_120 = TRUE;
					/*FLD.RDB$VALIDATION_BLR.NULL*/
					jrd_94.jrd_119 = TRUE;
					/*FLD.RDB$VALIDATION_SOURCE.NULL*/
					jrd_94.jrd_118 = TRUE;
					/*FLD.RDB$NULL_FLAG.NULL*/
					jrd_94.jrd_116 = TRUE;
					/*FLD.RDB$EDIT_STRING.NULL*/
					jrd_94.jrd_115 = TRUE;
					/*FLD.RDB$DIMENSIONS.NULL*/
					jrd_94.jrd_113 = TRUE;
					/*FLD.RDB$CHARACTER_LENGTH.NULL*/
					jrd_94.jrd_111 = TRUE;
					/*FLD.RDB$CHARACTER_SET_ID.NULL*/
					jrd_94.jrd_109 = TRUE;
					/*FLD.RDB$COLLATION_ID.NULL*/
					jrd_94.jrd_107 = TRUE;

					if (dtype) {
						/*FLD.RDB$FIELD_TYPE*/
						jrd_94.jrd_106 = new_fld.dyn_dtype;
						/*FLD.RDB$FIELD_TYPE.NULL*/
						jrd_94.jrd_105 = FALSE;
					}

					if (scale) {
						/*FLD.RDB$FIELD_SCALE*/
						jrd_94.jrd_131 = new_fld.dyn_dsc.dsc_scale;
						/*FLD.RDB$FIELD_SCALE.NULL*/
						jrd_94.jrd_130 = FALSE;
					}

					if (prec) {
						/*FLD.RDB$FIELD_PRECISION*/
						jrd_94.jrd_129 = new_fld.dyn_precision;
						/*FLD.RDB$FIELD_PRECISION.NULL*/
						jrd_94.jrd_128 = FALSE;
					}

					if (subtype) {
						/*FLD.RDB$FIELD_SUB_TYPE*/
						jrd_94.jrd_127 = new_fld.dyn_sub_type;
						/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
						jrd_94.jrd_126 = FALSE;
					}

					if (charlen) {
						/*FLD.RDB$CHARACTER_LENGTH*/
						jrd_94.jrd_112 = new_fld.dyn_charlen;
						/*FLD.RDB$CHARACTER_LENGTH.NULL*/
						jrd_94.jrd_111 = FALSE;
					}

					if (charset) {
						/*FLD.RDB$CHARACTER_SET_ID*/
						jrd_94.jrd_110 = new_fld.dyn_charset;
						/*FLD.RDB$CHARACTER_SET_ID.NULL*/
						jrd_94.jrd_109 = FALSE;
					}

					if (collation) {
						/*FLD.RDB$COLLATION_ID*/
						jrd_94.jrd_108 = new_fld.dyn_collation;
						/*FLD.RDB$COLLATION_ID.NULL*/
						jrd_94.jrd_107 = FALSE;
					}

					if (fldlen) {
						// CVC: Rescue from the wrong field_length with a helper.
						if (new_fld.dyn_dsc.dsc_dtype <= dtype_varying && new_fld.dyn_charbytelen)
							/*FLD.RDB$FIELD_LENGTH*/
							jrd_94.jrd_104 = new_fld.dyn_charbytelen;
						else
							/*FLD.RDB$FIELD_LENGTH*/
							jrd_94.jrd_104 = new_fld.dyn_dsc.dsc_length;
						/*FLD.RDB$FIELD_LENGTH.NULL*/
						jrd_94.jrd_103 = FALSE;
					}

					if (new_fld.dyn_computed_val)
					{
						DYN_put_blr_blob(gbl, &new_fld.dyn_computed_val, &/*FLD.RDB$COMPUTED_BLR*/
												  jrd_94.jrd_102);
						/*FLD.RDB$COMPUTED_BLR.NULL*/
						jrd_94.jrd_123 = FALSE;
					}

					if (new_fld.dyn_computed_src)
					{
						DYN_put_text_blob(gbl, &new_fld.dyn_computed_src, &/*FLD.RDB$COMPUTED_SOURCE*/
												   jrd_94.jrd_101);
						/*FLD.RDB$COMPUTED_SOURCE.NULL*/
						jrd_94.jrd_122 = FALSE;
					}

					// Copy the field name into RDB$FIELDS
					strcpy(/*FLD.RDB$FIELD_NAME*/
					       jrd_94.jrd_95, new_fld.dyn_fld_source.c_str());
				/*END_STORE;*/
				if (!request)
				   request = CMP_compile2 (tdbb, (UCHAR*) jrd_93, sizeof(jrd_93), true);
				EXE_start (tdbb, request, gbl->gbl_transaction);
				EXE_send (tdbb, request, 0, 270, (UCHAR*) &jrd_94);
				}

				CMP_release(tdbb, request);
				request = NULL;

				if (ENCODE_ODS(dbb->dbb_ods_version, dbb->dbb_minor_original) >= ODS_11_2)
				{
					/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
						PRM IN RDB$PROCEDURE_PARAMETERS
						WITH PRM.RDB$RELATION_NAME = relation_name->c_str() AND
							 PRM.RDB$FIELD_NAME = orig_fld.dyn_fld_name.c_str()*/
					{
					if (!request)
					   request = CMP_compile2 (tdbb, (UCHAR*) jrd_82, sizeof(jrd_82), true);
					gds__vtov ((const char*) orig_fld.dyn_fld_name.c_str(), (char*) jrd_83.jrd_84, 32);
					gds__vtov ((const char*) relation_name->c_str(), (char*) jrd_83.jrd_85, 32);
					EXE_start (tdbb, request, gbl->gbl_transaction);
					EXE_send (tdbb, request, 0, 64, (UCHAR*) &jrd_83);
					while (1)
					   {
					   EXE_receive (tdbb, request, 1, 34, (UCHAR*) &jrd_86);
					   if (!jrd_86.jrd_88) break;

						/*MODIFY PRM USING*/
						{
						
							strcpy(/*PRM.RDB$FIELD_SOURCE*/
							       jrd_86.jrd_87, new_fld.dyn_fld_source.c_str());
						/*END_MODIFY;*/
						gds__vtov((const char*) jrd_86.jrd_87, (char*) jrd_89.jrd_90, 32);
						EXE_send (tdbb, request, 2, 32, (UCHAR*) &jrd_89);
						}
					/*END_FOR;*/
					   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_91);
					   }
					}

					CMP_release(tdbb, request);
					request = NULL;
				}
			}
			else if (changeDefault)
			{
				request = first_request;
				/*MODIFY RFR USING*/
				{
				
					if (dropDefault)
					{
						if (/*RFR.RDB$DEFAULT_VALUE.NULL*/
						    jrd_177.jrd_188)
						{
							if (sourceIsInternalDomain || !domain_has_default)
							{
								DYN_error_punt(false, 229, orig_fld.dyn_fld_name.c_str());
								// msg 229: "Local column %s doesn't have a default"
							}
							else if (domain_has_default)
							{
								DYN_error_punt(false, 230, SafeArg() << orig_fld.dyn_fld_name.c_str() <<
												orig_fld.dyn_fld_source.c_str());
								// msg 230: "Local column %s default belongs to domain %s"
							}
						}
						else
						{
							/*RFR.RDB$DEFAULT_VALUE.NULL*/
							jrd_177.jrd_188 = TRUE;
							/*RFR.RDB$DEFAULT_SOURCE.NULL*/
							jrd_177.jrd_187 = TRUE;
						}
					}
					else
					{
						if (domain_is_computed)
						{
							DYN_error_punt(false, 233, orig_fld.dyn_fld_name.c_str());
							// msg 233: "Local column %s is computed, cannot set a default value"
						}
						if (defVal)
						{
							const UCHAR* p = defVal;
							if (DYN_put_blr_blob(gbl, &p, &/*RFR.RDB$DEFAULT_VALUE*/
										       jrd_177.jrd_179))
								/*RFR.RDB$DEFAULT_VALUE.NULL*/
								jrd_177.jrd_188 = FALSE;
						}

						if (defSrc)
						{
							const UCHAR* p = defSrc;
							if (DYN_put_text_blob(gbl, &p, &/*RFR.RDB$DEFAULT_SOURCE*/
											jrd_177.jrd_178))
								/*RFR.RDB$DEFAULT_SOURCE.NULL*/
								jrd_177.jrd_187 = FALSE;
						}
					}
				/*END_MODIFY*/
				jrd_206.jrd_207 = jrd_177.jrd_179;
				jrd_206.jrd_208 = jrd_177.jrd_178;
				jrd_206.jrd_209 = jrd_177.jrd_188;
				jrd_206.jrd_210 = jrd_177.jrd_187;
				EXE_send (tdbb, request, 5, 20, (UCHAR*) &jrd_206);
				}
				first_request = request;
				request = NULL;
			}
			else //if (sourceIsInternalDomain)
			{	// The original and new definitions are both base types.
				// b2. Internal domain -> internal domain.
				// Modify in place, since there cannot be other fields using it.

				//if (!sourceIsInternalDomain)
				//	DYN_UTIL_copy_domain(tdbb, gbl, orig_fld.dyn_fld_source, new_fld.dyn_fld_source);

				/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
					FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME = RFR.RDB$FIELD_SOURCE*/
				{
				if (!request)
				   request = CMP_compile2 (tdbb, (UCHAR*) jrd_26, sizeof(jrd_26), true);
				gds__vtov ((const char*) jrd_177.jrd_182, (char*) jrd_27.jrd_28, 32);
				EXE_start (tdbb, request, gbl->gbl_transaction);
				EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_27);
				while (1)
				   {
				   EXE_receive (tdbb, request, 1, 74, (UCHAR*) &jrd_29);
				   if (!jrd_29.jrd_34) break;
					/*MODIFY FLD USING*/
					{
					

						if (dtype) {
							/*FLD.RDB$FIELD_TYPE*/
							jrd_29.jrd_54 = new_fld.dyn_dtype;
							/*FLD.RDB$FIELD_TYPE.NULL*/
							jrd_29.jrd_53 = FALSE;
						}

						if (scale) {
							/*FLD.RDB$FIELD_SCALE*/
							jrd_29.jrd_52 = new_fld.dyn_dsc.dsc_scale;
							/*FLD.RDB$FIELD_SCALE.NULL*/
							jrd_29.jrd_51 = FALSE;
						}

						if (prec) {
							/*FLD.RDB$FIELD_PRECISION*/
							jrd_29.jrd_50 = new_fld.dyn_precision;
							/*FLD.RDB$FIELD_PRECISION.NULL*/
							jrd_29.jrd_49 = FALSE;
						}

						if (subtype) {
							/*FLD.RDB$FIELD_SUB_TYPE*/
							jrd_29.jrd_48 = new_fld.dyn_sub_type;
							/*FLD.RDB$FIELD_SUB_TYPE.NULL*/
							jrd_29.jrd_47 = FALSE;
						}

						if (charlen) {
							/*FLD.RDB$CHARACTER_LENGTH*/
							jrd_29.jrd_46 = new_fld.dyn_charlen;
							/*FLD.RDB$CHARACTER_LENGTH.NULL*/
							jrd_29.jrd_45 = FALSE;
						}

						if (charset) {
							/*FLD.RDB$CHARACTER_SET_ID*/
							jrd_29.jrd_44 = new_fld.dyn_charset;
							/*FLD.RDB$CHARACTER_SET_ID.NULL*/
							jrd_29.jrd_43 = FALSE;
						}

						if (collation) {
							/*FLD.RDB$COLLATION_ID*/
							jrd_29.jrd_42 = new_fld.dyn_collation;
							/*FLD.RDB$COLLATION_ID.NULL*/
							jrd_29.jrd_41 = FALSE;
						}

						if (fldlen) {
							// CVC: Rescue from the wrong field_length with a helper.
							if (new_fld.dyn_dsc.dsc_dtype <= dtype_varying && new_fld.dyn_charbytelen)
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_29.jrd_40 = new_fld.dyn_charbytelen;
							else
								/*FLD.RDB$FIELD_LENGTH*/
								jrd_29.jrd_40 = new_fld.dyn_dsc.dsc_length;
							/*FLD.RDB$FIELD_LENGTH.NULL*/
							jrd_29.jrd_39 = FALSE;
						}

						if (changeComputed)
						{
							/*FLD.RDB$DEFAULT_SOURCE.NULL*/
							jrd_29.jrd_38 = TRUE;
							/*FLD.RDB$DEFAULT_VALUE.NULL*/
							jrd_29.jrd_37 = TRUE;

							if (new_fld.dyn_computed_val)
							{
								DYN_put_blr_blob(gbl, &new_fld.dyn_computed_val, &/*FLD.RDB$COMPUTED_BLR*/
														  jrd_29.jrd_31);
								/*FLD.RDB$COMPUTED_BLR.NULL*/
								jrd_29.jrd_36 = FALSE;
							}

							if (new_fld.dyn_computed_src)
							{
								DYN_put_text_blob(gbl, &new_fld.dyn_computed_src, &/*FLD.RDB$COMPUTED_SOURCE*/
														   jrd_29.jrd_30);
								/*FLD.RDB$COMPUTED_SOURCE.NULL*/
								jrd_29.jrd_35 = FALSE;
							}
						}

					/*END_MODIFY;*/
					jrd_55.jrd_56 = jrd_29.jrd_33;
					jrd_55.jrd_57 = jrd_29.jrd_32;
					jrd_55.jrd_58 = jrd_29.jrd_31;
					jrd_55.jrd_59 = jrd_29.jrd_30;
					jrd_55.jrd_60 = jrd_29.jrd_53;
					jrd_55.jrd_61 = jrd_29.jrd_54;
					jrd_55.jrd_62 = jrd_29.jrd_51;
					jrd_55.jrd_63 = jrd_29.jrd_52;
					jrd_55.jrd_64 = jrd_29.jrd_49;
					jrd_55.jrd_65 = jrd_29.jrd_50;
					jrd_55.jrd_66 = jrd_29.jrd_47;
					jrd_55.jrd_67 = jrd_29.jrd_48;
					jrd_55.jrd_68 = jrd_29.jrd_45;
					jrd_55.jrd_69 = jrd_29.jrd_46;
					jrd_55.jrd_70 = jrd_29.jrd_43;
					jrd_55.jrd_71 = jrd_29.jrd_44;
					jrd_55.jrd_72 = jrd_29.jrd_41;
					jrd_55.jrd_73 = jrd_29.jrd_42;
					jrd_55.jrd_74 = jrd_29.jrd_39;
					jrd_55.jrd_75 = jrd_29.jrd_40;
					jrd_55.jrd_76 = jrd_29.jrd_38;
					jrd_55.jrd_77 = jrd_29.jrd_37;
					jrd_55.jrd_78 = jrd_29.jrd_36;
					jrd_55.jrd_79 = jrd_29.jrd_35;
					EXE_send (tdbb, request, 2, 72, (UCHAR*) &jrd_55);
					}
				/*END_FOR;*/
				   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_80);
				   }
				} // FLD in RDB$FIELDS
				CMP_release(tdbb, request);
				if (domain_is_computed)
				{
					request = first_request;
					/*MODIFY RFR USING*/
					{
					
						/*RFR.RDB$UPDATE_FLAG.NULL*/
						jrd_177.jrd_191 = FALSE;
						/*RFR.RDB$UPDATE_FLAG*/
						jrd_177.jrd_192 = 1;
					/*END_MODIFY;*/
					jrd_203.jrd_204 = jrd_177.jrd_191;
					jrd_203.jrd_205 = jrd_177.jrd_192;
					EXE_send (tdbb, request, 4, 4, (UCHAR*) &jrd_203);
					}
					first_request = request;
				}

				request = NULL;
			}
		} // else not a domain

		request = first_request;

		if (fld_position_change || view_context_change || fld_base_field_change)
		{
			/*MODIFY RFR USING*/
			{
			
				if (fld_position_change)
					/*RFR.RDB$FIELD_POSITION*/
					jrd_177.jrd_186 = fld_position;
				if (view_context_change)
					/*RFR.RDB$VIEW_CONTEXT*/
					jrd_177.jrd_185 = view_context;
				if (fld_base_field_change)
				{
					/*RFR.RDB$BASE_FIELD.NULL*/
					jrd_177.jrd_194 = fld_base_field.isEmpty();
					strcpy(/*RFR.RDB$BASE_FIELD*/
					       jrd_177.jrd_180, fld_base_field.c_str());
				}
			/*END_MODIFY;*/
			gds__vtov((const char*) jrd_177.jrd_180, (char*) jrd_196.jrd_197, 32);
			jrd_196.jrd_198 = jrd_177.jrd_194;
			jrd_196.jrd_199 = jrd_177.jrd_186;
			jrd_196.jrd_200 = jrd_177.jrd_185;
			EXE_send (tdbb, request, 2, 38, (UCHAR*) &jrd_196);
			}
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_201);
	   }
	} // RFR IN RDB$RELATION_FIELDS
	CMP_release(tdbb, request);
	request = NULL;

	if (!found)
	{
		DYN_error_punt(false, 176, SafeArg() << orig_fld.dyn_fld_name.c_str() <<
						relation_name->c_str());
		// msg 176: "column %s does not exist in table/view %s"
	}

	// Update any indices that exist
	modify_lfield_index(tdbb, gbl, *relation_name, orig_fld.dyn_fld_name, orig_fld.dyn_fld_name);

	}
	catch (const Exception& ex) {
		stuff_exception(tdbb->tdbb_status_vector, ex);
		DYN_error_punt(true, 95);
		// msg 95: "MODIFY RDB$RELATION_FIELDS failed"
	}
}


// *************************************
// D Y N _ m o d i f y _ m a p p i n g
// *************************************
// It's purpose is to add/drop mapping from OS security name
// to DB security object
void DYN_modify_mapping(Global* gbl, const UCHAR** ptr)
{
   struct {
          SSHORT jrd_25;	// gds__utility 
   } jrd_24;
   struct {
          SSHORT jrd_23;	// RDB$SYSTEM_FLAG 
   } jrd_22;
   struct {
          SSHORT jrd_20;	// gds__utility 
          SSHORT jrd_21;	// RDB$SYSTEM_FLAG 
   } jrd_19;
   struct {
          TEXT  jrd_18 [32];	// RDB$ROLE_NAME 
   } jrd_17;
	thread_db* tdbb = JRD_get_thread_data();
	Database* dbb = tdbb->getDatabase();

	jrd_req* request = CMP_find_request(tdbb, drq_m_map, DYN_REQUESTS);
	bool found = false;

	string osName, dbName;
	GET_STRING(ptr, osName);
	const UCHAR op = *(*ptr)++;
	GET_STRING(ptr, dbName);

	// This is FB 2.5 limited implementation!
	// Later it should work with new system table, something like RDB$MAPPING.

	if (dbName != ADMIN_ROLE)
	{
		status_exception::raise(Arg::Gds(isc_no_meta_update) << Arg::Gds(isc_wish_list));
	}

	if (!(tdbb->getAttachment() && tdbb->getAttachment()->locksmith()))
		ERR_post(Arg::Gds(isc_adm_task_denied));

	found = false;
	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		X IN RDB$ROLES
			WITH X.RDB$ROLE_NAME EQ dbName.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_16, sizeof(jrd_16), true);
	gds__vtov ((const char*) dbName.c_str(), (char*) jrd_17.jrd_18, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_17);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 4, (UCHAR*) &jrd_19);
	   if (!jrd_19.jrd_20) break;

		if (!DYN_REQUEST(drq_m_map))
			DYN_REQUEST(drq_m_map) = request;

		found = true;
		/*MODIFY X*/
		{
		
			switch (op)
			{
			case isc_dyn_automap_role:
				/*X.RDB$SYSTEM_FLAG*/
				jrd_19.jrd_21 = ROLE_FLAG_DBO | ROLE_FLAG_MAY_TRUST;
				break;

			case isc_dyn_autounmap_role:
				/*X.RDB$SYSTEM_FLAG*/
				jrd_19.jrd_21 = ROLE_FLAG_DBO;
				break;

			default:
				DYN_unsupported_verb();
			}
		/*END_MODIFY;*/
		jrd_22.jrd_23 = jrd_19.jrd_21;
		EXE_send (tdbb, request, 2, 2, (UCHAR*) &jrd_22);
		}
	/*END_FOR;*/
	   EXE_send (tdbb, request, 3, 2, (UCHAR*) &jrd_24);
	   }
	}

	if (!DYN_REQUEST(drq_m_map))
		DYN_REQUEST(drq_m_map) = request;

	if (!found)
	{
		status_exception::raise(Arg::Gds(isc_no_meta_update) <<
			Arg::Gds(isc_random) << Arg::Str("Missing RDB$ADMIN role in the database"));
	}
}

void get_domain_type(thread_db* tdbb, Global* gbl, dyn_fld& dom_fld)
{
   struct {
          SSHORT jrd_4;	// gds__utility 
          SSHORT jrd_5;	// gds__null_flag 
          SSHORT jrd_6;	// RDB$DIMENSIONS 
          SSHORT jrd_7;	// RDB$NULL_FLAG 
          SSHORT jrd_8;	// RDB$CHARACTER_LENGTH 
          SSHORT jrd_9;	// RDB$FIELD_PRECISION 
          SSHORT jrd_10;	// RDB$COLLATION_ID 
          SSHORT jrd_11;	// RDB$CHARACTER_SET_ID 
          SSHORT jrd_12;	// RDB$FIELD_SUB_TYPE 
          SSHORT jrd_13;	// RDB$FIELD_LENGTH 
          SSHORT jrd_14;	// RDB$FIELD_SCALE 
          SSHORT jrd_15;	// RDB$FIELD_TYPE 
   } jrd_3;
   struct {
          TEXT  jrd_2 [32];	// RDB$FIELD_NAME 
   } jrd_1;
/**************************************
 *
 *	g e t _ d o m a i n _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Retrieves the type information for a domain so
 *      that it can be compared to a local field before
 *      modifying the datatype of a field.
 *
 **************************************/
	jrd_req* request = NULL;

	/*FOR(REQUEST_HANDLE request TRANSACTION_HANDLE gbl->gbl_transaction)
		FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME EQ dom_fld.dyn_fld_source.c_str()*/
	{
	if (!request)
	   request = CMP_compile2 (tdbb, (UCHAR*) jrd_0, sizeof(jrd_0), true);
	gds__vtov ((const char*) dom_fld.dyn_fld_source.c_str(), (char*) jrd_1.jrd_2, 32);
	EXE_start (tdbb, request, gbl->gbl_transaction);
	EXE_send (tdbb, request, 0, 32, (UCHAR*) &jrd_1);
	while (1)
	   {
	   EXE_receive (tdbb, request, 1, 24, (UCHAR*) &jrd_3);
	   if (!jrd_3.jrd_4) break;;

		DSC_make_descriptor(&dom_fld.dyn_dsc,
							/*FLD.RDB$FIELD_TYPE*/
							jrd_3.jrd_15,
							/*FLD.RDB$FIELD_SCALE*/
							jrd_3.jrd_14,
							/*FLD.RDB$FIELD_LENGTH*/
							jrd_3.jrd_13,
							/*FLD.RDB$FIELD_SUB_TYPE*/
							jrd_3.jrd_12,
							/*FLD.RDB$CHARACTER_SET_ID*/
							jrd_3.jrd_11,
							/*FLD.RDB$COLLATION_ID*/
							jrd_3.jrd_10);

		dom_fld.dyn_charbytelen = /*FLD.RDB$FIELD_LENGTH*/
					  jrd_3.jrd_13;
		dom_fld.dyn_dtype = /*FLD.RDB$FIELD_TYPE*/
				    jrd_3.jrd_15;
		dom_fld.dyn_precision = /*FLD.RDB$FIELD_PRECISION*/
					jrd_3.jrd_9;
		dom_fld.dyn_sub_type = /*FLD.RDB$FIELD_SUB_TYPE*/
				       jrd_3.jrd_12;
		dom_fld.dyn_charlen = /*FLD.RDB$CHARACTER_LENGTH*/
				      jrd_3.jrd_8;
		dom_fld.dyn_collation = /*FLD.RDB$COLLATION_ID*/
					jrd_3.jrd_10;
		dom_fld.dyn_null_flag = /*FLD.RDB$NULL_FLAG*/
					jrd_3.jrd_7 != 0;

		if (!/*FLD.RDB$DIMENSIONS.NULL*/
		     jrd_3.jrd_5 && /*FLD.RDB$DIMENSIONS*/
    jrd_3.jrd_6 > 0)
			dom_fld.dyn_dtype = blr_blob;

	/*END_FOR;*/
	   }
	}
	CMP_release(tdbb, request);
}


static ULONG check_update_fld_type(const dyn_fld& orig_fld,
									const dyn_fld& new_fld)
{
/**************************************
 *
 *	c h e c k _ u p d a t e _ f l d _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Compare the original field type with the new field type to
 *      determine if the original type can be changed to the new type
 *
 *  The following conversions are not allowed:
 *        Blob to anything
 *        Array to anything
 *        Date to anything
 *        Char to any numeric
 *        Varchar to any numeric
 *        Anything to Blob
 *        Anything to Array
 *
 *  This function returns an error code if the conversion can not be
 *  made.  If the conversion can be made, FB_SUCCESS is returned
 **************************************/


/* Check to make sure that the old and new types are compatible */
	switch (orig_fld.dyn_dtype)
	{
/* CHARACTER types */
	case blr_text:
	case blr_varying:
	case blr_cstring:
		switch (new_fld.dyn_dtype)
		{
		case blr_blob:
		case blr_blob_id:
			return isc_dyn_dtype_invalid;
			/* Cannot change datatype for column %s.
			   The operation cannot be performed on BLOB, or ARRAY columns. */
			break;

		case blr_sql_date:
		case blr_sql_time:
		case blr_timestamp:
		case blr_int64:
		case blr_long:
		case blr_short:
		case blr_d_float:
		case blr_double:
		case blr_float:
			return isc_dyn_dtype_conv_invalid;
			/* Cannot convert column %s from character to non-character data. */
			break;

			/* If the original field is a character field and the new field is a character field,
			 * is there enough space in the new field? */
		case blr_text:
		case blr_varying:
		case blr_cstring:
			{
				/* CVC: Because our caller invoked DSC_make_descriptor() on new_fld previously,
						we should have the added bytes for varchar. For cstring, we are done, since
						DSC_make_descriptor(DSC_string_length) != DSC_string_length(DSC_make_descriptor). */

				const USHORT maxflen = DSC_string_length(&orig_fld.dyn_dsc);

				/* We can have this assertion since this case is for both string fields. */
				const ULONG new_len = DSC_string_length(&new_fld.dyn_dsc);
				fb_assert(new_len - maxflen == (ULONG) new_fld.dyn_charbytelen - orig_fld.dyn_charbytelen);
				// if (new_fld.dyn_dsc.dsc_length < maxflen)
				if (new_len < maxflen)
					return isc_dyn_char_fld_too_small;
				// msg 208: New size specified for column %s must be at least %d characters.
			}
			break;

		default:
			fb_assert(FALSE);
			return 87;			/* MODIFY RDB$FIELDS FAILED */
		}
		break;

/* BLOB and ARRAY types */
	case blr_blob:
	case blr_blob_id:
		return isc_dyn_dtype_invalid;
		/* Cannot change datatype for column %s.
		   The operation cannot be performed on BLOB, or ARRAY columns. */

/* DATE types */
	case blr_sql_date:
	case blr_sql_time:
	case blr_timestamp:
		switch (new_fld.dyn_dtype)
		{
		case blr_sql_date:
			if (orig_fld.dyn_dtype == blr_sql_time)
				return isc_dyn_invalid_dtype_conversion;
			/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			break;

		case blr_sql_time:
			if (orig_fld.dyn_dtype == blr_sql_date)
				return isc_dyn_invalid_dtype_conversion;
			/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			break;

		case blr_timestamp:
			if (orig_fld.dyn_dtype == blr_sql_time)
				return isc_dyn_invalid_dtype_conversion;
			/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			break;

			/* If the original field is a date field and the new field is a character field,
			   * is there enough space in the new field? */
		case blr_text:
		case blr_text2:
		case blr_varying:
		case blr_varying2:
		case blr_cstring:
		case blr_cstring2:
			{
				const USHORT maxflen = DSC_string_length(&orig_fld.dyn_dsc);

				// CVC: Solve bug #910423, missing DSC_string_length call.
				// if (new_fld.dyn_dsc.dsc_length < maxflen)
				if (DSC_string_length(&new_fld.dyn_dsc) < maxflen)
					return isc_dyn_char_fld_too_small;
				// msg 208: New size specified for column %s must be at least %d characters.
			}

			break;

		default:
			return isc_dyn_invalid_dtype_conversion;
			/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
		}
		break;

/* NUMERIC types */
	case blr_int64:
	case blr_long:
	case blr_short:
	case blr_d_float:
	case blr_double:
	case blr_float:
		switch (new_fld.dyn_dtype)
		{
		case blr_blob:
		case blr_blob_id:
			return isc_dyn_dtype_invalid;
			/* Cannot change datatype for column %s.
			   The operation cannot be performed on BLOB, or ARRAY columns. */

		case blr_sql_date:
		case blr_sql_time:
		case blr_timestamp:
			return isc_dyn_invalid_dtype_conversion;
			/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */

			/* If the original field is a numeric field and the new field is a numeric field,
			 * is there enough space in the new field (do not allow the base type to decrease) */

		case blr_short:
			switch (orig_fld.dyn_dtype)
			{
			case blr_short:
				return check_update_numeric_type(orig_fld, new_fld);

			default:
				return isc_dyn_invalid_dtype_conversion;
				/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			}
			break;

		case blr_long:
			switch (orig_fld.dyn_dtype)
			{
			case blr_long:
			case blr_short:
				return check_update_numeric_type(orig_fld, new_fld);

			default:
				return isc_dyn_invalid_dtype_conversion;
				/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			}
			break;

		case blr_float:
			switch (orig_fld.dyn_dtype)
			{
			case blr_float:
			case blr_short:
				break;

			default:
				return isc_dyn_invalid_dtype_conversion;
				/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			}
			break;

		case blr_int64:
			switch (orig_fld.dyn_dtype)
			{
			case blr_int64:
			case blr_long:
			case blr_short:
				return check_update_numeric_type(orig_fld, new_fld);

			default:
				return isc_dyn_invalid_dtype_conversion;
				/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			}
			break;

		case blr_d_float:
		case blr_double:
			switch (orig_fld.dyn_dtype)
			{
			case blr_double:
			case blr_d_float:
			case blr_float:
			case blr_short:
			case blr_long:
				break;

			default:
				return isc_dyn_invalid_dtype_conversion;
				/* Cannot change datatype for column %s.  Conversion from base type %s to base type %s is not supported. */
			}
			break;

			/* If the original field is a numeric field and the new field is a character field,
			 * is there enough space in the new field? */
		case blr_text:
		case blr_varying:
		case blr_cstring:
			{
				const USHORT maxflen = DSC_string_length(&orig_fld.dyn_dsc);

				// CVC: Solve bug #910423, missing DSC_string_length call.
				// if (new_fld.dyn_dsc.dsc_length < maxflen)
				if (DSC_string_length(&new_fld.dyn_dsc) < maxflen)
					return isc_dyn_char_fld_too_small;
				// msg 208: New size specified for column %s must be at least %d characters.
			}
			break;

		default:
			fb_assert(FALSE);
			return 87;			/* MODIFY RDB$FIELDS FAILED */
		}
		break;

	default:
		fb_assert(FALSE);
		return 87;				/* MODIFY RDB$FIELDS FAILED */
	}
	return FB_SUCCESS;
}


static ULONG check_update_numeric_type(const dyn_fld& orig_fld, const dyn_fld& new_fld)
{
/**************************************
 *
 *	c h e c k _ u p d a t e _ n u m e r i c _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Compare the original field type with the new field type to
 *      determine if the original type can be changed to the new type.
 *  The types should be integral, since it tests only numeric/decimal subtypes
 *      to ensure the scale is not being widened at the expense of the precision,
 *      because the old stored values should fit in the new definition.
 *
 *  This function returns an error code if the conversion can not be
 *  made.  If the conversion can be made, FB_SUCCESS is returned.
 **************************************/

 	// Since dsc_scale is negative, the sum of precision and scale produces
	// the width of the integral part.
	if (orig_fld.dyn_sub_type && new_fld.dyn_sub_type &&
		orig_fld.dyn_precision + orig_fld.dyn_dsc.dsc_scale >
			new_fld.dyn_precision + new_fld.dyn_dsc.dsc_scale)
	{
		return isc_dyn_scale_too_big;
	}
	return FB_SUCCESS;
}


static void modify_err_punt(thread_db* /*tdbb*/,
							ULONG errorcode,
							const dyn_fld& orig_fld_def,
							const dyn_fld& new_fld_def)
{
/**************************************
 *
 *	m o d i f y _ e r r _ p u n t
 *
 **************************************
 *
 * Functional description
 *	A generic error routine that calls DYN_error_punt
 *      based on the error code returned by check_update_field_type.
 *
 *      This function is called by DYN_modify_global_field and by
 *	DYN_modify_sql_field
 **************************************/

	switch (errorcode)
	{
	case isc_dyn_dtype_invalid:
		DYN_error_punt(false, errorcode, orig_fld_def.dyn_fld_name.c_str());
		/* Cannot change datatype for column %s.The operation cannot be performed on DATE, BLOB, or ARRAY columns. */
		break;

	case isc_dyn_dtype_conv_invalid:
		DYN_error_punt(false, errorcode, orig_fld_def.dyn_fld_name.c_str());
		/* Cannot convert column %s from character to non-character data. */
		break;

	case isc_dyn_char_fld_too_small:
		DYN_error_punt(false,
						errorcode,
						SafeArg() << orig_fld_def.dyn_fld_name.c_str() <<
						DSC_string_length(&orig_fld_def.dyn_dsc));
		// msg 208: New size specified for column %s must be at least %d characters.
		break;

	case isc_dyn_scale_too_big:
		{
			int code = errorcode;
			int diff = new_fld_def.dyn_precision -
				(orig_fld_def.dyn_precision + orig_fld_def.dyn_dsc.dsc_scale);
			if (diff < 0)
			{
				// If new scale becomes negative externally, the message is useless for the user.
				// (The scale is always zero or negative for us but externally is non-negative.)
				// Let's ask the user to widen the precision, then. Example: numeric(4, 0) -> numeric(1, 1).
				code = isc_dyn_precision_too_small;
				diff = new_fld_def.dyn_precision - new_fld_def.dyn_dsc.dsc_scale - diff;
			}
			DYN_error_punt(false, code, SafeArg() << orig_fld_def.dyn_fld_name.c_str() << diff);
			// scale_too_big: New scale specified for column @1 must be at most @2.
			// precision_too_small: New precision specified for column @1 must be at least @2.
		}
		break;

	case isc_dyn_invalid_dtype_conversion:
		{
			TEXT orig_type[25], new_type[25];

			DSC_get_dtype_name(&orig_fld_def.dyn_dsc, orig_type, sizeof(orig_type));
			DSC_get_dtype_name(&new_fld_def.dyn_dsc, new_type, sizeof(new_type));

			DYN_error_punt(false, errorcode,
							SafeArg() << orig_fld_def.dyn_fld_name.c_str() <<
							orig_type << new_type);
			// Cannot change datatype for @1.  Conversion from base type @2 to @3 is not supported.
		}
		break;

	default:
		DYN_error_punt(true, 95);
		/* msg 95: "MODIFY RDB$RELATION_FIELDS failed" */
	}
}
